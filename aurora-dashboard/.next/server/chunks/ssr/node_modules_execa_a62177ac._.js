module.exports = [
"[project]/node_modules/execa/lib/arguments/file-url.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isDenoExecPath",
    ()=>isDenoExecPath,
    "normalizeFileUrl",
    ()=>normalizeFileUrl,
    "safeNormalizeFileUrl",
    ()=>safeNormalizeFileUrl
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
;
const safeNormalizeFileUrl = (file, name)=>{
    const fileString = normalizeFileUrl(normalizeDenoExecPath(file));
    if (typeof fileString !== 'string') {
        throw new TypeError(`${name} must be a string or a file URL: ${fileString}.`);
    }
    return fileString;
};
// In Deno node:process execPath is a special object, not just a string:
// https://github.com/denoland/deno/blob/f460188e583f00144000aa0d8ade08218d47c3c1/ext/node/polyfills/process.ts#L344
const normalizeDenoExecPath = (file)=>isDenoExecPath(file) ? file.toString() : file;
const isDenoExecPath = (file)=>typeof file !== 'string' && file && Object.getPrototypeOf(file) === String.prototype;
const normalizeFileUrl = (file)=>file instanceof URL ? (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["fileURLToPath"])(file) : file;
}),
"[project]/node_modules/execa/lib/methods/parameters.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizeParameters",
    ()=>normalizeParameters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/file-url.js [app-ssr] (ecmascript)");
;
;
const normalizeParameters = (rawFile, rawArguments = [], rawOptions = {})=>{
    const filePath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeNormalizeFileUrl"])(rawFile, 'First argument');
    const [commandArguments, options] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(rawArguments) ? [
        [],
        rawArguments
    ] : [
        rawArguments,
        rawOptions
    ];
    if (!Array.isArray(commandArguments)) {
        throw new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);
    }
    if (commandArguments.some((commandArgument)=>typeof commandArgument === 'object' && commandArgument !== null)) {
        throw new TypeError(`Second argument must be an array of strings: ${commandArguments}`);
    }
    const normalizedArguments = commandArguments.map(String);
    const nullByteArgument = normalizedArguments.find((normalizedArgument)=>normalizedArgument.includes('\0'));
    if (nullByteArgument !== undefined) {
        throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${nullByteArgument}`);
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(options)) {
        throw new TypeError(`Last argument must be an options object: ${options}`);
    }
    return [
        filePath,
        normalizedArguments,
        options
    ];
};
}),
"[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bufferToUint8Array",
    ()=>bufferToUint8Array,
    "concatUint8Arrays",
    ()=>concatUint8Arrays,
    "isArrayBuffer",
    ()=>isArrayBuffer,
    "isUint8Array",
    ()=>isUint8Array,
    "joinToString",
    ()=>joinToString,
    "joinToUint8Array",
    ()=>joinToUint8Array,
    "uint8ArrayToString",
    ()=>uint8ArrayToString
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$string_decoder__$5b$external$5d$__$28$node$3a$string_decoder$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:string_decoder [external] (node:string_decoder, cjs)");
;
const { toString: objectToString } = Object.prototype;
const isArrayBuffer = (value)=>objectToString.call(value) === '[object ArrayBuffer]';
const isUint8Array = (value)=>objectToString.call(value) === '[object Uint8Array]';
const bufferToUint8Array = (buffer)=>new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
const textEncoder = new TextEncoder();
const stringToUint8Array = (string)=>textEncoder.encode(string);
const textDecoder = new TextDecoder();
const uint8ArrayToString = (uint8Array)=>textDecoder.decode(uint8Array);
const joinToString = (uint8ArraysOrStrings, encoding)=>{
    const strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);
    return strings.join('');
};
const uint8ArraysToStrings = (uint8ArraysOrStrings, encoding)=>{
    if (encoding === 'utf8' && uint8ArraysOrStrings.every((uint8ArrayOrString)=>typeof uint8ArrayOrString === 'string')) {
        return uint8ArraysOrStrings;
    }
    const decoder = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$string_decoder__$5b$external$5d$__$28$node$3a$string_decoder$2c$__cjs$29$__["StringDecoder"](encoding);
    const strings = uint8ArraysOrStrings.map((uint8ArrayOrString)=>typeof uint8ArrayOrString === 'string' ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString).map((uint8Array)=>decoder.write(uint8Array));
    const finalString = decoder.end();
    return finalString === '' ? strings : [
        ...strings,
        finalString
    ];
};
const joinToUint8Array = (uint8ArraysOrStrings)=>{
    if (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {
        return uint8ArraysOrStrings[0];
    }
    return concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));
};
const stringsToUint8Arrays = (uint8ArraysOrStrings)=>uint8ArraysOrStrings.map((uint8ArrayOrString)=>typeof uint8ArrayOrString === 'string' ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString);
const concatUint8Arrays = (uint8Arrays)=>{
    const result = new Uint8Array(getJoinLength(uint8Arrays));
    let index = 0;
    for (const uint8Array of uint8Arrays){
        result.set(uint8Array, index);
        index += uint8Array.length;
    }
    return result;
};
const getJoinLength = (uint8Arrays)=>{
    let joinLength = 0;
    for (const uint8Array of uint8Arrays){
        joinLength += uint8Array.length;
    }
    return joinLength;
};
}),
"[project]/node_modules/execa/lib/methods/template.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isTemplateString",
    ()=>isTemplateString,
    "parseTemplates",
    ()=>parseTemplates
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:child_process [external] (node:child_process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
;
;
;
const isTemplateString = (templates)=>Array.isArray(templates) && Array.isArray(templates.raw);
const parseTemplates = (templates, expressions)=>{
    let tokens = [];
    for (const [index, template] of templates.entries()){
        tokens = parseTemplate({
            templates,
            expressions,
            tokens,
            index,
            template
        });
    }
    if (tokens.length === 0) {
        throw new TypeError('Template script must not be empty');
    }
    const [file, ...commandArguments] = tokens;
    return [
        file,
        commandArguments,
        {}
    ];
};
const parseTemplate = ({ templates, expressions, tokens, index, template })=>{
    if (template === undefined) {
        throw new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);
    }
    const { nextTokens, leadingWhitespaces, trailingWhitespaces } = splitByWhitespaces(template, templates.raw[index]);
    const newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);
    if (index === expressions.length) {
        return newTokens;
    }
    const expression = expressions[index];
    const expressionTokens = Array.isArray(expression) ? expression.map((expression)=>parseExpression(expression)) : [
        parseExpression(expression)
    ];
    return concatTokens(newTokens, expressionTokens, trailingWhitespaces);
};
// Like `string.split(/[ \t\r\n]+/)` except newlines and tabs are:
//  - ignored when input as a backslash sequence like: `echo foo\n bar`
//  - not ignored when input directly
// The only way to distinguish those in JavaScript is to use a tagged template and compare:
//  - the first array argument, which does not escape backslash sequences
//  - its `raw` property, which escapes them
const splitByWhitespaces = (template, rawTemplate)=>{
    if (rawTemplate.length === 0) {
        return {
            nextTokens: [],
            leadingWhitespaces: false,
            trailingWhitespaces: false
        };
    }
    const nextTokens = [];
    let templateStart = 0;
    const leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);
    for(let templateIndex = 0, rawIndex = 0; templateIndex < template.length; templateIndex += 1, rawIndex += 1){
        const rawCharacter = rawTemplate[rawIndex];
        if (DELIMITERS.has(rawCharacter)) {
            if (templateStart !== templateIndex) {
                nextTokens.push(template.slice(templateStart, templateIndex));
            }
            templateStart = templateIndex + 1;
        } else if (rawCharacter === '\\') {
            const nextRawCharacter = rawTemplate[rawIndex + 1];
            if (nextRawCharacter === '\n') {
                // Handles escaped newlines in templates
                templateIndex -= 1;
                rawIndex += 1;
            } else if (nextRawCharacter === 'u' && rawTemplate[rawIndex + 2] === '{') {
                rawIndex = rawTemplate.indexOf('}', rawIndex + 3);
            } else {
                rawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;
            }
        }
    }
    const trailingWhitespaces = templateStart === template.length;
    if (!trailingWhitespaces) {
        nextTokens.push(template.slice(templateStart));
    }
    return {
        nextTokens,
        leadingWhitespaces,
        trailingWhitespaces
    };
};
const DELIMITERS = new Set([
    ' ',
    '\t',
    '\r',
    '\n'
]);
// Number of characters in backslash escape sequences: \0 \xXX or \uXXXX
// \cX is allowed in RegExps but not in strings
// Octal sequences are not allowed in strict mode
const ESCAPE_LENGTH = {
    x: 3,
    u: 5
};
const concatTokens = (tokens, nextTokens, isSeparated)=>isSeparated || tokens.length === 0 || nextTokens.length === 0 ? [
        ...tokens,
        ...nextTokens
    ] : [
        ...tokens.slice(0, -1),
        `${tokens.at(-1)}${nextTokens[0]}`,
        ...nextTokens.slice(1)
    ];
// Handle `${expression}` inside the template string syntax
const parseExpression = (expression)=>{
    const typeOfExpression = typeof expression;
    if (typeOfExpression === 'string') {
        return expression;
    }
    if (typeOfExpression === 'number') {
        return String(expression);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(expression) && ('stdout' in expression || 'isMaxBuffer' in expression)) {
        return getSubprocessResult(expression);
    }
    if (expression instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["ChildProcess"] || Object.prototype.toString.call(expression) === '[object Promise]') {
        // eslint-disable-next-line no-template-curly-in-string
        throw new TypeError('Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.');
    }
    throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
const getSubprocessResult = ({ stdout })=>{
    if (typeof stdout === 'string') {
        return stdout;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUint8Array"])(stdout)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uint8ArrayToString"])(stdout);
    }
    if (stdout === undefined) {
        throw new TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\' "stdout" option.');
    }
    throw new TypeError(`Unexpected "${typeof stdout}" stdout in template expression`);
};
}),
"[project]/node_modules/execa/lib/utils/standard-stream.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "STANDARD_STREAMS",
    ()=>STANDARD_STREAMS,
    "STANDARD_STREAMS_ALIASES",
    ()=>STANDARD_STREAMS_ALIASES,
    "getStreamName",
    ()=>getStreamName,
    "isStandardStream",
    ()=>isStandardStream
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
;
const isStandardStream = (stream)=>STANDARD_STREAMS.includes(stream);
const STANDARD_STREAMS = [
    __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin,
    __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdout,
    __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stderr
];
const STANDARD_STREAMS_ALIASES = [
    'stdin',
    'stdout',
    'stderr'
];
const getStreamName = (fdNumber)=>STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;
}),
"[project]/node_modules/execa/lib/arguments/specific.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FD_SPECIFIC_OPTIONS",
    ()=>FD_SPECIFIC_OPTIONS,
    "getFdSpecificValue",
    ()=>getFdSpecificValue,
    "normalizeFdSpecificOption",
    ()=>normalizeFdSpecificOption,
    "normalizeFdSpecificOptions",
    ()=>normalizeFdSpecificOptions,
    "parseFd",
    ()=>parseFd
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-ssr] (ecmascript)");
;
;
;
const normalizeFdSpecificOptions = (options)=>{
    const optionsCopy = {
        ...options
    };
    for (const optionName of FD_SPECIFIC_OPTIONS){
        optionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);
    }
    return optionsCopy;
};
const normalizeFdSpecificOption = (options, optionName)=>{
    const optionBaseArray = Array.from({
        length: getStdioLength(options) + 1
    });
    const optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);
    return addDefaultValue(optionArray, optionName);
};
const getStdioLength = ({ stdio })=>Array.isArray(stdio) ? Math.max(stdio.length, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].length) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].length;
const normalizeFdSpecificValue = (optionValue, optionArray, optionName)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(optionValue) ? normalizeOptionObject(optionValue, optionArray, optionName) : optionArray.fill(optionValue);
const normalizeOptionObject = (optionValue, optionArray, optionName)=>{
    for (const fdName of Object.keys(optionValue).sort(compareFdName)){
        for (const fdNumber of parseFdName(fdName, optionName, optionArray)){
            optionArray[fdNumber] = optionValue[fdName];
        }
    }
    return optionArray;
};
// Ensure priority order when setting both `stdout`/`stderr`, `fd1`/`fd2`, and `all`
const compareFdName = (fdNameA, fdNameB)=>getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;
const getFdNameOrder = (fdName)=>{
    if (fdName === 'stdout' || fdName === 'stderr') {
        return 0;
    }
    return fdName === 'all' ? 2 : 1;
};
const parseFdName = (fdName, optionName, optionArray)=>{
    if (fdName === 'ipc') {
        return [
            optionArray.length - 1
        ];
    }
    const fdNumber = parseFd(fdName);
    if (fdNumber === undefined || fdNumber === 0) {
        throw new TypeError(`"${optionName}.${fdName}" is invalid.
It must be "${optionName}.stdout", "${optionName}.stderr", "${optionName}.all", "${optionName}.ipc", or "${optionName}.fd3", "${optionName}.fd4" (and so on).`);
    }
    if (fdNumber >= optionArray.length) {
        throw new TypeError(`"${optionName}.${fdName}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
    }
    return fdNumber === 'all' ? [
        1,
        2
    ] : [
        fdNumber
    ];
};
const parseFd = (fdName)=>{
    if (fdName === 'all') {
        return fdName;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].includes(fdName)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].indexOf(fdName);
    }
    const regexpResult = FD_REGEXP.exec(fdName);
    if (regexpResult !== null) {
        return Number(regexpResult[1]);
    }
};
const FD_REGEXP = /^fd(\d+)$/;
const addDefaultValue = (optionArray, optionName)=>optionArray.map((optionValue)=>optionValue === undefined ? DEFAULT_OPTIONS[optionName] : optionValue);
// Default value for the `verbose` option
const verboseDefault = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["debuglog"])('execa').enabled ? 'full' : 'none';
const DEFAULT_OPTIONS = {
    lines: false,
    buffer: true,
    maxBuffer: 1000 * 1000 * 100,
    verbose: verboseDefault,
    stripFinalNewline: true
};
const FD_SPECIFIC_OPTIONS = [
    'lines',
    'buffer',
    'maxBuffer',
    'verbose',
    'stripFinalNewline'
];
const getFdSpecificValue = (optionArray, fdNumber)=>fdNumber === 'ipc' ? optionArray.at(-1) : optionArray[fdNumber];
}),
"[project]/node_modules/execa/lib/verbose/values.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VERBOSE_VALUES",
    ()=>VERBOSE_VALUES,
    "getVerboseFunction",
    ()=>getVerboseFunction,
    "isFullVerbose",
    ()=>isFullVerbose,
    "isVerbose",
    ()=>isVerbose,
    "isVerboseFunction",
    ()=>isVerboseFunction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-ssr] (ecmascript)");
;
const isVerbose = ({ verbose }, fdNumber)=>getFdVerbose(verbose, fdNumber) !== 'none';
const isFullVerbose = ({ verbose }, fdNumber)=>![
        'none',
        'short'
    ].includes(getFdVerbose(verbose, fdNumber));
const getVerboseFunction = ({ verbose }, fdNumber)=>{
    const fdVerbose = getFdVerbose(verbose, fdNumber);
    return isVerboseFunction(fdVerbose) ? fdVerbose : undefined;
};
// When using `verbose: {stdout, stderr, fd3, ipc}`:
//  - `verbose.stdout|stderr|fd3` is used for 'output'
//  - `verbose.ipc` is only used for 'ipc'
//  - highest `verbose.*` value is used for 'command', 'error' and 'duration'
const getFdVerbose = (verbose, fdNumber)=>fdNumber === undefined ? getFdGenericVerbose(verbose) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFdSpecificValue"])(verbose, fdNumber);
// When using `verbose: {stdout, stderr, fd3, ipc}` and logging is not specific to a file descriptor.
// We then use the highest `verbose.*` value, using the following order:
//  - function > 'full' > 'short' > 'none'
//  - if several functions are defined: stdout > stderr > fd3 > ipc
const getFdGenericVerbose = (verbose)=>verbose.find((fdVerbose)=>isVerboseFunction(fdVerbose)) ?? VERBOSE_VALUES.findLast((fdVerbose)=>verbose.includes(fdVerbose));
const isVerboseFunction = (fdVerbose)=>typeof fdVerbose === 'function';
const VERBOSE_VALUES = [
    'none',
    'short',
    'full'
];
}),
"[project]/node_modules/execa/lib/arguments/escape.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "escapeLines",
    ()=>escapeLines,
    "joinCommand",
    ()=>joinCommand
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
;
;
const joinCommand = (filePath, rawArguments)=>{
    const fileAndArguments = [
        filePath,
        ...rawArguments
    ];
    const command = fileAndArguments.join(' ');
    const escapedCommand = fileAndArguments.map((fileAndArgument)=>quoteString(escapeControlCharacters(fileAndArgument))).join(' ');
    return {
        command,
        escapedCommand
    };
};
const escapeLines = (lines)=>(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["stripVTControlCharacters"])(lines).split('\n').map((line)=>escapeControlCharacters(line)).join('\n');
const escapeControlCharacters = (line)=>line.replaceAll(SPECIAL_CHAR_REGEXP, (character)=>escapeControlCharacter(character));
const escapeControlCharacter = (character)=>{
    const commonEscape = COMMON_ESCAPES[character];
    if (commonEscape !== undefined) {
        return commonEscape;
    }
    const codepoint = character.codePointAt(0);
    const codepointHex = codepoint.toString(16);
    return codepoint <= ASTRAL_START ? `\\u${codepointHex.padStart(4, '0')}` : `\\U${codepointHex}`;
};
// Characters that would create issues when printed are escaped using the \u or \U notation.
// Those include control characters and newlines.
// The \u and \U notation is Bash specific, but there is no way to do this in a shell-agnostic way.
// Some shells do not even have a way to print those characters in an escaped fashion.
// Therefore, we prioritize printing those safely, instead of allowing those to be copy-pasted.
// List of Unicode character categories: https://www.fileformat.info/info/unicode/category/index.htm
const getSpecialCharRegExp = ()=>{
    try {
        // This throws when using Node.js without ICU support.
        // When using a RegExp literal, this would throw at parsing-time, instead of runtime.
        // eslint-disable-next-line prefer-regex-literals
        return new RegExp('\\p{Separator}|\\p{Other}', 'gu');
    } catch  {
        // Similar to the above RegExp, but works even when Node.js has been built without ICU support.
        // Unlike the above RegExp, it only covers whitespaces and C0/C1 control characters.
        // It does not cover some edge cases, such as Unicode reserved characters.
        // See https://github.com/sindresorhus/execa/issues/1143
        // eslint-disable-next-line no-control-regex
        return /[\s\u0000-\u001F\u007F-\u009F\u00AD]/g;
    }
};
const SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();
// Accepted by $'...' in Bash.
// Exclude \a \e \v which are accepted in Bash but not in JavaScript (except \v) and JSON.
const COMMON_ESCAPES = {
    ' ': ' ',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t'
};
// Up until that codepoint, \u notation can be used instead of \U
const ASTRAL_START = 65_535;
// Some characters are shell-specific, i.e. need to be escaped when the command is copy-pasted then run.
// Escaping is shell-specific. We cannot know which shell is used: `process.platform` detection is not enough.
// For example, Windows users could be using `cmd.exe`, Powershell or Bash for Windows which all use different escaping.
// We use '...' on Unix, which is POSIX shell compliant and escape all characters but ' so this is fairly safe.
// On Windows, we assume cmd.exe is used and escape with "...", which also works with Powershell.
const quoteString = (escapedArgument)=>{
    if (NO_ESCAPE_REGEXP.test(escapedArgument)) {
        return escapedArgument;
    }
    return ("TURBOPACK compile-time truthy", 1) ? `"${escapedArgument.replaceAll('"', '""')}"` : "TURBOPACK unreachable";
};
const NO_ESCAPE_REGEXP = /^[\w./-]+$/;
}),
"[project]/node_modules/execa/lib/verbose/default.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "defaultVerboseFunction",
    ()=>defaultVerboseFunction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$figures$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/figures/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/yoctocolors/base.js [app-ssr] (ecmascript)");
;
;
const defaultVerboseFunction = ({ type, message, timestamp, piped, commandId, result: { failed = false } = {}, options: { reject = true } })=>{
    const timestampString = serializeTimestamp(timestamp);
    const icon = ICONS[type]({
        failed,
        reject,
        piped
    });
    const color = COLORS[type]({
        reject
    });
    return `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gray"])(`[${timestampString}]`)} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gray"])(`[${commandId}]`)} ${color(icon)} ${color(message)}`;
};
// Prepending the timestamp allows debugging the slow paths of a subprocess
const serializeTimestamp = (timestamp)=>`${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;
const padField = (field, padding)=>String(field).padStart(padding, '0');
const getFinalIcon = ({ failed, reject })=>{
    if (!failed) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$figures$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].tick;
    }
    return reject ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$figures$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].cross : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$figures$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].warning;
};
const ICONS = {
    command: ({ piped })=>piped ? '|' : '$',
    output: ()=>' ',
    ipc: ()=>'*',
    error: getFinalIcon,
    duration: getFinalIcon
};
const identity = (string)=>string;
const COLORS = {
    command: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bold"],
    output: ()=>identity,
    ipc: ()=>identity,
    error: ({ reject })=>reject ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["redBright"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["yellowBright"],
    duration: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gray"]
};
}),
"[project]/node_modules/execa/lib/verbose/custom.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "applyVerboseOnLines",
    ()=>applyVerboseOnLines
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-ssr] (ecmascript)");
;
const applyVerboseOnLines = (printedLines, verboseInfo, fdNumber)=>{
    const verboseFunction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getVerboseFunction"])(verboseInfo, fdNumber);
    return printedLines.map(({ verboseLine, verboseObject })=>applyVerboseFunction(verboseLine, verboseObject, verboseFunction)).filter((printedLine)=>printedLine !== undefined).map((printedLine)=>appendNewline(printedLine)).join('');
};
const applyVerboseFunction = (verboseLine, verboseObject, verboseFunction)=>{
    if (verboseFunction === undefined) {
        return verboseLine;
    }
    const printedLine = verboseFunction(verboseLine, verboseObject);
    if (typeof printedLine === 'string') {
        return printedLine;
    }
};
const appendNewline = (printedLine)=>printedLine.endsWith('\n') ? printedLine : `${printedLine}\n`;
}),
"[project]/node_modules/execa/lib/verbose/log.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "serializeVerboseMessage",
    ()=>serializeVerboseMessage,
    "verboseLog",
    ()=>verboseLog
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/escape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$default$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/default.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$custom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/custom.js [app-ssr] (ecmascript)");
;
;
;
;
const verboseLog = ({ type, verboseMessage, fdNumber, verboseInfo, result })=>{
    const verboseObject = getVerboseObject({
        type,
        result,
        verboseInfo
    });
    const printedLines = getPrintedLines(verboseMessage, verboseObject);
    const finalLines = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$custom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["applyVerboseOnLines"])(printedLines, verboseInfo, fdNumber);
    if (finalLines !== '') {
        console.warn(finalLines.slice(0, -1));
    }
};
const getVerboseObject = ({ type, result, verboseInfo: { escapedCommand, commandId, rawOptions: { piped = false, ...options } } })=>({
        type,
        escapedCommand,
        commandId: `${commandId}`,
        timestamp: new Date(),
        piped,
        result,
        options
    });
const getPrintedLines = (verboseMessage, verboseObject)=>verboseMessage.split('\n').map((message)=>getPrintedLine({
            ...verboseObject,
            message
        }));
const getPrintedLine = (verboseObject)=>{
    const verboseLine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$default$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defaultVerboseFunction"])(verboseObject);
    return {
        verboseLine,
        verboseObject
    };
};
const serializeVerboseMessage = (message)=>{
    const messageString = typeof message === 'string' ? message : (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["inspect"])(message);
    const escapedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["escapeLines"])(messageString);
    return escapedMessage.replaceAll('\t', ' '.repeat(TAB_SIZE));
};
// Same as `util.inspect()`
const TAB_SIZE = 2;
}),
"[project]/node_modules/execa/lib/verbose/start.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logCommand",
    ()=>logCommand
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/log.js [app-ssr] (ecmascript)");
;
;
const logCommand = (escapedCommand, verboseInfo)=>{
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isVerbose"])(verboseInfo)) {
        return;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["verboseLog"])({
        type: 'command',
        verboseMessage: escapedCommand,
        verboseInfo
    });
};
}),
"[project]/node_modules/execa/lib/verbose/info.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getVerboseInfo",
    ()=>getVerboseInfo
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-ssr] (ecmascript)");
;
const getVerboseInfo = (verbose, escapedCommand, rawOptions)=>{
    validateVerbose(verbose);
    const commandId = getCommandId(verbose);
    return {
        verbose,
        escapedCommand,
        commandId,
        rawOptions
    };
};
const getCommandId = (verbose)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isVerbose"])({
        verbose
    }) ? COMMAND_ID++ : undefined;
// Prepending the `pid` is useful when multiple commands print their output at the same time.
// However, we cannot use the real PID since this is not available with `child_process.spawnSync()`.
// Also, we cannot use the real PID if we want to print it before `child_process.spawn()` is run.
// As a pro, it is shorter than a normal PID and never re-uses the same id.
// As a con, it cannot be used to send signals.
let COMMAND_ID = 0n;
const validateVerbose = (verbose)=>{
    for (const fdVerbose of verbose){
        if (fdVerbose === false) {
            throw new TypeError('The "verbose: false" option was renamed to "verbose: \'none\'".');
        }
        if (fdVerbose === true) {
            throw new TypeError('The "verbose: true" option was renamed to "verbose: \'short\'".');
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VERBOSE_VALUES"].includes(fdVerbose) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isVerboseFunction"])(fdVerbose)) {
            const allowedValues = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VERBOSE_VALUES"].map((allowedValue)=>`'${allowedValue}'`).join(', ');
            throw new TypeError(`The "verbose" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);
        }
    }
};
}),
"[project]/node_modules/execa/lib/return/duration.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getDurationMs",
    ()=>getDurationMs,
    "getStartTime",
    ()=>getStartTime
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
;
const getStartTime = ()=>__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["hrtime"].bigint();
const getDurationMs = (startTime)=>Number(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["hrtime"].bigint() - startTime) / 1e6;
}),
"[project]/node_modules/execa/lib/arguments/command.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleCommand",
    ()=>handleCommand
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$start$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/start.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$info$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/info.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/duration.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/escape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-ssr] (ecmascript)");
;
;
;
;
;
const handleCommand = (filePath, rawArguments, rawOptions)=>{
    const startTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStartTime"])();
    const { command, escapedCommand } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["joinCommand"])(filePath, rawArguments);
    const verbose = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeFdSpecificOption"])(rawOptions, 'verbose');
    const verboseInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$info$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getVerboseInfo"])(verbose, escapedCommand, {
        ...rawOptions
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$start$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logCommand"])(escapedCommand, verboseInfo);
    return {
        command,
        escapedCommand,
        startTime,
        verboseInfo
    };
};
}),
"[project]/node_modules/execa/lib/return/final-error.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// When the subprocess fails, this is the error instance being returned.
// If another error instance is being thrown, it is kept as `error.cause`.
__turbopack_context__.s([
    "DiscardedError",
    ()=>DiscardedError,
    "ExecaError",
    ()=>ExecaError,
    "ExecaSyncError",
    ()=>ExecaSyncError,
    "getFinalError",
    ()=>getFinalError,
    "isErrorInstance",
    ()=>isErrorInstance,
    "isExecaError",
    ()=>isExecaError
]);
const getFinalError = (originalError, message, isSync)=>{
    const ErrorClass = isSync ? ExecaSyncError : ExecaError;
    const options = originalError instanceof DiscardedError ? {} : {
        cause: originalError
    };
    return new ErrorClass(message, options);
};
class DiscardedError extends Error {
}
// Proper way to set `error.name`: it should be inherited and non-enumerable
const setErrorName = (ErrorClass, value)=>{
    Object.defineProperty(ErrorClass.prototype, 'name', {
        value,
        writable: true,
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ErrorClass.prototype, execaErrorSymbol, {
        value: true,
        writable: false,
        enumerable: false,
        configurable: false
    });
};
const isExecaError = (error)=>isErrorInstance(error) && execaErrorSymbol in error;
const execaErrorSymbol = Symbol('isExecaError');
const isErrorInstance = (value)=>Object.prototype.toString.call(value) === '[object Error]';
class ExecaError extends Error {
}
setErrorName(ExecaError, ExecaError.name);
class ExecaSyncError extends Error {
}
setErrorName(ExecaSyncError, ExecaSyncError.name);
}),
"[project]/node_modules/execa/lib/terminate/signal.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getSignalDescription",
    ()=>getSignalDescription,
    "normalizeKillSignal",
    ()=>normalizeKillSignal,
    "normalizeSignalArgument",
    ()=>normalizeSignalArgument
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:os [external] (node:os, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$human$2d$signals$2f$build$2f$src$2f$main$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/human-signals/build/src/main.js [app-ssr] (ecmascript)");
;
;
const normalizeKillSignal = (killSignal)=>{
    const optionName = 'option `killSignal`';
    if (killSignal === 0) {
        throw new TypeError(`Invalid ${optionName}: 0 cannot be used.`);
    }
    return normalizeSignal(killSignal, optionName);
};
const normalizeSignalArgument = (signal)=>signal === 0 ? signal : normalizeSignal(signal, '`subprocess.kill()`\'s argument');
const normalizeSignal = (signalNameOrInteger, optionName)=>{
    if (Number.isInteger(signalNameOrInteger)) {
        return normalizeSignalInteger(signalNameOrInteger, optionName);
    }
    if (typeof signalNameOrInteger === 'string') {
        return normalizeSignalName(signalNameOrInteger, optionName);
    }
    throw new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.\n${getAvailableSignals()}`);
};
const normalizeSignalInteger = (signalInteger, optionName)=>{
    if (signalsIntegerToName.has(signalInteger)) {
        return signalsIntegerToName.get(signalInteger);
    }
    throw new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.\n${getAvailableSignals()}`);
};
const getSignalsIntegerToName = ()=>new Map(Object.entries(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["constants"].signals).reverse().map(([signalName, signalInteger])=>[
            signalInteger,
            signalName
        ]));
const signalsIntegerToName = getSignalsIntegerToName();
const normalizeSignalName = (signalName, optionName)=>{
    if (signalName in __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["constants"].signals) {
        return signalName;
    }
    if (signalName.toUpperCase() in __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["constants"].signals) {
        throw new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);
    }
    throw new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.\n${getAvailableSignals()}`);
};
const getAvailableSignals = ()=>`Available signal names: ${getAvailableSignalNames()}.
Available signal numbers: ${getAvailableSignalIntegers()}.`;
const getAvailableSignalNames = ()=>Object.keys(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["constants"].signals).sort().map((signalName)=>`'${signalName}'`).join(', ');
const getAvailableSignalIntegers = ()=>[
        ...new Set(Object.values(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$os__$5b$external$5d$__$28$node$3a$os$2c$__cjs$29$__["constants"].signals).sort((signalInteger, signalIntegerTwo)=>signalInteger - signalIntegerTwo))
    ].join(', ');
const getSignalDescription = (signal)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$human$2d$signals$2f$build$2f$src$2f$main$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["signalsByName"][signal].description;
}),
"[project]/node_modules/execa/lib/terminate/kill.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "killOnTimeout",
    ()=>killOnTimeout,
    "normalizeForceKillAfterDelay",
    ()=>normalizeForceKillAfterDelay,
    "subprocessKill",
    ()=>subprocessKill
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:timers/promises [external] (node:timers/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/final-error.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/signal.js [app-ssr] (ecmascript)");
;
;
;
const normalizeForceKillAfterDelay = (forceKillAfterDelay)=>{
    if (forceKillAfterDelay === false) {
        return forceKillAfterDelay;
    }
    if (forceKillAfterDelay === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT;
    }
    if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {
        throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
    }
    return forceKillAfterDelay;
};
const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
const subprocessKill = ({ kill, options: { forceKillAfterDelay, killSignal }, onInternalError, context, controller }, signalOrError, errorArgument)=>{
    const { signal, error } = parseKillArguments(signalOrError, errorArgument, killSignal);
    emitKillError(error, onInternalError);
    const killResult = kill(signal);
    setKillTimeout({
        kill,
        signal,
        forceKillAfterDelay,
        killSignal,
        killResult,
        context,
        controller
    });
    return killResult;
};
const parseKillArguments = (signalOrError, errorArgument, killSignal)=>{
    const [signal = killSignal, error] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isErrorInstance"])(signalOrError) ? [
        undefined,
        signalOrError
    ] : [
        signalOrError,
        errorArgument
    ];
    if (typeof signal !== 'string' && !Number.isInteger(signal)) {
        throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);
    }
    if (error !== undefined && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isErrorInstance"])(error)) {
        throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);
    }
    return {
        signal: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeSignalArgument"])(signal),
        error
    };
};
// Fails right away when calling `subprocess.kill(error)`.
// Does not wait for actual signal termination.
// Uses a deferred promise instead of the `error` event on the subprocess, as this is less intrusive.
const emitKillError = (error, onInternalError)=>{
    if (error !== undefined) {
        onInternalError.reject(error);
    }
};
const setKillTimeout = async ({ kill, signal, forceKillAfterDelay, killSignal, killResult, context, controller })=>{
    if (signal === killSignal && killResult) {
        killOnTimeout({
            kill,
            forceKillAfterDelay,
            context,
            controllerSignal: controller.signal
        });
    }
};
const killOnTimeout = async ({ kill, forceKillAfterDelay, context, controllerSignal })=>{
    if (forceKillAfterDelay === false) {
        return;
    }
    try {
        await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__["setTimeout"])(forceKillAfterDelay, undefined, {
            signal: controllerSignal
        });
        if (kill('SIGKILL')) {
            context.isForcefullyTerminated ??= true;
        }
    } catch  {}
};
}),
"[project]/node_modules/execa/lib/utils/abort-signal.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "onAbortedSignal",
    ()=>onAbortedSignal
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
;
const onAbortedSignal = async (mainSignal, stopSignal)=>{
    if (!mainSignal.aborted) {
        await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(mainSignal, 'abort', {
            signal: stopSignal
        });
    }
};
}),
"[project]/node_modules/execa/lib/terminate/cancel.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "throwOnCancel",
    ()=>throwOnCancel,
    "validateCancelSignal",
    ()=>validateCancelSignal
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$abort$2d$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/abort-signal.js [app-ssr] (ecmascript)");
;
const validateCancelSignal = ({ cancelSignal })=>{
    if (cancelSignal !== undefined && Object.prototype.toString.call(cancelSignal) !== '[object AbortSignal]') {
        throw new Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(cancelSignal)}`);
    }
};
const throwOnCancel = ({ subprocess, cancelSignal, gracefulCancel, context, controller })=>cancelSignal === undefined || gracefulCancel ? [] : [
        terminateOnCancel(subprocess, cancelSignal, context, controller)
    ];
const terminateOnCancel = async (subprocess, cancelSignal, context, { signal })=>{
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$abort$2d$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["onAbortedSignal"])(cancelSignal, signal);
    context.terminationReason ??= 'cancel';
    subprocess.kill();
    throw cancelSignal.reason;
};
}),
"[project]/node_modules/execa/lib/ipc/validation.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Validate the IPC channel is connected before receiving/sending messages
__turbopack_context__.s([
    "disconnect",
    ()=>disconnect,
    "getAbortDisconnectError",
    ()=>getAbortDisconnectError,
    "getStrictResponseError",
    ()=>getStrictResponseError,
    "handleEpipeError",
    ()=>handleEpipeError,
    "handleSerializationError",
    ()=>handleSerializationError,
    "throwOnEarlyDisconnect",
    ()=>throwOnEarlyDisconnect,
    "throwOnMissingParent",
    ()=>throwOnMissingParent,
    "throwOnMissingStrict",
    ()=>throwOnMissingStrict,
    "throwOnStrictDeadlockError",
    ()=>throwOnStrictDeadlockError,
    "throwOnStrictDisconnect",
    ()=>throwOnStrictDisconnect,
    "validateConnection",
    ()=>validateConnection,
    "validateIpcMethod",
    ()=>validateIpcMethod
]);
const validateIpcMethod = ({ methodName, isSubprocess, ipc, isConnected })=>{
    validateIpcOption(methodName, isSubprocess, ipc);
    validateConnection(methodName, isSubprocess, isConnected);
};
// Better error message when forgetting to set `ipc: true` and using the IPC methods
const validateIpcOption = (methodName, isSubprocess, ipc)=>{
    if (!ipc) {
        throw new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \`ipc\` option is \`true\`.`);
    }
};
const validateConnection = (methodName, isSubprocess, isConnected)=>{
    if (!isConnected) {
        throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);
    }
};
const throwOnEarlyDisconnect = (isSubprocess)=>{
    throw new Error(`${getMethodName('getOneMessage', isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);
};
const throwOnStrictDeadlockError = (isSubprocess)=>{
    throw new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
	${getMethodName('getOneMessage', isSubprocess)},
	${getMethodName('sendMessage', isSubprocess, 'message, {strict: true}')},
]);`);
};
const getStrictResponseError = (error, isSubprocess)=>new Error(`${getMethodName('sendMessage', isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, {
        cause: error
    });
const throwOnMissingStrict = (isSubprocess)=>{
    throw new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);
};
const throwOnStrictDisconnect = (isSubprocess)=>{
    throw new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);
};
const getAbortDisconnectError = ()=>new Error(`\`cancelSignal\` aborted: the ${getOtherProcessName(true)} disconnected.`);
const throwOnMissingParent = ()=>{
    throw new Error('`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.');
};
const handleEpipeError = ({ error, methodName, isSubprocess })=>{
    if (error.code === 'EPIPE') {
        throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, {
            cause: error
        });
    }
};
const handleSerializationError = ({ error, methodName, isSubprocess, message })=>{
    if (isSerializationError(error)) {
        throw new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, {
            cause: error
        });
    }
};
const isSerializationError = ({ code, message })=>SERIALIZATION_ERROR_CODES.has(code) || SERIALIZATION_ERROR_MESSAGES.some((serializationErrorMessage)=>message.includes(serializationErrorMessage));
// `error.code` set by Node.js when it failed to serialize the message
const SERIALIZATION_ERROR_CODES = new Set([
    // Message is `undefined`
    'ERR_MISSING_ARGS',
    // Message is a function, a bigint, a symbol
    'ERR_INVALID_ARG_TYPE'
]);
// `error.message` set by Node.js when it failed to serialize the message
const SERIALIZATION_ERROR_MESSAGES = [
    // Message is a promise or a proxy, with `serialization: 'advanced'`
    'could not be cloned',
    // Message has cycles, with `serialization: 'json'`
    'circular structure',
    // Message has cycles inside toJSON(), with `serialization: 'json'`
    'call stack size exceeded'
];
const getMethodName = (methodName, isSubprocess, parameters = '')=>methodName === 'cancelSignal' ? '`cancelSignal`\'s `controller.abort()`' : `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;
const getNamespaceName = (isSubprocess)=>isSubprocess ? '' : 'subprocess.';
const getOtherProcessName = (isSubprocess)=>isSubprocess ? 'parent process' : 'subprocess';
const disconnect = (anyProcess)=>{
    if (anyProcess.connected) {
        anyProcess.disconnect();
    }
};
}),
"[project]/node_modules/execa/lib/utils/deferred.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createDeferred",
    ()=>createDeferred
]);
const createDeferred = ()=>{
    const methods = {};
    const promise = new Promise((resolve, reject)=>{
        Object.assign(methods, {
            resolve,
            reject
        });
    });
    return Object.assign(promise, methods);
};
}),
"[project]/node_modules/execa/lib/arguments/fd-options.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SUBPROCESS_OPTIONS",
    ()=>SUBPROCESS_OPTIONS,
    "getFromStream",
    ()=>getFromStream,
    "getToStream",
    ()=>getToStream,
    "serializeOptionValue",
    ()=>serializeOptionValue
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-ssr] (ecmascript)");
;
const getToStream = (destination, to = 'stdin')=>{
    const isWritable = true;
    const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(destination);
    const fdNumber = getFdNumber(fileDescriptors, to, isWritable);
    const destinationStream = destination.stdio[fdNumber];
    if (destinationStream === null) {
        throw new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));
    }
    return destinationStream;
};
const getFromStream = (source, from = 'stdout')=>{
    const isWritable = false;
    const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
    const fdNumber = getFdNumber(fileDescriptors, from, isWritable);
    const sourceStream = fdNumber === 'all' ? source.all : source.stdio[fdNumber];
    if (sourceStream === null || sourceStream === undefined) {
        throw new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));
    }
    return sourceStream;
};
const SUBPROCESS_OPTIONS = new WeakMap();
const getFdNumber = (fileDescriptors, fdName, isWritable)=>{
    const fdNumber = parseFdNumber(fdName, isWritable);
    validateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);
    return fdNumber;
};
const parseFdNumber = (fdName, isWritable)=>{
    const fdNumber = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseFd"])(fdName);
    if (fdNumber !== undefined) {
        return fdNumber;
    }
    const { validOptions, defaultValue } = isWritable ? {
        validOptions: '"stdin"',
        defaultValue: 'stdin'
    } : {
        validOptions: '"stdout", "stderr", "all"',
        defaultValue: 'stdout'
    };
    throw new TypeError(`"${getOptionName(isWritable)}" must not be "${fdName}".
It must be ${validOptions} or "fd3", "fd4" (and so on).
It is optional and defaults to "${defaultValue}".`);
};
const validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors)=>{
    const fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];
    if (fileDescriptor === undefined) {
        throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
    }
    if (fileDescriptor.direction === 'input' && !isWritable) {
        throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a readable stream, not writable.`);
    }
    if (fileDescriptor.direction !== 'input' && isWritable) {
        throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a writable stream, not readable.`);
    }
};
const getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable)=>{
    if (fdNumber === 'all' && !options.all) {
        return 'The "all" option must be true to use "from: \'all\'".';
    }
    const { optionName, optionValue } = getInvalidStdioOption(fdNumber, options);
    return `The "${optionName}: ${serializeOptionValue(optionValue)}" option is incompatible with using "${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}".
Please set this option with "pipe" instead.`;
};
const getInvalidStdioOption = (fdNumber, { stdin, stdout, stderr, stdio })=>{
    const usedDescriptor = getUsedDescriptor(fdNumber);
    if (usedDescriptor === 0 && stdin !== undefined) {
        return {
            optionName: 'stdin',
            optionValue: stdin
        };
    }
    if (usedDescriptor === 1 && stdout !== undefined) {
        return {
            optionName: 'stdout',
            optionValue: stdout
        };
    }
    if (usedDescriptor === 2 && stderr !== undefined) {
        return {
            optionName: 'stderr',
            optionValue: stderr
        };
    }
    return {
        optionName: `stdio[${usedDescriptor}]`,
        optionValue: stdio[usedDescriptor]
    };
};
const getUsedDescriptor = (fdNumber)=>fdNumber === 'all' ? 1 : fdNumber;
const getOptionName = (isWritable)=>isWritable ? 'to' : 'from';
const serializeOptionValue = (value)=>{
    if (typeof value === 'string') {
        return `'${value}'`;
    }
    return typeof value === 'number' ? `${value}` : 'Stream';
};
}),
"[project]/node_modules/execa/lib/utils/max-listeners.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "incrementMaxListeners",
    ()=>incrementMaxListeners
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
;
const incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal)=>{
    const maxListeners = eventEmitter.getMaxListeners();
    if (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {
        return;
    }
    eventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);
    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["addAbortListener"])(signal, ()=>{
        eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);
    });
};
}),
"[project]/node_modules/execa/lib/ipc/reference.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// By default, Node.js keeps the subprocess alive while it has a `message` or `disconnect` listener.
// We replicate the same logic for the events that we proxy.
// This ensures the subprocess is kept alive while `getOneMessage()` and `getEachMessage()` are ongoing.
// This is not a problem with `sendMessage()` since Node.js handles that method automatically.
// We do not use `anyProcess.channel.ref()` since this would prevent the automatic `.channel.refCounted()` Node.js is doing.
// We keep a reference to `anyProcess.channel` since it might be `null` while `getOneMessage()` or `getEachMessage()` is still processing debounced messages.
// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L547
__turbopack_context__.s([
    "addReference",
    ()=>addReference,
    "redoAddedReferences",
    ()=>redoAddedReferences,
    "removeReference",
    ()=>removeReference,
    "undoAddedReferences",
    ()=>undoAddedReferences
]);
const addReference = (channel, reference)=>{
    if (reference) {
        addReferenceCount(channel);
    }
};
const addReferenceCount = (channel)=>{
    channel.refCounted();
};
const removeReference = (channel, reference)=>{
    if (reference) {
        removeReferenceCount(channel);
    }
};
const removeReferenceCount = (channel)=>{
    channel.unrefCounted();
};
const undoAddedReferences = (channel, isSubprocess)=>{
    if (isSubprocess) {
        removeReferenceCount(channel);
        removeReferenceCount(channel);
    }
};
const redoAddedReferences = (channel, isSubprocess)=>{
    if (isSubprocess) {
        addReferenceCount(channel);
        addReferenceCount(channel);
    }
};
}),
"[project]/node_modules/execa/lib/ipc/incoming.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "onDisconnect",
    ()=>onDisconnect,
    "onMessage",
    ()=>onMessage
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:timers/promises [external] (node:timers/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/outgoing.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/reference.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/strict.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/graceful.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
const onMessage = async ({ anyProcess, channel, isSubprocess, ipcEmitter }, wrappedMessage)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleStrictResponse"])(wrappedMessage) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleAbort"])(wrappedMessage)) {
        return;
    }
    if (!INCOMING_MESSAGES.has(anyProcess)) {
        INCOMING_MESSAGES.set(anyProcess, []);
    }
    const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
    incomingMessages.push(wrappedMessage);
    if (incomingMessages.length > 1) {
        return;
    }
    while(incomingMessages.length > 0){
        // eslint-disable-next-line no-await-in-loop
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForOutgoingMessages"])(anyProcess, ipcEmitter, wrappedMessage);
        // eslint-disable-next-line no-await-in-loop
        await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__["scheduler"].yield();
        // eslint-disable-next-line no-await-in-loop
        const message = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleStrictRequest"])({
            wrappedMessage: incomingMessages[0],
            anyProcess,
            channel,
            isSubprocess,
            ipcEmitter
        });
        incomingMessages.shift();
        ipcEmitter.emit('message', message);
        ipcEmitter.emit('message:done');
    }
};
const onDisconnect = async ({ anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage })=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abortOnDisconnect"])();
    const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
    while(incomingMessages?.length > 0){
        // eslint-disable-next-line no-await-in-loop
        await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(ipcEmitter, 'message:done');
    }
    anyProcess.removeListener('message', boundOnMessage);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["redoAddedReferences"])(channel, isSubprocess);
    ipcEmitter.connected = false;
    ipcEmitter.emit('disconnect');
};
const INCOMING_MESSAGES = new WeakMap();
}),
"[project]/node_modules/execa/lib/ipc/forward.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getIpcEmitter",
    ()=>getIpcEmitter,
    "isConnected",
    ()=>isConnected
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$incoming$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/incoming.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/reference.js [app-ssr] (ecmascript)");
;
;
;
const getIpcEmitter = (anyProcess, channel, isSubprocess)=>{
    if (IPC_EMITTERS.has(anyProcess)) {
        return IPC_EMITTERS.get(anyProcess);
    }
    // Use an `EventEmitter`, like the `process` that is being proxied
    // eslint-disable-next-line unicorn/prefer-event-target
    const ipcEmitter = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["EventEmitter"]();
    ipcEmitter.connected = true;
    IPC_EMITTERS.set(anyProcess, ipcEmitter);
    forwardEvents({
        ipcEmitter,
        anyProcess,
        channel,
        isSubprocess
    });
    return ipcEmitter;
};
const IPC_EMITTERS = new WeakMap();
// The `message` and `disconnect` events are buffered in the subprocess until the first listener is setup.
// However, unbuffering happens after one tick, so this give enough time for the caller to setup the listener on the proxy emitter first.
// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L721
const forwardEvents = ({ ipcEmitter, anyProcess, channel, isSubprocess })=>{
    const boundOnMessage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$incoming$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["onMessage"].bind(undefined, {
        anyProcess,
        channel,
        isSubprocess,
        ipcEmitter
    });
    anyProcess.on('message', boundOnMessage);
    anyProcess.once('disconnect', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$incoming$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["onDisconnect"].bind(undefined, {
        anyProcess,
        channel,
        isSubprocess,
        ipcEmitter,
        boundOnMessage
    }));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["undoAddedReferences"])(channel, isSubprocess);
};
const isConnected = (anyProcess)=>{
    const ipcEmitter = IPC_EMITTERS.get(anyProcess);
    return ipcEmitter === undefined ? anyProcess.channel !== null : ipcEmitter.connected;
};
}),
"[project]/node_modules/execa/lib/ipc/strict.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleSendStrict",
    ()=>handleSendStrict,
    "handleStrictRequest",
    ()=>handleStrictRequest,
    "handleStrictResponse",
    ()=>handleStrictResponse,
    "validateStrictDeadlock",
    ()=>validateStrictDeadlock,
    "waitForStrictResponse",
    ()=>waitForStrictResponse
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/deferred.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/max-listeners.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$send$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/send.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/validation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/forward.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/outgoing.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const handleSendStrict = ({ anyProcess, channel, isSubprocess, message, strict })=>{
    if (!strict) {
        return message;
    }
    const ipcEmitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getIpcEmitter"])(anyProcess, channel, isSubprocess);
    const hasListeners = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasMessageListeners"])(anyProcess, ipcEmitter);
    return {
        id: count++,
        type: REQUEST_TYPE,
        message,
        hasListeners
    };
};
let count = 0n;
const validateStrictDeadlock = (outgoingMessages, wrappedMessage)=>{
    if (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) {
        return;
    }
    for (const { id } of outgoingMessages){
        if (id !== undefined) {
            STRICT_RESPONSES[id].resolve({
                isDeadlock: true,
                hasListeners: false
            });
        }
    }
};
const handleStrictRequest = async ({ wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter })=>{
    if (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) {
        return wrappedMessage;
    }
    const { id, message } = wrappedMessage;
    const response = {
        id,
        type: RESPONSE_TYPE,
        message: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasMessageListeners"])(anyProcess, ipcEmitter)
    };
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$send$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sendMessage"])({
            anyProcess,
            channel,
            isSubprocess,
            ipc: true
        }, response);
    } catch (error) {
        ipcEmitter.emit('strict:error', error);
    }
    return message;
};
const handleStrictResponse = (wrappedMessage)=>{
    if (wrappedMessage?.type !== RESPONSE_TYPE) {
        return false;
    }
    const { id, message: hasListeners } = wrappedMessage;
    STRICT_RESPONSES[id]?.resolve({
        isDeadlock: false,
        hasListeners
    });
    return true;
};
const waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess)=>{
    if (wrappedMessage?.type !== REQUEST_TYPE) {
        return;
    }
    const deferred = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDeferred"])();
    STRICT_RESPONSES[wrappedMessage.id] = deferred;
    const controller = new AbortController();
    try {
        const { isDeadlock, hasListeners } = await Promise.race([
            deferred,
            throwOnDisconnect(anyProcess, isSubprocess, controller)
        ]);
        if (isDeadlock) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["throwOnStrictDeadlockError"])(isSubprocess);
        }
        if (!hasListeners) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["throwOnMissingStrict"])(isSubprocess);
        }
    } finally{
        controller.abort();
        delete STRICT_RESPONSES[wrappedMessage.id];
    }
};
const STRICT_RESPONSES = {};
const throwOnDisconnect = async (anyProcess, isSubprocess, { signal })=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["incrementMaxListeners"])(anyProcess, 1, signal);
    await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(anyProcess, 'disconnect', {
        signal
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["throwOnStrictDisconnect"])(isSubprocess);
};
const REQUEST_TYPE = 'execa:ipc:request';
const RESPONSE_TYPE = 'execa:ipc:response';
}),
"[project]/node_modules/execa/lib/ipc/outgoing.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "endSendMessage",
    ()=>endSendMessage,
    "hasMessageListeners",
    ()=>hasMessageListeners,
    "startSendMessage",
    ()=>startSendMessage,
    "waitForOutgoingMessages",
    ()=>waitForOutgoingMessages
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/deferred.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/strict.js [app-ssr] (ecmascript)");
;
;
;
;
const startSendMessage = (anyProcess, wrappedMessage, strict)=>{
    if (!OUTGOING_MESSAGES.has(anyProcess)) {
        OUTGOING_MESSAGES.set(anyProcess, new Set());
    }
    const outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);
    const onMessageSent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDeferred"])();
    const id = strict ? wrappedMessage.id : undefined;
    const outgoingMessage = {
        onMessageSent,
        id
    };
    outgoingMessages.add(outgoingMessage);
    return {
        outgoingMessages,
        outgoingMessage
    };
};
const endSendMessage = ({ outgoingMessages, outgoingMessage })=>{
    outgoingMessages.delete(outgoingMessage);
    outgoingMessage.onMessageSent.resolve();
};
const waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage)=>{
    while(!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0){
        const outgoingMessages = [
            ...OUTGOING_MESSAGES.get(anyProcess)
        ];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateStrictDeadlock"])(outgoingMessages, wrappedMessage);
        // eslint-disable-next-line no-await-in-loop
        await Promise.all(outgoingMessages.map(({ onMessageSent })=>onMessageSent));
    }
};
const OUTGOING_MESSAGES = new WeakMap();
const hasMessageListeners = (anyProcess, ipcEmitter)=>ipcEmitter.listenerCount('message') > getMinListenerCount(anyProcess);
// When `buffer` is `false`, we set up a `message` listener that should be ignored.
// That listener is only meant to intercept `strict` acknowledgement responses.
const getMinListenerCount = (anyProcess)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SUBPROCESS_OPTIONS"].has(anyProcess) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFdSpecificValue"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SUBPROCESS_OPTIONS"].get(anyProcess).options.buffer, 'ipc') ? 1 : 0;
}),
"[project]/node_modules/execa/lib/ipc/send.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sendMessage",
    ()=>sendMessage,
    "sendOneMessage",
    ()=>sendOneMessage
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/validation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/outgoing.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/strict.js [app-ssr] (ecmascript)");
;
;
;
;
const sendMessage = ({ anyProcess, channel, isSubprocess, ipc }, message, { strict = false } = {})=>{
    const methodName = 'sendMessage';
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIpcMethod"])({
        methodName,
        isSubprocess,
        ipc,
        isConnected: anyProcess.connected
    });
    return sendMessageAsync({
        anyProcess,
        channel,
        methodName,
        isSubprocess,
        message,
        strict
    });
};
const sendMessageAsync = async ({ anyProcess, channel, methodName, isSubprocess, message, strict })=>{
    const wrappedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleSendStrict"])({
        anyProcess,
        channel,
        isSubprocess,
        message,
        strict
    });
    const outgoingMessagesState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["startSendMessage"])(anyProcess, wrappedMessage, strict);
    try {
        await sendOneMessage({
            anyProcess,
            methodName,
            isSubprocess,
            wrappedMessage,
            message
        });
    } catch (error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["disconnect"])(anyProcess);
        throw error;
    } finally{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["endSendMessage"])(outgoingMessagesState);
    }
};
const sendOneMessage = async ({ anyProcess, methodName, isSubprocess, wrappedMessage, message })=>{
    const sendMethod = getSendMethod(anyProcess);
    try {
        await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForStrictResponse"])(wrappedMessage, anyProcess, isSubprocess),
            sendMethod(wrappedMessage)
        ]);
    } catch (error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleEpipeError"])({
            error,
            methodName,
            isSubprocess
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleSerializationError"])({
            error,
            methodName,
            isSubprocess,
            message
        });
        throw error;
    }
};
// [sub]process.send() promisified, memoized
const getSendMethod = (anyProcess)=>{
    if (PROCESS_SEND_METHODS.has(anyProcess)) {
        return PROCESS_SEND_METHODS.get(anyProcess);
    }
    const sendMethod = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["promisify"])(anyProcess.send.bind(anyProcess));
    PROCESS_SEND_METHODS.set(anyProcess, sendMethod);
    return sendMethod;
};
const PROCESS_SEND_METHODS = new WeakMap();
}),
"[project]/node_modules/execa/lib/ipc/graceful.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "abortOnDisconnect",
    ()=>abortOnDisconnect,
    "getCancelSignal",
    ()=>getCancelSignal,
    "handleAbort",
    ()=>handleAbort,
    "sendAbort",
    ()=>sendAbort
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:timers/promises [external] (node:timers/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$send$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/send.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/forward.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/validation.js [app-ssr] (ecmascript)");
;
;
;
;
const sendAbort = (subprocess, message)=>{
    const methodName = 'cancelSignal';
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateConnection"])(methodName, false, subprocess.connected);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$send$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sendOneMessage"])({
        anyProcess: subprocess,
        methodName,
        isSubprocess: false,
        wrappedMessage: {
            type: GRACEFUL_CANCEL_TYPE,
            message
        },
        message
    });
};
const getCancelSignal = async ({ anyProcess, channel, isSubprocess, ipc })=>{
    await startIpc({
        anyProcess,
        channel,
        isSubprocess,
        ipc
    });
    return cancelController.signal;
};
const startIpc = async ({ anyProcess, channel, isSubprocess, ipc })=>{
    if (cancelListening) {
        return;
    }
    cancelListening = true;
    if (!ipc) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["throwOnMissingParent"])();
        return;
    }
    if (channel === null) {
        abortOnDisconnect();
        return;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getIpcEmitter"])(anyProcess, channel, isSubprocess);
    await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__["scheduler"].yield();
};
let cancelListening = false;
const handleAbort = (wrappedMessage)=>{
    if (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) {
        return false;
    }
    cancelController.abort(wrappedMessage.message);
    return true;
};
const GRACEFUL_CANCEL_TYPE = 'execa:ipc:cancel';
const abortOnDisconnect = ()=>{
    cancelController.abort((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAbortDisconnectError"])());
};
const cancelController = new AbortController();
}),
"[project]/node_modules/execa/lib/terminate/graceful.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "throwOnGracefulCancel",
    ()=>throwOnGracefulCancel,
    "validateGracefulCancel",
    ()=>validateGracefulCancel
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$abort$2d$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/abort-signal.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/graceful.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$kill$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/kill.js [app-ssr] (ecmascript)");
;
;
;
const validateGracefulCancel = ({ gracefulCancel, cancelSignal, ipc, serialization })=>{
    if (!gracefulCancel) {
        return;
    }
    if (cancelSignal === undefined) {
        throw new Error('The `cancelSignal` option must be defined when setting the `gracefulCancel` option.');
    }
    if (!ipc) {
        throw new Error('The `ipc` option cannot be false when setting the `gracefulCancel` option.');
    }
    if (serialization === 'json') {
        throw new Error('The `serialization` option cannot be \'json\' when setting the `gracefulCancel` option.');
    }
};
const throwOnGracefulCancel = ({ subprocess, cancelSignal, gracefulCancel, forceKillAfterDelay, context, controller })=>gracefulCancel ? [
        sendOnAbort({
            subprocess,
            cancelSignal,
            forceKillAfterDelay,
            context,
            controller
        })
    ] : [];
const sendOnAbort = async ({ subprocess, cancelSignal, forceKillAfterDelay, context, controller: { signal } })=>{
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$abort$2d$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["onAbortedSignal"])(cancelSignal, signal);
    const reason = getReason(cancelSignal);
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sendAbort"])(subprocess, reason);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$kill$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["killOnTimeout"])({
        kill: subprocess.kill,
        forceKillAfterDelay,
        context,
        controllerSignal: signal
    });
    context.terminationReason ??= 'gracefulCancel';
    throw cancelSignal.reason;
};
// The default `reason` is a DOMException, which is not serializable with V8
// See https://github.com/nodejs/node/issues/53225
const getReason = ({ reason })=>{
    if (!(reason instanceof DOMException)) {
        return reason;
    }
    const error = new Error(reason.message);
    Object.defineProperty(error, 'stack', {
        value: reason.stack,
        enumerable: false,
        configurable: true,
        writable: true
    });
    return error;
};
}),
"[project]/node_modules/execa/lib/terminate/timeout.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "throwOnTimeout",
    ()=>throwOnTimeout,
    "validateTimeout",
    ()=>validateTimeout
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:timers/promises [external] (node:timers/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/final-error.js [app-ssr] (ecmascript)");
;
;
const validateTimeout = ({ timeout })=>{
    if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
    }
};
const throwOnTimeout = (subprocess, timeout, context, controller)=>timeout === 0 || timeout === undefined ? [] : [
        killAfterTimeout(subprocess, timeout, context, controller)
    ];
const killAfterTimeout = async (subprocess, timeout, context, { signal })=>{
    await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__["setTimeout"])(timeout, undefined, {
        signal
    });
    context.terminationReason ??= 'timeout';
    subprocess.kill();
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DiscardedError"]();
};
}),
"[project]/node_modules/execa/lib/methods/node.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleNodeOption",
    ()=>handleNodeOption,
    "mapNode",
    ()=>mapNode
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/file-url.js [app-ssr] (ecmascript)");
;
;
;
const mapNode = ({ options })=>{
    if (options.node === false) {
        throw new TypeError('The "node" option cannot be false with `execaNode()`.');
    }
    return {
        options: {
            ...options,
            node: true
        }
    };
};
const handleNodeOption = (file, commandArguments, { node: shouldHandleNode = false, nodePath = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["execPath"], nodeOptions = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["execArgv"].filter((nodeOption)=>!nodeOption.startsWith('--inspect')), cwd, execPath: formerNodePath, ...options })=>{
    if (formerNodePath !== undefined) {
        throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');
    }
    const normalizedNodePath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeNormalizeFileUrl"])(nodePath, 'The "nodePath" option');
    const resolvedNodePath = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(cwd, normalizedNodePath);
    const newOptions = {
        ...options,
        nodePath: resolvedNodePath,
        node: shouldHandleNode,
        cwd
    };
    if (!shouldHandleNode) {
        return [
            file,
            commandArguments,
            newOptions
        ];
    }
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].basename(file, '.exe') === 'node') {
        throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');
    }
    return [
        resolvedNodePath,
        [
            ...nodeOptions,
            file,
            ...commandArguments
        ],
        {
            ipc: true,
            ...newOptions,
            shell: false
        }
    ];
};
}),
"[project]/node_modules/execa/lib/ipc/ipc-input.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sendIpcInput",
    ()=>sendIpcInput,
    "validateIpcInputOption",
    ()=>validateIpcInputOption
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$v8__$5b$external$5d$__$28$node$3a$v8$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:v8 [external] (node:v8, cjs)");
;
const validateIpcInputOption = ({ ipcInput, ipc, serialization })=>{
    if (ipcInput === undefined) {
        return;
    }
    if (!ipc) {
        throw new Error('The `ipcInput` option cannot be set unless the `ipc` option is `true`.');
    }
    validateIpcInput[serialization](ipcInput);
};
const validateAdvancedInput = (ipcInput)=>{
    try {
        (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$v8__$5b$external$5d$__$28$node$3a$v8$2c$__cjs$29$__["serialize"])(ipcInput);
    } catch (error) {
        throw new Error('The `ipcInput` option is not serializable with a structured clone.', {
            cause: error
        });
    }
};
const validateJsonInput = (ipcInput)=>{
    try {
        JSON.stringify(ipcInput);
    } catch (error) {
        throw new Error('The `ipcInput` option is not serializable with JSON.', {
            cause: error
        });
    }
};
const validateIpcInput = {
    advanced: validateAdvancedInput,
    json: validateJsonInput
};
const sendIpcInput = async (subprocess, ipcInput)=>{
    if (ipcInput === undefined) {
        return;
    }
    await subprocess.sendMessage(ipcInput);
};
}),
"[project]/node_modules/execa/lib/arguments/encoding-option.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Validate `encoding` option
__turbopack_context__.s([
    "BINARY_ENCODINGS",
    ()=>BINARY_ENCODINGS,
    "validateEncoding",
    ()=>validateEncoding
]);
const validateEncoding = ({ encoding })=>{
    if (ENCODINGS.has(encoding)) {
        return;
    }
    const correctEncoding = getCorrectEncoding(encoding);
    if (correctEncoding !== undefined) {
        throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to ${serializeEncoding(correctEncoding)}.`);
    }
    const correctEncodings = [
        ...ENCODINGS
    ].map((correctEncoding)=>serializeEncoding(correctEncoding)).join(', ');
    throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to one of: ${correctEncodings}.`);
};
const TEXT_ENCODINGS = new Set([
    'utf8',
    'utf16le'
]);
const BINARY_ENCODINGS = new Set([
    'buffer',
    'hex',
    'base64',
    'base64url',
    'latin1',
    'ascii'
]);
const ENCODINGS = new Set([
    ...TEXT_ENCODINGS,
    ...BINARY_ENCODINGS
]);
const getCorrectEncoding = (encoding)=>{
    if (encoding === null) {
        return 'buffer';
    }
    if (typeof encoding !== 'string') {
        return;
    }
    const lowerEncoding = encoding.toLowerCase();
    if (lowerEncoding in ENCODING_ALIASES) {
        return ENCODING_ALIASES[lowerEncoding];
    }
    if (ENCODINGS.has(lowerEncoding)) {
        return lowerEncoding;
    }
};
const ENCODING_ALIASES = {
    // eslint-disable-next-line unicorn/text-encoding-identifier-case
    'utf-8': 'utf8',
    'utf-16le': 'utf16le',
    'ucs-2': 'utf16le',
    ucs2: 'utf16le',
    binary: 'latin1'
};
const serializeEncoding = (encoding)=>typeof encoding === 'string' ? `"${encoding}"` : String(encoding);
}),
"[project]/node_modules/execa/lib/arguments/cwd.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fixCwdError",
    ()=>fixCwdError,
    "normalizeCwd",
    ()=>normalizeCwd
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/file-url.js [app-ssr] (ecmascript)");
;
;
;
;
const normalizeCwd = (cwd = getDefaultCwd())=>{
    const cwdString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeNormalizeFileUrl"])(cwd, 'The "cwd" option');
    return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].resolve(cwdString);
};
const getDefaultCwd = ()=>{
    try {
        return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].cwd();
    } catch (error) {
        error.message = `The current directory does not exist.\n${error.message}`;
        throw error;
    }
};
const fixCwdError = (originalMessage, cwd)=>{
    if (cwd === getDefaultCwd()) {
        return originalMessage;
    }
    let cwdStat;
    try {
        cwdStat = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["statSync"])(cwd);
    } catch (error) {
        return `The "cwd" option is invalid: ${cwd}.\n${error.message}\n${originalMessage}`;
    }
    if (!cwdStat.isDirectory()) {
        return `The "cwd" option is not a directory: ${cwd}.\n${originalMessage}`;
    }
    return originalMessage;
};
}),
"[project]/node_modules/execa/lib/arguments/options.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizeOptions",
    ()=>normalizeOptions
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cross$2d$spawn$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cross-spawn/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$npm$2d$run$2d$path$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/npm-run-path/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$kill$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/kill.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/signal.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$cancel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/cancel.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/graceful.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$timeout$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/timeout.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$ipc$2d$input$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/ipc-input.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$cwd$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/cwd.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/file-url.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const normalizeOptions = (filePath, rawArguments, rawOptions)=>{
    rawOptions.cwd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$cwd$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeCwd"])(rawOptions.cwd);
    const [processedFile, processedArguments, processedOptions] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleNodeOption"])(filePath, rawArguments, rawOptions);
    const { command: file, args: commandArguments, options: initialOptions } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cross$2d$spawn$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]._parse(processedFile, processedArguments, processedOptions);
    const fdOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeFdSpecificOptions"])(initialOptions);
    const options = addDefaultOptions(fdOptions);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$timeout$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateTimeout"])(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateEncoding"])(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$ipc$2d$input$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIpcInputOption"])(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$cancel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateCancelSignal"])(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateGracefulCancel"])(options);
    options.shell = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeFileUrl"])(options.shell);
    options.env = getEnv(options);
    options.killSignal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeKillSignal"])(options.killSignal);
    options.forceKillAfterDelay = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$kill$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeForceKillAfterDelay"])(options.forceKillAfterDelay);
    options.lines = options.lines.map((lines, fdNumber)=>lines && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(options.encoding) && options.buffer[fdNumber]);
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].platform === 'win32' && __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].basename(file, '.exe') === 'cmd') {
        // #116
        commandArguments.unshift('/q');
    }
    return {
        file,
        commandArguments,
        options
    };
};
const addDefaultOptions = ({ extendEnv = true, preferLocal = false, cwd, localDir: localDirectory = cwd, encoding = 'utf8', reject = true, cleanup = true, all = false, windowsHide = true, killSignal = 'SIGTERM', forceKillAfterDelay = true, gracefulCancel = false, ipcInput, ipc = ipcInput !== undefined || gracefulCancel, serialization = 'advanced', ...options })=>({
        ...options,
        extendEnv,
        preferLocal,
        cwd,
        localDirectory,
        encoding,
        reject,
        cleanup,
        all,
        windowsHide,
        killSignal,
        forceKillAfterDelay,
        gracefulCancel,
        ipcInput,
        ipc,
        serialization
    });
const getEnv = ({ env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath })=>{
    const env = extendEnv ? {
        ...__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].env,
        ...envOption
    } : envOption;
    if (preferLocal || node) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$npm$2d$run$2d$path$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["npmRunPathEnv"])({
            env,
            cwd: localDirectory,
            execPath: nodePath,
            preferLocal,
            addExecPath: node
        });
    }
    return env;
};
}),
"[project]/node_modules/execa/lib/arguments/shell.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// When the `shell` option is set, any command argument is concatenated as a single string by Node.js:
// https://github.com/nodejs/node/blob/e38ce27f3ca0a65f68a31cedd984cddb927d4002/lib/child_process.js#L614-L624
// However, since Node 24, it also prints a deprecation warning.
// To avoid this warning, we perform that same operation before calling `node:child_process`.
// Shells only understand strings, which is why Node.js performs that concatenation.
// However, we rely on users splitting command arguments as an array.
// For example, this allows us to easily detect which arguments are passed.
// So we do want users to pass array of arguments even with `shell: true`, but we also want to avoid any warning.
__turbopack_context__.s([
    "concatenateShell",
    ()=>concatenateShell
]);
const concatenateShell = (file, commandArguments, options)=>options.shell && commandArguments.length > 0 ? [
        [
            file,
            ...commandArguments
        ].join(' '),
        [],
        options
    ] : [
        file,
        commandArguments,
        options
    ];
}),
"[project]/node_modules/execa/lib/io/max-buffer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "checkIpcMaxBuffer",
    ()=>checkIpcMaxBuffer,
    "getMaxBufferMessage",
    ()=>getMaxBufferMessage,
    "getMaxBufferSync",
    ()=>getMaxBufferSync,
    "handleMaxBuffer",
    ()=>handleMaxBuffer,
    "isMaxBufferSync",
    ()=>isMaxBufferSync,
    "truncateMaxBufferSync",
    ()=>truncateMaxBufferSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$contents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-stream/source/contents.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-ssr] (ecmascript)");
;
;
;
const handleMaxBuffer = ({ error, stream, readableObjectMode, lines, encoding, fdNumber })=>{
    if (!(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$contents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MaxBufferError"])) {
        throw error;
    }
    if (fdNumber === 'all') {
        return error;
    }
    const unit = getMaxBufferUnit(readableObjectMode, lines, encoding);
    error.maxBufferInfo = {
        fdNumber,
        unit
    };
    stream.destroy();
    throw error;
};
const getMaxBufferUnit = (readableObjectMode, lines, encoding)=>{
    if (readableObjectMode) {
        return 'objects';
    }
    if (lines) {
        return 'lines';
    }
    if (encoding === 'buffer') {
        return 'bytes';
    }
    return 'characters';
};
const checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer)=>{
    if (ipcOutput.length !== maxBuffer) {
        return;
    }
    const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$contents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MaxBufferError"]();
    error.maxBufferInfo = {
        fdNumber: 'ipc'
    };
    throw error;
};
const getMaxBufferMessage = (error, maxBuffer)=>{
    const { streamName, threshold, unit } = getMaxBufferInfo(error, maxBuffer);
    return `Command's ${streamName} was larger than ${threshold} ${unit}`;
};
const getMaxBufferInfo = (error, maxBuffer)=>{
    if (error?.maxBufferInfo === undefined) {
        return {
            streamName: 'output',
            threshold: maxBuffer[1],
            unit: 'bytes'
        };
    }
    const { maxBufferInfo: { fdNumber, unit } } = error;
    delete error.maxBufferInfo;
    const threshold = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFdSpecificValue"])(maxBuffer, fdNumber);
    if (fdNumber === 'ipc') {
        return {
            streamName: 'IPC output',
            threshold,
            unit: 'messages'
        };
    }
    return {
        streamName: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStreamName"])(fdNumber),
        threshold,
        unit
    };
};
const isMaxBufferSync = (resultError, output, maxBuffer)=>resultError?.code === 'ENOBUFS' && output !== null && output.some((result)=>result !== null && result.length > getMaxBufferSync(maxBuffer));
const truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer)=>{
    if (!isMaxBuffer) {
        return result;
    }
    const maxBufferValue = getMaxBufferSync(maxBuffer);
    return result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;
};
const getMaxBufferSync = ([, stdoutMaxBuffer])=>stdoutMaxBuffer;
}),
"[project]/node_modules/execa/lib/return/message.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createMessages",
    ()=>createMessages
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$final$2d$newline$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/strip-final-newline/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$cwd$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/cwd.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/escape.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/max-buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/signal.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/final-error.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
const createMessages = ({ stdio, all, ipcOutput, originalError, signal, signalDescription, exitCode, escapedCommand, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, forceKillAfterDelay, killSignal, maxBuffer, timeout, cwd })=>{
    const errorCode = originalError?.code;
    const prefix = getErrorPrefix({
        originalError,
        timedOut,
        timeout,
        isMaxBuffer,
        maxBuffer,
        errorCode,
        signal,
        signalDescription,
        exitCode,
        isCanceled,
        isGracefullyCanceled,
        isForcefullyTerminated,
        forceKillAfterDelay,
        killSignal
    });
    const originalMessage = getOriginalMessage(originalError, cwd);
    const suffix = originalMessage === undefined ? '' : `\n${originalMessage}`;
    const shortMessage = `${prefix}: ${escapedCommand}${suffix}`;
    const messageStdio = all === undefined ? [
        stdio[2],
        stdio[1]
    ] : [
        all
    ];
    const message = [
        shortMessage,
        ...messageStdio,
        ...stdio.slice(3),
        ipcOutput.map((ipcMessage)=>serializeIpcMessage(ipcMessage)).join('\n')
    ].map((messagePart)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["escapeLines"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$final$2d$newline$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(serializeMessagePart(messagePart)))).filter(Boolean).join('\n\n');
    return {
        originalMessage,
        shortMessage,
        message
    };
};
const getErrorPrefix = ({ originalError, timedOut, timeout, isMaxBuffer, maxBuffer, errorCode, signal, signalDescription, exitCode, isCanceled, isGracefullyCanceled, isForcefullyTerminated, forceKillAfterDelay, killSignal })=>{
    const forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);
    if (timedOut) {
        return `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;
    }
    if (isGracefullyCanceled) {
        if (signal === undefined) {
            return `Command was gracefully canceled with exit code ${exitCode}`;
        }
        return isForcefullyTerminated ? `Command was gracefully canceled${forcefulSuffix}` : `Command was gracefully canceled with ${signal} (${signalDescription})`;
    }
    if (isCanceled) {
        return `Command was canceled${forcefulSuffix}`;
    }
    if (isMaxBuffer) {
        return `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getMaxBufferMessage"])(originalError, maxBuffer)}${forcefulSuffix}`;
    }
    if (errorCode !== undefined) {
        return `Command failed with ${errorCode}${forcefulSuffix}`;
    }
    if (isForcefullyTerminated) {
        return `Command was killed with ${killSignal} (${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSignalDescription"])(killSignal)})${forcefulSuffix}`;
    }
    if (signal !== undefined) {
        return `Command was killed with ${signal} (${signalDescription})`;
    }
    if (exitCode !== undefined) {
        return `Command failed with exit code ${exitCode}`;
    }
    return 'Command failed';
};
const getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay)=>isForcefullyTerminated ? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds` : '';
const getOriginalMessage = (originalError, cwd)=>{
    if (originalError instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DiscardedError"]) {
        return;
    }
    const originalMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isExecaError"])(originalError) ? originalError.originalMessage : String(originalError?.message ?? originalError);
    const escapedOriginalMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["escapeLines"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$cwd$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fixCwdError"])(originalMessage, cwd));
    return escapedOriginalMessage === '' ? undefined : escapedOriginalMessage;
};
const serializeIpcMessage = (ipcMessage)=>typeof ipcMessage === 'string' ? ipcMessage : (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["inspect"])(ipcMessage);
const serializeMessagePart = (messagePart)=>Array.isArray(messagePart) ? messagePart.map((messageItem)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$final$2d$newline$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(serializeMessageItem(messageItem))).filter(Boolean).join('\n') : serializeMessageItem(messagePart);
const serializeMessageItem = (messageItem)=>{
    if (typeof messageItem === 'string') {
        return messageItem;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUint8Array"])(messageItem)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uint8ArrayToString"])(messageItem);
    }
    return '';
};
}),
"[project]/node_modules/execa/lib/return/result.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "makeEarlyError",
    ()=>makeEarlyError,
    "makeError",
    ()=>makeError,
    "makeSuccessResult",
    ()=>makeSuccessResult
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/signal.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/duration.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/final-error.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$message$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/message.js [app-ssr] (ecmascript)");
;
;
;
;
const makeSuccessResult = ({ command, escapedCommand, stdio, all, ipcOutput, options: { cwd }, startTime })=>omitUndefinedProperties({
        command,
        escapedCommand,
        cwd,
        durationMs: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDurationMs"])(startTime),
        failed: false,
        timedOut: false,
        isCanceled: false,
        isGracefullyCanceled: false,
        isTerminated: false,
        isMaxBuffer: false,
        isForcefullyTerminated: false,
        exitCode: 0,
        stdout: stdio[1],
        stderr: stdio[2],
        all,
        stdio,
        ipcOutput,
        pipedFrom: []
    });
const makeEarlyError = ({ error, command, escapedCommand, fileDescriptors, options, startTime, isSync })=>makeError({
        error,
        command,
        escapedCommand,
        startTime,
        timedOut: false,
        isCanceled: false,
        isGracefullyCanceled: false,
        isMaxBuffer: false,
        isForcefullyTerminated: false,
        stdio: Array.from({
            length: fileDescriptors.length
        }),
        ipcOutput: [],
        options,
        isSync
    });
const makeError = ({ error: originalError, command, escapedCommand, startTime, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, exitCode: rawExitCode, signal: rawSignal, stdio, all, ipcOutput, options: { timeoutDuration, timeout = timeoutDuration, forceKillAfterDelay, killSignal, cwd, maxBuffer }, isSync })=>{
    const { exitCode, signal, signalDescription } = normalizeExitPayload(rawExitCode, rawSignal);
    const { originalMessage, shortMessage, message } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$message$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createMessages"])({
        stdio,
        all,
        ipcOutput,
        originalError,
        signal,
        signalDescription,
        exitCode,
        escapedCommand,
        timedOut,
        isCanceled,
        isGracefullyCanceled,
        isMaxBuffer,
        isForcefullyTerminated,
        forceKillAfterDelay,
        killSignal,
        maxBuffer,
        timeout,
        cwd
    });
    const error = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFinalError"])(originalError, message, isSync);
    Object.assign(error, getErrorProperties({
        error,
        command,
        escapedCommand,
        startTime,
        timedOut,
        isCanceled,
        isGracefullyCanceled,
        isMaxBuffer,
        isForcefullyTerminated,
        exitCode,
        signal,
        signalDescription,
        stdio,
        all,
        ipcOutput,
        cwd,
        originalMessage,
        shortMessage
    }));
    return error;
};
const getErrorProperties = ({ error, command, escapedCommand, startTime, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, exitCode, signal, signalDescription, stdio, all, ipcOutput, cwd, originalMessage, shortMessage })=>omitUndefinedProperties({
        shortMessage,
        originalMessage,
        command,
        escapedCommand,
        cwd,
        durationMs: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDurationMs"])(startTime),
        failed: true,
        timedOut,
        isCanceled,
        isGracefullyCanceled,
        isTerminated: signal !== undefined,
        isMaxBuffer,
        isForcefullyTerminated,
        exitCode,
        signal,
        signalDescription,
        code: error.cause?.code,
        stdout: stdio[1],
        stderr: stdio[2],
        all,
        stdio,
        ipcOutput,
        pipedFrom: []
    });
const omitUndefinedProperties = (result)=>Object.fromEntries(Object.entries(result).filter(([, value])=>value !== undefined));
// `signal` and `exitCode` emitted on `subprocess.on('exit')` event can be `null`.
// We normalize them to `undefined`
const normalizeExitPayload = (rawExitCode, rawSignal)=>{
    const exitCode = rawExitCode === null ? undefined : rawExitCode;
    const signal = rawSignal === null ? undefined : rawSignal;
    const signalDescription = signal === undefined ? undefined : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSignalDescription"])(rawSignal);
    return {
        exitCode,
        signal,
        signalDescription
    };
};
}),
"[project]/node_modules/execa/lib/verbose/error.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logError",
    ()=>logError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/log.js [app-ssr] (ecmascript)");
;
const logError = (result, verboseInfo)=>{
    if (result.failed) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["verboseLog"])({
            type: 'error',
            verboseMessage: result.shortMessage,
            verboseInfo,
            result
        });
    }
};
}),
"[project]/node_modules/execa/lib/verbose/complete.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logResult",
    ()=>logResult
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pretty$2d$ms$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pretty-ms/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/log.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/error.js [app-ssr] (ecmascript)");
;
;
;
;
const logResult = (result, verboseInfo)=>{
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isVerbose"])(verboseInfo)) {
        return;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logError"])(result, verboseInfo);
    logDuration(result, verboseInfo);
};
const logDuration = (result, verboseInfo)=>{
    const verboseMessage = `(done in ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pretty$2d$ms$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(result.durationMs)})`;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["verboseLog"])({
        type: 'duration',
        verboseMessage,
        verboseInfo,
        result
    });
};
}),
"[project]/node_modules/execa/lib/return/reject.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleResult",
    ()=>handleResult
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$complete$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/complete.js [app-ssr] (ecmascript)");
;
const handleResult = (result, verboseInfo, { reject })=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$complete$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logResult"])(result, verboseInfo);
    if (result.failed && reject) {
        throw result;
    }
    return result;
};
}),
"[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FILE_TYPES",
    ()=>FILE_TYPES,
    "FORBID_DUPLICATE_TYPES",
    ()=>FORBID_DUPLICATE_TYPES,
    "SPECIAL_DUPLICATE_TYPES",
    ()=>SPECIAL_DUPLICATE_TYPES,
    "SPECIAL_DUPLICATE_TYPES_SYNC",
    ()=>SPECIAL_DUPLICATE_TYPES_SYNC,
    "TRANSFORM_TYPES",
    ()=>TRANSFORM_TYPES,
    "TYPE_TO_MESSAGE",
    ()=>TYPE_TO_MESSAGE,
    "getStdioItemType",
    ()=>getStdioItemType,
    "isAsyncGenerator",
    ()=>isAsyncGenerator,
    "isFilePathString",
    ()=>isFilePathString,
    "isRegularUrl",
    ()=>isRegularUrl,
    "isUnknownStdioString",
    ()=>isUnknownStdioString,
    "isUrl",
    ()=>isUrl,
    "isWritableStream",
    ()=>isWritableStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-stream/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
;
;
;
const getStdioItemType = (value, optionName)=>{
    if (isAsyncGenerator(value)) {
        return 'asyncGenerator';
    }
    if (isSyncGenerator(value)) {
        return 'generator';
    }
    if (isUrl(value)) {
        return 'fileUrl';
    }
    if (isFilePathObject(value)) {
        return 'filePath';
    }
    if (isWebStream(value)) {
        return 'webStream';
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStream"])(value, {
        checkOpen: false
    })) {
        return 'native';
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUint8Array"])(value)) {
        return 'uint8Array';
    }
    if (isAsyncIterableObject(value)) {
        return 'asyncIterable';
    }
    if (isIterableObject(value)) {
        return 'iterable';
    }
    if (isTransformStream(value)) {
        return getTransformStreamType({
            transform: value
        }, optionName);
    }
    if (isTransformOptions(value)) {
        return getTransformObjectType(value, optionName);
    }
    return 'native';
};
const getTransformObjectType = (value, optionName)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isDuplexStream"])(value.transform, {
        checkOpen: false
    })) {
        return getDuplexType(value, optionName);
    }
    if (isTransformStream(value.transform)) {
        return getTransformStreamType(value, optionName);
    }
    return getGeneratorObjectType(value, optionName);
};
const getDuplexType = (value, optionName)=>{
    validateNonGeneratorType(value, optionName, 'Duplex stream');
    return 'duplex';
};
const getTransformStreamType = (value, optionName)=>{
    validateNonGeneratorType(value, optionName, 'web TransformStream');
    return 'webTransform';
};
const validateNonGeneratorType = ({ final, binary, objectMode }, optionName, typeName)=>{
    checkUndefinedOption(final, `${optionName}.final`, typeName);
    checkUndefinedOption(binary, `${optionName}.binary`, typeName);
    checkBooleanOption(objectMode, `${optionName}.objectMode`);
};
const checkUndefinedOption = (value, optionName, typeName)=>{
    if (value !== undefined) {
        throw new TypeError(`The \`${optionName}\` option can only be defined when using a generator, not a ${typeName}.`);
    }
};
const getGeneratorObjectType = ({ transform, final, binary, objectMode }, optionName)=>{
    if (transform !== undefined && !isGenerator(transform)) {
        throw new TypeError(`The \`${optionName}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isDuplexStream"])(final, {
        checkOpen: false
    })) {
        throw new TypeError(`The \`${optionName}.final\` option must not be a Duplex stream.`);
    }
    if (isTransformStream(final)) {
        throw new TypeError(`The \`${optionName}.final\` option must not be a web TransformStream.`);
    }
    if (final !== undefined && !isGenerator(final)) {
        throw new TypeError(`The \`${optionName}.final\` option must be a generator.`);
    }
    checkBooleanOption(binary, `${optionName}.binary`);
    checkBooleanOption(objectMode, `${optionName}.objectMode`);
    return isAsyncGenerator(transform) || isAsyncGenerator(final) ? 'asyncGenerator' : 'generator';
};
const checkBooleanOption = (value, optionName)=>{
    if (value !== undefined && typeof value !== 'boolean') {
        throw new TypeError(`The \`${optionName}\` option must use a boolean.`);
    }
};
const isGenerator = (value)=>isAsyncGenerator(value) || isSyncGenerator(value);
const isAsyncGenerator = (value)=>Object.prototype.toString.call(value) === '[object AsyncGeneratorFunction]';
const isSyncGenerator = (value)=>Object.prototype.toString.call(value) === '[object GeneratorFunction]';
const isTransformOptions = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value) && (value.transform !== undefined || value.final !== undefined);
const isUrl = (value)=>Object.prototype.toString.call(value) === '[object URL]';
const isRegularUrl = (value)=>isUrl(value) && value.protocol !== 'file:';
const isFilePathObject = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value) && Object.keys(value).length > 0 && Object.keys(value).every((key)=>FILE_PATH_KEYS.has(key)) && isFilePathString(value.file);
const FILE_PATH_KEYS = new Set([
    'file',
    'append'
]);
const isFilePathString = (file)=>typeof file === 'string';
const isUnknownStdioString = (type, value)=>type === 'native' && typeof value === 'string' && !KNOWN_STDIO_STRINGS.has(value);
const KNOWN_STDIO_STRINGS = new Set([
    'ipc',
    'ignore',
    'inherit',
    'overlapped',
    'pipe'
]);
const isReadableStream = (value)=>Object.prototype.toString.call(value) === '[object ReadableStream]';
const isWritableStream = (value)=>Object.prototype.toString.call(value) === '[object WritableStream]';
const isWebStream = (value)=>isReadableStream(value) || isWritableStream(value);
const isTransformStream = (value)=>isReadableStream(value?.readable) && isWritableStream(value?.writable);
const isAsyncIterableObject = (value)=>isObject(value) && typeof value[Symbol.asyncIterator] === 'function';
const isIterableObject = (value)=>isObject(value) && typeof value[Symbol.iterator] === 'function';
const isObject = (value)=>typeof value === 'object' && value !== null;
const TRANSFORM_TYPES = new Set([
    'generator',
    'asyncGenerator',
    'duplex',
    'webTransform'
]);
const FILE_TYPES = new Set([
    'fileUrl',
    'filePath',
    'fileNumber'
]);
const SPECIAL_DUPLICATE_TYPES_SYNC = new Set([
    'fileUrl',
    'filePath'
]);
const SPECIAL_DUPLICATE_TYPES = new Set([
    ...SPECIAL_DUPLICATE_TYPES_SYNC,
    'webStream',
    'nodeStream'
]);
const FORBID_DUPLICATE_TYPES = new Set([
    'webTransform',
    'duplex'
]);
const TYPE_TO_MESSAGE = {
    generator: 'a generator',
    asyncGenerator: 'an async generator',
    fileUrl: 'a file URL',
    filePath: 'a file path string',
    fileNumber: 'a file descriptor number',
    webStream: 'a web stream',
    nodeStream: 'a Node.js stream',
    webTransform: 'a web TransformStream',
    duplex: 'a Duplex stream',
    native: 'any value',
    iterable: 'an iterable',
    asyncIterable: 'an async iterable',
    string: 'a string',
    uint8Array: 'a Uint8Array'
};
}),
"[project]/node_modules/execa/lib/transform/object-mode.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getFdObjectMode",
    ()=>getFdObjectMode,
    "getTransformObjectModes",
    ()=>getTransformObjectModes
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
;
const getTransformObjectModes = (objectMode, index, newTransforms, direction)=>direction === 'output' ? getOutputObjectModes(objectMode, index, newTransforms) : getInputObjectModes(objectMode, index, newTransforms);
const getOutputObjectModes = (objectMode, index, newTransforms)=>{
    const writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;
    const readableObjectMode = objectMode ?? writableObjectMode;
    return {
        writableObjectMode,
        readableObjectMode
    };
};
const getInputObjectModes = (objectMode, index, newTransforms)=>{
    const writableObjectMode = index === 0 ? objectMode === true : newTransforms[index - 1].value.readableObjectMode;
    const readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);
    return {
        writableObjectMode,
        readableObjectMode
    };
};
const getFdObjectMode = (stdioItems, direction)=>{
    const lastTransform = stdioItems.findLast(({ type })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type));
    if (lastTransform === undefined) {
        return false;
    }
    return direction === 'input' ? lastTransform.value.writableObjectMode : lastTransform.value.readableObjectMode;
};
}),
"[project]/node_modules/execa/lib/transform/normalize.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizeTransforms",
    ()=>normalizeTransforms
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$object$2d$mode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/object-mode.js [app-ssr] (ecmascript)");
;
;
;
;
const normalizeTransforms = (stdioItems, optionName, direction, options)=>[
        ...stdioItems.filter(({ type })=>!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type)),
        ...getTransforms(stdioItems, optionName, direction, options)
    ];
const getTransforms = (stdioItems, optionName, direction, { encoding })=>{
    const transforms = stdioItems.filter(({ type })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type));
    const newTransforms = Array.from({
        length: transforms.length
    });
    for (const [index, stdioItem] of Object.entries(transforms)){
        newTransforms[index] = normalizeTransform({
            stdioItem,
            index: Number(index),
            newTransforms,
            optionName,
            direction,
            encoding
        });
    }
    return sortTransforms(newTransforms, direction);
};
const normalizeTransform = ({ stdioItem, stdioItem: { type }, index, newTransforms, optionName, direction, encoding })=>{
    if (type === 'duplex') {
        return normalizeDuplex({
            stdioItem,
            optionName
        });
    }
    if (type === 'webTransform') {
        return normalizeTransformStream({
            stdioItem,
            index,
            newTransforms,
            direction
        });
    }
    return normalizeGenerator({
        stdioItem,
        index,
        newTransforms,
        direction,
        encoding
    });
};
const normalizeDuplex = ({ stdioItem, stdioItem: { value: { transform, transform: { writableObjectMode, readableObjectMode }, objectMode = readableObjectMode } }, optionName })=>{
    if (objectMode && !readableObjectMode) {
        throw new TypeError(`The \`${optionName}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);
    }
    if (!objectMode && readableObjectMode) {
        throw new TypeError(`The \`${optionName}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);
    }
    return {
        ...stdioItem,
        value: {
            transform,
            writableObjectMode,
            readableObjectMode
        }
    };
};
const normalizeTransformStream = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction })=>{
    const { transform, objectMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value) ? value : {
        transform: value
    };
    const { writableObjectMode, readableObjectMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$object$2d$mode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getTransformObjectModes"])(objectMode, index, newTransforms, direction);
    return {
        ...stdioItem,
        value: {
            transform,
            writableObjectMode,
            readableObjectMode
        }
    };
};
const normalizeGenerator = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction, encoding })=>{
    const { transform, final, binary: binaryOption = false, preserveNewlines = false, objectMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value) ? value : {
        transform: value
    };
    const binary = binaryOption || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(encoding);
    const { writableObjectMode, readableObjectMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$object$2d$mode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getTransformObjectModes"])(objectMode, index, newTransforms, direction);
    return {
        ...stdioItem,
        value: {
            transform,
            final,
            binary,
            preserveNewlines,
            writableObjectMode,
            readableObjectMode
        }
    };
};
const sortTransforms = (newTransforms, direction)=>direction === 'input' ? newTransforms.reverse() : newTransforms;
}),
"[project]/node_modules/execa/lib/stdio/direction.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getStreamDirection",
    ()=>getStreamDirection
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-stream/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
;
;
;
const getStreamDirection = (stdioItems, fdNumber, optionName)=>{
    const directions = stdioItems.map((stdioItem)=>getStdioItemDirection(stdioItem, fdNumber));
    if (directions.includes('input') && directions.includes('output')) {
        throw new TypeError(`The \`${optionName}\` option must not be an array of both readable and writable values.`);
    }
    return directions.find(Boolean) ?? DEFAULT_DIRECTION;
};
const getStdioItemDirection = ({ type, value }, fdNumber)=>KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);
// `stdin`/`stdout`/`stderr` have a known direction
const KNOWN_DIRECTIONS = [
    'input',
    'output',
    'output'
];
const anyDirection = ()=>undefined;
const alwaysInput = ()=>'input';
// `string` can only be added through the `input` option, i.e. does not need to be handled here
const guessStreamDirection = {
    generator: anyDirection,
    asyncGenerator: anyDirection,
    fileUrl: anyDirection,
    filePath: anyDirection,
    iterable: alwaysInput,
    asyncIterable: alwaysInput,
    uint8Array: alwaysInput,
    webStream: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isWritableStream"])(value) ? 'output' : 'input',
    nodeStream (value) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isReadableStream"])(value, {
            checkOpen: false
        })) {
            return 'output';
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isWritableStream"])(value, {
            checkOpen: false
        }) ? undefined : 'input';
    },
    webTransform: anyDirection,
    duplex: anyDirection,
    native (value) {
        const standardStreamDirection = getStandardStreamDirection(value);
        if (standardStreamDirection !== undefined) {
            return standardStreamDirection;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStream"])(value, {
            checkOpen: false
        })) {
            return guessStreamDirection.nodeStream(value);
        }
    }
};
const getStandardStreamDirection = (value)=>{
    if ([
        0,
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdin
    ].includes(value)) {
        return 'input';
    }
    if ([
        1,
        2,
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stdout,
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].stderr
    ].includes(value)) {
        return 'output';
    }
};
// When ambiguous, we initially keep the direction as `undefined`.
// This allows arrays of `stdio` values to resolve the ambiguity.
// For example, `stdio[3]: DuplexStream` is ambiguous, but `stdio[3]: [DuplexStream, WritableStream]` is not.
// When the ambiguity remains, we default to `output` since it is the most common use case for additional file descriptors.
const DEFAULT_DIRECTION = 'output';
}),
"[project]/node_modules/execa/lib/ipc/array.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// The `ipc` option adds an `ipc` item to the `stdio` option
__turbopack_context__.s([
    "normalizeIpcStdioArray",
    ()=>normalizeIpcStdioArray
]);
const normalizeIpcStdioArray = (stdioArray, ipc)=>ipc && !stdioArray.includes('ipc') ? [
        ...stdioArray,
        'ipc'
    ] : stdioArray;
}),
"[project]/node_modules/execa/lib/stdio/stdio-option.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizeStdioOption",
    ()=>normalizeStdioOption
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-ssr] (ecmascript)");
;
;
;
const normalizeStdioOption = ({ stdio, ipc, buffer, ...options }, verboseInfo, isSync)=>{
    const stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber)=>addDefaultValue(stdioOption, fdNumber));
    return isSync ? normalizeStdioSync(stdioArray, buffer, verboseInfo) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeIpcStdioArray"])(stdioArray, ipc);
};
const getStdioArray = (stdio, options)=>{
    if (stdio === undefined) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].map((alias)=>options[alias]);
    }
    if (hasAlias(options)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].map((alias)=>`\`${alias}\``).join(', ')}`);
    }
    if (typeof stdio === 'string') {
        return [
            stdio,
            stdio,
            stdio
        ];
    }
    if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    }
    const length = Math.max(stdio.length, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].length);
    return Array.from({
        length
    }, (_, fdNumber)=>stdio[fdNumber]);
};
const hasAlias = (options)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].some((alias)=>options[alias] !== undefined);
const addDefaultValue = (stdioOption, fdNumber)=>{
    if (Array.isArray(stdioOption)) {
        return stdioOption.map((item)=>addDefaultValue(item, fdNumber));
    }
    if (stdioOption === null || stdioOption === undefined) {
        return fdNumber >= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].length ? 'ignore' : 'pipe';
    }
    return stdioOption;
};
// Using `buffer: false` with synchronous methods implies `stdout`/`stderr`: `ignore`.
// Unless the output is needed, e.g. due to `verbose: 'full'` or to redirecting to a file.
const normalizeStdioSync = (stdioArray, buffer, verboseInfo)=>stdioArray.map((stdioOption, fdNumber)=>!buffer[fdNumber] && fdNumber !== 0 && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFullVerbose"])(verboseInfo, fdNumber) && isOutputPipeOnly(stdioOption) ? 'ignore' : stdioOption);
const isOutputPipeOnly = (stdioOption)=>stdioOption === 'pipe' || Array.isArray(stdioOption) && stdioOption.every((item)=>item === 'pipe');
}),
"[project]/node_modules/execa/lib/stdio/native.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleNativeStream",
    ()=>handleNativeStream
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:tty [external] (node:tty, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-stream/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
const handleNativeStream = ({ stdioItem, stdioItem: { type }, isStdioArray, fdNumber, direction, isSync })=>{
    if (!isStdioArray || type !== 'native') {
        return stdioItem;
    }
    return isSync ? handleNativeStreamSync({
        stdioItem,
        fdNumber,
        direction
    }) : handleNativeStreamAsync({
        stdioItem,
        fdNumber
    });
};
// Synchronous methods use a different logic.
// 'inherit', file descriptors and process.std* are handled by readFileSync()/writeFileSync().
const handleNativeStreamSync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber, direction })=>{
    const targetFd = getTargetFd({
        value,
        optionName,
        fdNumber,
        direction
    });
    if (targetFd !== undefined) {
        return targetFd;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStream"])(value, {
        checkOpen: false
    })) {
        throw new TypeError(`The \`${optionName}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);
    }
    return stdioItem;
};
const getTargetFd = ({ value, optionName, fdNumber, direction })=>{
    const targetFdNumber = getTargetFdNumber(value, fdNumber);
    if (targetFdNumber === undefined) {
        return;
    }
    if (direction === 'output') {
        return {
            type: 'fileNumber',
            value: targetFdNumber,
            optionName
        };
    }
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$tty__$5b$external$5d$__$28$node$3a$tty$2c$__cjs$29$__["default"].isatty(targetFdNumber)) {
        throw new TypeError(`The \`${optionName}: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeOptionValue"])(value)}\` option is invalid: it cannot be a TTY with synchronous methods.`);
    }
    return {
        type: 'uint8Array',
        value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufferToUint8Array"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["readFileSync"])(targetFdNumber)),
        optionName
    };
};
const getTargetFdNumber = (value, fdNumber)=>{
    if (value === 'inherit') {
        return fdNumber;
    }
    if (typeof value === 'number') {
        return value;
    }
    const standardStreamIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS"].indexOf(value);
    if (standardStreamIndex !== -1) {
        return standardStreamIndex;
    }
};
const handleNativeStreamAsync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber })=>{
    if (value === 'inherit') {
        return {
            type: 'nodeStream',
            value: getStandardStream(fdNumber, value, optionName),
            optionName
        };
    }
    if (typeof value === 'number') {
        return {
            type: 'nodeStream',
            value: getStandardStream(value, value, optionName),
            optionName
        };
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStream"])(value, {
        checkOpen: false
    })) {
        return {
            type: 'nodeStream',
            value,
            optionName
        };
    }
    return stdioItem;
};
// Node.js does not allow to easily retrieve file descriptors beyond stdin/stdout/stderr as streams.
//  - `fs.createReadStream()`/`fs.createWriteStream()` with the `fd` option do not work with character devices that use blocking reads/writes (such as interactive TTYs).
//  - Using a TCP `Socket` would work but be rather complex to implement.
// Since this is an edge case, we simply throw an error message.
// See https://github.com/sindresorhus/execa/pull/643#discussion_r1435905707
const getStandardStream = (fdNumber, value, optionName)=>{
    const standardStream = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STANDARD_STREAMS"][fdNumber];
    if (standardStream === undefined) {
        throw new TypeError(`The \`${optionName}: ${value}\` option is invalid: no such standard stream.`);
    }
    return standardStream;
};
}),
"[project]/node_modules/execa/lib/stdio/input-option.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleInputOptions",
    ()=>handleInputOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-stream/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
;
;
;
const handleInputOptions = ({ input, inputFile }, fdNumber)=>fdNumber === 0 ? [
        ...handleInputOption(input),
        ...handleInputFileOption(inputFile)
    ] : [];
const handleInputOption = (input)=>input === undefined ? [] : [
        {
            type: getInputType(input),
            value: input,
            optionName: 'input'
        }
    ];
const getInputType = (input)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isReadableStream"])(input, {
        checkOpen: false
    })) {
        return 'nodeStream';
    }
    if (typeof input === 'string') {
        return 'string';
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUint8Array"])(input)) {
        return 'uint8Array';
    }
    throw new Error('The `input` option must be a string, a Uint8Array or a Node.js Readable stream.');
};
const handleInputFileOption = (inputFile)=>inputFile === undefined ? [] : [
        {
            ...getInputFileType(inputFile),
            optionName: 'inputFile'
        }
    ];
const getInputFileType = (inputFile)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUrl"])(inputFile)) {
        return {
            type: 'fileUrl',
            value: inputFile
        };
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFilePathString"])(inputFile)) {
        return {
            type: 'filePath',
            value: {
                file: inputFile
            }
        };
    }
    throw new Error('The `inputFile` option must be a file path string or a file URL.');
};
}),
"[project]/node_modules/execa/lib/stdio/duplicate.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "filterDuplicates",
    ()=>filterDuplicates,
    "getDuplicateStream",
    ()=>getDuplicateStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
;
const filterDuplicates = (stdioItems)=>stdioItems.filter((stdioItemOne, indexOne)=>stdioItems.every((stdioItemTwo, indexTwo)=>stdioItemOne.value !== stdioItemTwo.value || indexOne >= indexTwo || stdioItemOne.type === 'generator' || stdioItemOne.type === 'asyncGenerator'));
const getDuplicateStream = ({ stdioItem: { type, value, optionName }, direction, fileDescriptors, isSync })=>{
    const otherStdioItems = getOtherStdioItems(fileDescriptors, type);
    if (otherStdioItems.length === 0) {
        return;
    }
    if (isSync) {
        validateDuplicateStreamSync({
            otherStdioItems,
            type,
            value,
            optionName,
            direction
        });
        return;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SPECIAL_DUPLICATE_TYPES"].has(type)) {
        return getDuplicateStreamInstance({
            otherStdioItems,
            type,
            value,
            optionName,
            direction
        });
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FORBID_DUPLICATE_TYPES"].has(type)) {
        validateDuplicateTransform({
            otherStdioItems,
            type,
            value,
            optionName
        });
    }
};
// Values shared by multiple file descriptors
const getOtherStdioItems = (fileDescriptors, type)=>fileDescriptors.flatMap(({ direction, stdioItems })=>stdioItems.filter((stdioItem)=>stdioItem.type === type).map((stdioItem)=>({
                ...stdioItem,
                direction
            })));
// With `execaSync()`, do not allow setting a file path both in input and output
const validateDuplicateStreamSync = ({ otherStdioItems, type, value, optionName, direction })=>{
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SPECIAL_DUPLICATE_TYPES_SYNC"].has(type)) {
        getDuplicateStreamInstance({
            otherStdioItems,
            type,
            value,
            optionName,
            direction
        });
    }
};
// When two file descriptors share the file or stream, we need to re-use the same underlying stream.
// Otherwise, the stream would be closed twice when piping ends.
// This is only an issue with output file descriptors.
// This is not a problem with generator functions since those create a new instance for each file descriptor.
// We also forbid input and output file descriptors sharing the same file or stream, since that does not make sense.
const getDuplicateStreamInstance = ({ otherStdioItems, type, value, optionName, direction })=>{
    const duplicateStdioItems = otherStdioItems.filter((stdioItem)=>hasSameValue(stdioItem, value));
    if (duplicateStdioItems.length === 0) {
        return;
    }
    const differentStdioItem = duplicateStdioItems.find((stdioItem)=>stdioItem.direction !== direction);
    throwOnDuplicateStream(differentStdioItem, optionName, type);
    return direction === 'output' ? duplicateStdioItems[0].stream : undefined;
};
const hasSameValue = ({ type, value }, secondValue)=>{
    if (type === 'filePath') {
        return value.file === secondValue.file;
    }
    if (type === 'fileUrl') {
        return value.href === secondValue.href;
    }
    return value === secondValue;
};
// We do not allow two file descriptors to share the same Duplex or TransformStream.
// This is because those are set directly to `subprocess.std*`.
// For example, this could result in `subprocess.stdout` and `subprocess.stderr` being the same value.
// This means reading from either would get data from both stdout and stderr.
const validateDuplicateTransform = ({ otherStdioItems, type, value, optionName })=>{
    const duplicateStdioItem = otherStdioItems.find(({ value: { transform } })=>transform === value.transform);
    throwOnDuplicateStream(duplicateStdioItem, optionName, type);
};
const throwOnDuplicateStream = (stdioItem, optionName, type)=>{
    if (stdioItem !== undefined) {
        throw new TypeError(`The \`${stdioItem.optionName}\` and \`${optionName}\` options must not target ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE_TO_MESSAGE"][type]} that is the same.`);
    }
};
}),
"[project]/node_modules/execa/lib/stdio/handle.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cleanupCustomStreams",
    ()=>cleanupCustomStreams,
    "handleStdio",
    ()=>handleStdio
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$normalize$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/normalize.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$object$2d$mode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/object-mode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$direction$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/direction.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$stdio$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/stdio-option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$native$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/native.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$input$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/input-option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$duplicate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/duplicate.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
const handleStdio = (addProperties, options, verboseInfo, isSync)=>{
    const stdio = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$stdio$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeStdioOption"])(options, verboseInfo, isSync);
    const initialFileDescriptors = stdio.map((stdioOption, fdNumber)=>getFileDescriptor({
            stdioOption,
            fdNumber,
            options,
            isSync
        }));
    const fileDescriptors = getFinalFileDescriptors({
        initialFileDescriptors,
        addProperties,
        options,
        isSync
    });
    options.stdio = fileDescriptors.map(({ stdioItems })=>forwardStdio(stdioItems));
    return fileDescriptors;
};
const getFileDescriptor = ({ stdioOption, fdNumber, options, isSync })=>{
    const optionName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStreamName"])(fdNumber);
    const { stdioItems: initialStdioItems, isStdioArray } = initializeStdioItems({
        stdioOption,
        fdNumber,
        options,
        optionName
    });
    const direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$direction$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStreamDirection"])(initialStdioItems, fdNumber, optionName);
    const stdioItems = initialStdioItems.map((stdioItem)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$native$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleNativeStream"])({
            stdioItem,
            isStdioArray,
            fdNumber,
            direction,
            isSync
        }));
    const normalizedStdioItems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$normalize$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeTransforms"])(stdioItems, optionName, direction, options);
    const objectMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$object$2d$mode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFdObjectMode"])(normalizedStdioItems, direction);
    validateFileObjectMode(normalizedStdioItems, objectMode);
    return {
        direction,
        objectMode,
        stdioItems: normalizedStdioItems
    };
};
// We make sure passing an array with a single item behaves the same as passing that item without an array.
// This is what users would expect.
// For example, `stdout: ['ignore']` behaves the same as `stdout: 'ignore'`.
const initializeStdioItems = ({ stdioOption, fdNumber, options, optionName })=>{
    const values = Array.isArray(stdioOption) ? stdioOption : [
        stdioOption
    ];
    const initialStdioItems = [
        ...values.map((value)=>initializeStdioItem(value, optionName)),
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$input$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleInputOptions"])(options, fdNumber)
    ];
    const stdioItems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$duplicate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filterDuplicates"])(initialStdioItems);
    const isStdioArray = stdioItems.length > 1;
    validateStdioArray(stdioItems, isStdioArray, optionName);
    validateStreams(stdioItems);
    return {
        stdioItems,
        isStdioArray
    };
};
const initializeStdioItem = (value, optionName)=>({
        type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStdioItemType"])(value, optionName),
        value,
        optionName
    });
const validateStdioArray = (stdioItems, isStdioArray, optionName)=>{
    if (stdioItems.length === 0) {
        throw new TypeError(`The \`${optionName}\` option must not be an empty array.`);
    }
    if (!isStdioArray) {
        return;
    }
    for (const { value, optionName } of stdioItems){
        if (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {
            throw new Error(`The \`${optionName}\` option must not include \`${value}\`.`);
        }
    }
};
// Using those `stdio` values together with others for the same stream does not make sense, so we make it fail.
// However, we do allow it if the array has a single item.
const INVALID_STDIO_ARRAY_OPTIONS = new Set([
    'ignore',
    'ipc'
]);
const validateStreams = (stdioItems)=>{
    for (const stdioItem of stdioItems){
        validateFileStdio(stdioItem);
    }
};
const validateFileStdio = ({ type, value, optionName })=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isRegularUrl"])(value)) {
        throw new TypeError(`The \`${optionName}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUnknownStdioString"])(type, value)) {
        throw new TypeError(`The \`${optionName}: { file: '...' }\` option must be used instead of \`${optionName}: '...'\`.`);
    }
};
const validateFileObjectMode = (stdioItems, objectMode)=>{
    if (!objectMode) {
        return;
    }
    const fileStdioItem = stdioItems.find(({ type })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FILE_TYPES"].has(type));
    if (fileStdioItem !== undefined) {
        throw new TypeError(`The \`${fileStdioItem.optionName}\` option cannot use both files and transforms in objectMode.`);
    }
};
// Some `stdio` values require Execa to create streams.
// For example, file paths create file read/write streams.
// Those transformations are specified in `addProperties`, which is both direction-specific and type-specific.
const getFinalFileDescriptors = ({ initialFileDescriptors, addProperties, options, isSync })=>{
    const fileDescriptors = [];
    try {
        for (const fileDescriptor of initialFileDescriptors){
            fileDescriptors.push(getFinalFileDescriptor({
                fileDescriptor,
                fileDescriptors,
                addProperties,
                options,
                isSync
            }));
        }
        return fileDescriptors;
    } catch (error) {
        cleanupCustomStreams(fileDescriptors);
        throw error;
    }
};
const getFinalFileDescriptor = ({ fileDescriptor: { direction, objectMode, stdioItems }, fileDescriptors, addProperties, options, isSync })=>{
    const finalStdioItems = stdioItems.map((stdioItem)=>addStreamProperties({
            stdioItem,
            addProperties,
            direction,
            options,
            fileDescriptors,
            isSync
        }));
    return {
        direction,
        objectMode,
        stdioItems: finalStdioItems
    };
};
const addStreamProperties = ({ stdioItem, addProperties, direction, options, fileDescriptors, isSync })=>{
    const duplicateStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$duplicate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDuplicateStream"])({
        stdioItem,
        direction,
        fileDescriptors,
        isSync
    });
    if (duplicateStream !== undefined) {
        return {
            ...stdioItem,
            stream: duplicateStream
        };
    }
    return {
        ...stdioItem,
        ...addProperties[direction][stdioItem.type](stdioItem, options)
    };
};
const cleanupCustomStreams = (fileDescriptors)=>{
    for (const { stdioItems } of fileDescriptors){
        for (const { stream } of stdioItems){
            if (stream !== undefined && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStandardStream"])(stream)) {
                stream.destroy();
            }
        }
    }
};
// When the `std*: Iterable | WebStream | URL | filePath`, `input` or `inputFile` option is used, we pipe to `subprocess.std*`.
// When the `std*: Array` option is used, we emulate some of the native values ('inherit', Node.js stream and file descriptor integer). To do so, we also need to pipe to `subprocess.std*`.
// Therefore the `std*` options must be either `pipe` or `overlapped`. Other values do not set `subprocess.std*`.
const forwardStdio = (stdioItems)=>{
    if (stdioItems.length > 1) {
        return stdioItems.some(({ value })=>value === 'overlapped') ? 'overlapped' : 'pipe';
    }
    const [{ type, value }] = stdioItems;
    return type === 'native' ? value : 'pipe';
};
}),
"[project]/node_modules/execa/lib/stdio/handle-sync.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleStdioSync",
    ()=>handleStdioSync
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$handle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/handle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
;
;
;
;
const handleStdioSync = (options, verboseInfo)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$handle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleStdio"])(addPropertiesSync, options, verboseInfo, true);
const forbiddenIfSync = ({ type, optionName })=>{
    throwInvalidSyncValue(optionName, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE_TO_MESSAGE"][type]);
};
const forbiddenNativeIfSync = ({ optionName, value })=>{
    if (value === 'ipc' || value === 'overlapped') {
        throwInvalidSyncValue(optionName, `"${value}"`);
    }
    return {};
};
const throwInvalidSyncValue = (optionName, value)=>{
    throw new TypeError(`The \`${optionName}\` option cannot be ${value} with synchronous methods.`);
};
// Create streams used internally for redirecting when using specific values for the `std*` options, in sync mode.
// For example, `stdin: {file}` reads the file synchronously, then passes it as the `input` option.
const addProperties = {
    generator () {},
    asyncGenerator: forbiddenIfSync,
    webStream: forbiddenIfSync,
    nodeStream: forbiddenIfSync,
    webTransform: forbiddenIfSync,
    duplex: forbiddenIfSync,
    asyncIterable: forbiddenIfSync,
    native: forbiddenNativeIfSync
};
const addPropertiesSync = {
    input: {
        ...addProperties,
        fileUrl: ({ value })=>({
                contents: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufferToUint8Array"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["readFileSync"])(value))
                ]
            }),
        filePath: ({ value: { file } })=>({
                contents: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufferToUint8Array"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["readFileSync"])(file))
                ]
            }),
        fileNumber: forbiddenIfSync,
        iterable: ({ value })=>({
                contents: [
                    ...value
                ]
            }),
        string: ({ value })=>({
                contents: [
                    value
                ]
            }),
        uint8Array: ({ value })=>({
                contents: [
                    value
                ]
            })
    },
    output: {
        ...addProperties,
        fileUrl: ({ value })=>({
                path: value
            }),
        filePath: ({ value: { file, append } })=>({
                path: file,
                append
            }),
        fileNumber: ({ value })=>({
                path: value
            }),
        iterable: forbiddenIfSync,
        string: forbiddenIfSync,
        uint8Array: forbiddenIfSync
    }
};
}),
"[project]/node_modules/execa/lib/io/strip-newline.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getStripFinalNewline",
    ()=>getStripFinalNewline,
    "stripNewline",
    ()=>stripNewline
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$final$2d$newline$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/strip-final-newline/index.js [app-ssr] (ecmascript)");
;
const stripNewline = (value, { stripFinalNewline }, fdNumber)=>getStripFinalNewline(stripFinalNewline, fdNumber) && value !== undefined && !Array.isArray(value) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$final$2d$newline$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value) : value;
const getStripFinalNewline = (stripFinalNewline, fdNumber)=>fdNumber === 'all' ? stripFinalNewline[1] || stripFinalNewline[2] : stripFinalNewline[fdNumber];
}),
"[project]/node_modules/execa/lib/transform/split.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Split chunks line-wise for generators passed to the `std*` options
__turbopack_context__.s([
    "getAppendNewlineGenerator",
    ()=>getAppendNewlineGenerator,
    "getSplitLinesGenerator",
    ()=>getSplitLinesGenerator,
    "splitLinesSync",
    ()=>splitLinesSync
]);
const getSplitLinesGenerator = (binary, preserveNewlines, skipped, state)=>binary || skipped ? undefined : initializeSplitLines(preserveNewlines, state);
const splitLinesSync = (chunk, preserveNewlines, objectMode)=>objectMode ? chunk.flatMap((item)=>splitLinesItemSync(item, preserveNewlines)) : splitLinesItemSync(chunk, preserveNewlines);
const splitLinesItemSync = (chunk, preserveNewlines)=>{
    const { transform, final } = initializeSplitLines(preserveNewlines, {});
    return [
        ...transform(chunk),
        ...final()
    ];
};
const initializeSplitLines = (preserveNewlines, state)=>{
    state.previousChunks = '';
    return {
        transform: splitGenerator.bind(undefined, state, preserveNewlines),
        final: linesFinal.bind(undefined, state)
    };
};
// This imperative logic is much faster than using `String.split()` and uses very low memory.
const splitGenerator = function*(state, preserveNewlines, chunk) {
    if (typeof chunk !== 'string') {
        yield chunk;
        return;
    }
    let { previousChunks } = state;
    let start = -1;
    for(let end = 0; end < chunk.length; end += 1){
        if (chunk[end] === '\n') {
            const newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);
            let line = chunk.slice(start + 1, end + 1 - newlineLength);
            if (previousChunks.length > 0) {
                line = concatString(previousChunks, line);
                previousChunks = '';
            }
            yield line;
            start = end;
        }
    }
    if (start !== chunk.length - 1) {
        previousChunks = concatString(previousChunks, chunk.slice(start + 1));
    }
    state.previousChunks = previousChunks;
};
const getNewlineLength = (chunk, end, preserveNewlines, state)=>{
    if (preserveNewlines) {
        return 0;
    }
    state.isWindowsNewline = end !== 0 && chunk[end - 1] === '\r';
    return state.isWindowsNewline ? 2 : 1;
};
const linesFinal = function*({ previousChunks }) {
    if (previousChunks.length > 0) {
        yield previousChunks;
    }
};
const getAppendNewlineGenerator = ({ binary, preserveNewlines, readableObjectMode, state })=>binary || preserveNewlines || readableObjectMode ? undefined : {
        transform: appendNewlineGenerator.bind(undefined, state)
    };
const appendNewlineGenerator = function*({ isWindowsNewline = false }, chunk) {
    const { unixNewline, windowsNewline, LF, concatBytes } = typeof chunk === 'string' ? linesStringInfo : linesUint8ArrayInfo;
    if (chunk.at(-1) === LF) {
        yield chunk;
        return;
    }
    const newline = isWindowsNewline ? windowsNewline : unixNewline;
    yield concatBytes(chunk, newline);
};
const concatString = (firstChunk, secondChunk)=>`${firstChunk}${secondChunk}`;
const linesStringInfo = {
    windowsNewline: '\r\n',
    unixNewline: '\n',
    LF: '\n',
    concatBytes: concatString
};
const concatUint8Array = (firstChunk, secondChunk)=>{
    const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
    chunk.set(firstChunk, 0);
    chunk.set(secondChunk, firstChunk.length);
    return chunk;
};
const linesUint8ArrayInfo = {
    windowsNewline: new Uint8Array([
        0x0D,
        0x0A
    ]),
    unixNewline: new Uint8Array([
        0x0A
    ]),
    LF: 0x0A,
    concatBytes: concatUint8Array
};
}),
"[project]/node_modules/execa/lib/transform/validate.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getValidateTransformInput",
    ()=>getValidateTransformInput,
    "getValidateTransformReturn",
    ()=>getValidateTransformReturn
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:buffer [external] (node:buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
;
;
const getValidateTransformInput = (writableObjectMode, optionName)=>writableObjectMode ? undefined : validateStringTransformInput.bind(undefined, optionName);
const validateStringTransformInput = function*(optionName, chunk) {
    if (typeof chunk !== 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUint8Array"])(chunk) && !__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].isBuffer(chunk)) {
        throw new TypeError(`The \`${optionName}\` option's transform must use "objectMode: true" to receive as input: ${typeof chunk}.`);
    }
    yield chunk;
};
const getValidateTransformReturn = (readableObjectMode, optionName)=>readableObjectMode ? validateObjectTransformReturn.bind(undefined, optionName) : validateStringTransformReturn.bind(undefined, optionName);
const validateObjectTransformReturn = function*(optionName, chunk) {
    validateEmptyReturn(optionName, chunk);
    yield chunk;
};
const validateStringTransformReturn = function*(optionName, chunk) {
    validateEmptyReturn(optionName, chunk);
    if (typeof chunk !== 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUint8Array"])(chunk)) {
        throw new TypeError(`The \`${optionName}\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);
    }
    yield chunk;
};
const validateEmptyReturn = (optionName, chunk)=>{
    if (chunk === null || chunk === undefined) {
        throw new TypeError(`The \`${optionName}\` option's function must not call \`yield ${chunk}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`);
    }
};
}),
"[project]/node_modules/execa/lib/transform/encoding-transform.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getEncodingTransformGenerator",
    ()=>getEncodingTransformGenerator
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:buffer [external] (node:buffer, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$string_decoder__$5b$external$5d$__$28$node$3a$string_decoder$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:string_decoder [external] (node:string_decoder, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
;
;
;
const getEncodingTransformGenerator = (binary, encoding, skipped)=>{
    if (skipped) {
        return;
    }
    if (binary) {
        return {
            transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder())
        };
    }
    const stringDecoder = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$string_decoder__$5b$external$5d$__$28$node$3a$string_decoder$2c$__cjs$29$__["StringDecoder"](encoding);
    return {
        transform: encodingStringGenerator.bind(undefined, stringDecoder),
        final: encodingStringFinal.bind(undefined, stringDecoder)
    };
};
const encodingUint8ArrayGenerator = function*(textEncoder, chunk) {
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].isBuffer(chunk)) {
        yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufferToUint8Array"])(chunk);
    } else if (typeof chunk === 'string') {
        yield textEncoder.encode(chunk);
    } else {
        yield chunk;
    }
};
const encodingStringGenerator = function*(stringDecoder, chunk) {
    yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUint8Array"])(chunk) ? stringDecoder.write(chunk) : chunk;
};
const encodingStringFinal = function*(stringDecoder) {
    const lastChunk = stringDecoder.end();
    if (lastChunk !== '') {
        yield lastChunk;
    }
};
}),
"[project]/node_modules/execa/lib/transform/run-async.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "destroyTransform",
    ()=>destroyTransform,
    "finalChunks",
    ()=>finalChunks,
    "pushChunks",
    ()=>pushChunks,
    "transformChunk",
    ()=>transformChunk
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
;
const pushChunks = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["callbackify"])(async (getChunks, state, getChunksArguments, transformStream)=>{
    state.currentIterable = getChunks(...getChunksArguments);
    try {
        for await (const chunk of state.currentIterable){
            transformStream.push(chunk);
        }
    } finally{
        delete state.currentIterable;
    }
});
const transformChunk = async function*(chunk, generators, index) {
    if (index === generators.length) {
        yield chunk;
        return;
    }
    const { transform = identityGenerator } = generators[index];
    for await (const transformedChunk of transform(chunk)){
        yield* transformChunk(transformedChunk, generators, index + 1);
    }
};
const finalChunks = async function*(generators) {
    for (const [index, { final }] of Object.entries(generators)){
        yield* generatorFinalChunks(final, Number(index), generators);
    }
};
const generatorFinalChunks = async function*(final, index, generators) {
    if (final === undefined) {
        return;
    }
    for await (const finalChunk of final()){
        yield* transformChunk(finalChunk, generators, index + 1);
    }
};
const destroyTransform = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["callbackify"])(async ({ currentIterable }, error)=>{
    if (currentIterable !== undefined) {
        await (error ? currentIterable.throw(error) : currentIterable.return());
        return;
    }
    if (error) {
        throw error;
    }
});
const identityGenerator = function*(chunk) {
    yield chunk;
};
}),
"[project]/node_modules/execa/lib/transform/run-sync.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Duplicate the code from `run-async.js` but as synchronous functions
__turbopack_context__.s([
    "finalChunksSync",
    ()=>finalChunksSync,
    "pushChunksSync",
    ()=>pushChunksSync,
    "runTransformSync",
    ()=>runTransformSync,
    "transformChunkSync",
    ()=>transformChunkSync
]);
const pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done)=>{
    try {
        for (const chunk of getChunksSync(...getChunksArguments)){
            transformStream.push(chunk);
        }
        done();
    } catch (error) {
        done(error);
    }
};
const runTransformSync = (generators, chunks)=>[
        ...chunks.flatMap((chunk)=>[
                ...transformChunkSync(chunk, generators, 0)
            ]),
        ...finalChunksSync(generators)
    ];
const transformChunkSync = function*(chunk, generators, index) {
    if (index === generators.length) {
        yield chunk;
        return;
    }
    const { transform = identityGenerator } = generators[index];
    for (const transformedChunk of transform(chunk)){
        yield* transformChunkSync(transformedChunk, generators, index + 1);
    }
};
const finalChunksSync = function*(generators) {
    for (const [index, { final }] of Object.entries(generators)){
        yield* generatorFinalChunksSync(final, Number(index), generators);
    }
};
const generatorFinalChunksSync = function*(final, index, generators) {
    if (final === undefined) {
        return;
    }
    for (const finalChunk of final()){
        yield* transformChunkSync(finalChunk, generators, index + 1);
    }
};
const identityGenerator = function*(chunk) {
    yield chunk;
};
}),
"[project]/node_modules/execa/lib/transform/generator.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generatorToStream",
    ()=>generatorToStream,
    "runGeneratorsSync",
    ()=>runGeneratorsSync
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/split.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/validate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$encoding$2d$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/encoding-transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/run-async.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/run-sync.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const generatorToStream = ({ value, value: { transform, final, writableObjectMode, readableObjectMode }, optionName }, { encoding })=>{
    const state = {};
    const generators = addInternalGenerators(value, encoding, optionName);
    const transformAsync = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAsyncGenerator"])(transform);
    const finalAsync = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAsyncGenerator"])(final);
    const transformMethod = transformAsync ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushChunks"].bind(undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformChunk"], state) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushChunksSync"].bind(undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformChunkSync"]);
    const finalMethod = transformAsync || finalAsync ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushChunks"].bind(undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["finalChunks"], state) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushChunksSync"].bind(undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["finalChunksSync"]);
    const destroyMethod = transformAsync || finalAsync ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["destroyTransform"].bind(undefined, state) : undefined;
    const stream = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Transform"]({
        writableObjectMode,
        writableHighWaterMark: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["getDefaultHighWaterMark"])(writableObjectMode),
        readableObjectMode,
        readableHighWaterMark: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["getDefaultHighWaterMark"])(readableObjectMode),
        transform (chunk, encoding, done) {
            transformMethod([
                chunk,
                generators,
                0
            ], this, done);
        },
        flush (done) {
            finalMethod([
                generators
            ], this, done);
        },
        destroy: destroyMethod
    });
    return {
        stream
    };
};
const runGeneratorsSync = (chunks, stdioItems, encoding, isInput)=>{
    const generators = stdioItems.filter(({ type })=>type === 'generator');
    const reversedGenerators = isInput ? generators.reverse() : generators;
    for (const { value, optionName } of reversedGenerators){
        const generators = addInternalGenerators(value, encoding, optionName);
        chunks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["runTransformSync"])(generators, chunks);
    }
    return chunks;
};
// Generators used internally to convert the chunk type, validate it, and split into lines
const addInternalGenerators = ({ transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines }, encoding, optionName)=>{
    const state = {};
    return [
        {
            transform: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getValidateTransformInput"])(writableObjectMode, optionName)
        },
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$encoding$2d$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getEncodingTransformGenerator"])(binary, encoding, writableObjectMode),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSplitLinesGenerator"])(binary, preserveNewlines, writableObjectMode, state),
        {
            transform,
            final
        },
        {
            transform: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getValidateTransformReturn"])(readableObjectMode, optionName)
        },
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAppendNewlineGenerator"])({
            binary,
            preserveNewlines,
            readableObjectMode,
            state
        })
    ].filter(Boolean);
};
}),
"[project]/node_modules/execa/lib/io/input-sync.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addInputOptionsSync",
    ()=>addInputOptionsSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$generator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/generator.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
;
;
;
const addInputOptionsSync = (fileDescriptors, options)=>{
    for (const fdNumber of getInputFdNumbers(fileDescriptors)){
        addInputOptionSync(fileDescriptors, fdNumber, options);
    }
};
const getInputFdNumbers = (fileDescriptors)=>new Set(Object.entries(fileDescriptors).filter(([, { direction }])=>direction === 'input').map(([fdNumber])=>Number(fdNumber)));
const addInputOptionSync = (fileDescriptors, fdNumber, options)=>{
    const { stdioItems } = fileDescriptors[fdNumber];
    const allStdioItems = stdioItems.filter(({ contents })=>contents !== undefined);
    if (allStdioItems.length === 0) {
        return;
    }
    if (fdNumber !== 0) {
        const [{ type, optionName }] = allStdioItems;
        throw new TypeError(`Only the \`stdin\` option, not \`${optionName}\`, can be ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE_TO_MESSAGE"][type]} with synchronous methods.`);
    }
    const allContents = allStdioItems.map(({ contents })=>contents);
    const transformedContents = allContents.map((contents)=>applySingleInputGeneratorsSync(contents, stdioItems));
    options.input = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["joinToUint8Array"])(transformedContents);
};
const applySingleInputGeneratorsSync = (contents, stdioItems)=>{
    const newContents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$generator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["runGeneratorsSync"])(contents, stdioItems, 'utf8', true);
    validateSerializable(newContents);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["joinToUint8Array"])(newContents);
};
const validateSerializable = (newContents)=>{
    const invalidItem = newContents.find((item)=>typeof item !== 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUint8Array"])(item));
    if (invalidItem !== undefined) {
        throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);
    }
};
}),
"[project]/node_modules/execa/lib/verbose/output.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logLines",
    ()=>logLines,
    "logLinesSync",
    ()=>logLinesSync,
    "shouldLogOutput",
    ()=>shouldLogOutput
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/log.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-ssr] (ecmascript)");
;
;
;
;
const shouldLogOutput = ({ stdioItems, encoding, verboseInfo, fdNumber })=>fdNumber !== 'all' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFullVerbose"])(verboseInfo, fdNumber) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(encoding) && fdUsesVerbose(fdNumber) && (stdioItems.some(({ type, value })=>type === 'native' && PIPED_STDIO_VALUES.has(value)) || stdioItems.every(({ type })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type)));
// Printing input streams would be confusing.
// Files and streams can produce big outputs, which we don't want to print.
// We could print `stdio[3+]` but it often is redirected to files and streams, with the same issue.
// So we only print stdout and stderr.
const fdUsesVerbose = (fdNumber)=>fdNumber === 1 || fdNumber === 2;
const PIPED_STDIO_VALUES = new Set([
    'pipe',
    'overlapped'
]);
const logLines = async (linesIterable, stream, fdNumber, verboseInfo)=>{
    for await (const line of linesIterable){
        if (!isPipingStream(stream)) {
            logLine(line, fdNumber, verboseInfo);
        }
    }
};
const logLinesSync = (linesArray, fdNumber, verboseInfo)=>{
    for (const line of linesArray){
        logLine(line, fdNumber, verboseInfo);
    }
};
// When `subprocess.stdout|stderr.pipe()` is called, `verbose` becomes a noop.
// This prevents the following problems:
//  - `.pipe()` achieves the same result as using `stdout: 'inherit'`, `stdout: stream`, etc. which also make `verbose` a noop.
//    For example, `subprocess.stdout.pipe(process.stdin)` would print each line twice.
//  - When chaining subprocesses with `subprocess.pipe(otherSubprocess)`, only the last one should print its output.
// Detecting whether `.pipe()` is impossible without monkey-patching it, so we use the following undocumented property.
// This is not a critical behavior since changes of the following property would only make `verbose` more verbose.
const isPipingStream = (stream)=>stream._readableState.pipes.length > 0;
// When `verbose` is `full`, print stdout|stderr
const logLine = (line, fdNumber, verboseInfo)=>{
    const verboseMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeVerboseMessage"])(line);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["verboseLog"])({
        type: 'output',
        verboseMessage,
        fdNumber,
        verboseInfo
    });
};
}),
"[project]/node_modules/execa/lib/io/output-sync.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "transformOutputSync",
    ()=>transformOutputSync
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$output$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/output.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$generator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/generator.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/split.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/max-buffer.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const transformOutputSync = ({ fileDescriptors, syncResult: { output }, options, isMaxBuffer, verboseInfo })=>{
    if (output === null) {
        return {
            output: Array.from({
                length: 3
            })
        };
    }
    const state = {};
    const outputFiles = new Set([]);
    const transformedOutput = output.map((result, fdNumber)=>transformOutputResultSync({
            result,
            fileDescriptors,
            fdNumber,
            state,
            outputFiles,
            isMaxBuffer,
            verboseInfo
        }, options));
    return {
        output: transformedOutput,
        ...state
    };
};
const transformOutputResultSync = ({ result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo }, { buffer, encoding, lines, stripFinalNewline, maxBuffer })=>{
    if (result === null) {
        return;
    }
    const truncatedResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncateMaxBufferSync"])(result, isMaxBuffer, maxBuffer);
    const uint8ArrayResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufferToUint8Array"])(truncatedResult);
    const { stdioItems, objectMode } = fileDescriptors[fdNumber];
    const chunks = runOutputGeneratorsSync([
        uint8ArrayResult
    ], stdioItems, encoding, state);
    const { serializedResult, finalResult = serializedResult } = serializeChunks({
        chunks,
        objectMode,
        encoding,
        lines,
        stripFinalNewline,
        fdNumber
    });
    logOutputSync({
        serializedResult,
        fdNumber,
        state,
        verboseInfo,
        encoding,
        stdioItems,
        objectMode
    });
    const returnedResult = buffer[fdNumber] ? finalResult : undefined;
    try {
        if (state.error === undefined) {
            writeToFiles(serializedResult, stdioItems, outputFiles);
        }
        return returnedResult;
    } catch (error) {
        state.error = error;
        return returnedResult;
    }
};
// Applies transform generators to `stdout`/`stderr`
const runOutputGeneratorsSync = (chunks, stdioItems, encoding, state)=>{
    try {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$generator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["runGeneratorsSync"])(chunks, stdioItems, encoding, false);
    } catch (error) {
        state.error = error;
        return chunks;
    }
};
// The contents is converted to three stages:
//  - serializedResult: used when the target is a file path/URL or a file descriptor (including 'inherit')
//  - finalResult/returnedResult: returned as `result.std*`
const serializeChunks = ({ chunks, objectMode, encoding, lines, stripFinalNewline, fdNumber })=>{
    if (objectMode) {
        return {
            serializedResult: chunks
        };
    }
    if (encoding === 'buffer') {
        return {
            serializedResult: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["joinToUint8Array"])(chunks)
        };
    }
    const serializedResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["joinToString"])(chunks, encoding);
    if (lines[fdNumber]) {
        return {
            serializedResult,
            finalResult: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["splitLinesSync"])(serializedResult, !stripFinalNewline[fdNumber], objectMode)
        };
    }
    return {
        serializedResult
    };
};
const logOutputSync = ({ serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode })=>{
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$output$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shouldLogOutput"])({
        stdioItems,
        encoding,
        verboseInfo,
        fdNumber
    })) {
        return;
    }
    const linesArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["splitLinesSync"])(serializedResult, false, objectMode);
    try {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$output$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logLinesSync"])(linesArray, fdNumber, verboseInfo);
    } catch (error) {
        state.error ??= error;
    }
};
// When the `std*` target is a file path/URL or a file descriptor
const writeToFiles = (serializedResult, stdioItems, outputFiles)=>{
    for (const { path, append } of stdioItems.filter(({ type })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FILE_TYPES"].has(type))){
        const pathString = typeof path === 'string' ? path : path.toString();
        if (append || outputFiles.has(pathString)) {
            (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["appendFileSync"])(path, serializedResult);
        } else {
            outputFiles.add(pathString);
            (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["writeFileSync"])(path, serializedResult);
        }
    }
};
}),
"[project]/node_modules/execa/lib/resolve/all-sync.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getAllSync",
    ()=>getAllSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/strip-newline.js [app-ssr] (ecmascript)");
;
;
const getAllSync = ([, stdout, stderr], options)=>{
    if (!options.all) {
        return;
    }
    if (stdout === undefined) {
        return stderr;
    }
    if (stderr === undefined) {
        return stdout;
    }
    if (Array.isArray(stdout)) {
        return Array.isArray(stderr) ? [
            ...stdout,
            ...stderr
        ] : [
            ...stdout,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stripNewline"])(stderr, options, 'all')
        ];
    }
    if (Array.isArray(stderr)) {
        return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stripNewline"])(stdout, options, 'all'),
            ...stderr
        ];
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUint8Array"])(stdout) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUint8Array"])(stderr)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concatUint8Arrays"])([
            stdout,
            stderr
        ]);
    }
    return `${stdout}${stderr}`;
};
}),
"[project]/node_modules/execa/lib/resolve/exit-async.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isFailedExit",
    ()=>isFailedExit,
    "waitForExit",
    ()=>waitForExit,
    "waitForSuccessfulExit",
    ()=>waitForSuccessfulExit
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/final-error.js [app-ssr] (ecmascript)");
;
;
const waitForExit = async (subprocess, context)=>{
    const [exitCode, signal] = await waitForExitOrError(subprocess);
    context.isForcefullyTerminated ??= false;
    return [
        exitCode,
        signal
    ];
};
const waitForExitOrError = async (subprocess)=>{
    const [spawnPayload, exitPayload] = await Promise.allSettled([
        (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(subprocess, 'spawn'),
        (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(subprocess, 'exit')
    ]);
    if (spawnPayload.status === 'rejected') {
        return [];
    }
    return exitPayload.status === 'rejected' ? waitForSubprocessExit(subprocess) : exitPayload.value;
};
const waitForSubprocessExit = async (subprocess)=>{
    try {
        return await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(subprocess, 'exit');
    } catch  {
        return waitForSubprocessExit(subprocess);
    }
};
const waitForSuccessfulExit = async (exitPromise)=>{
    const [exitCode, signal] = await exitPromise;
    if (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DiscardedError"]();
    }
    return [
        exitCode,
        signal
    ];
};
// When the subprocess fails due to an `error` event
const isSubprocessErrorExit = (exitCode, signal)=>exitCode === undefined && signal === undefined;
const isFailedExit = (exitCode, signal)=>exitCode !== 0 || signal !== null;
}),
"[project]/node_modules/execa/lib/resolve/exit-sync.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getExitResultSync",
    ()=>getExitResultSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/final-error.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/max-buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/exit-async.js [app-ssr] (ecmascript)");
;
;
;
const getExitResultSync = ({ error, status: exitCode, signal, output }, { maxBuffer })=>{
    const resultError = getResultError(error, exitCode, signal);
    const timedOut = resultError?.code === 'ETIMEDOUT';
    const isMaxBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isMaxBufferSync"])(resultError, output, maxBuffer);
    return {
        resultError,
        exitCode,
        signal,
        timedOut,
        isMaxBuffer
    };
};
const getResultError = (error, exitCode, signal)=>{
    if (error !== undefined) {
        return error;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFailedExit"])(exitCode, signal) ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DiscardedError"]() : undefined;
};
}),
"[project]/node_modules/execa/lib/methods/main-sync.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "execaCoreSync",
    ()=>execaCoreSync
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:child_process [external] (node:child_process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$command$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/command.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/options.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$shell$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/shell.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/result.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$reject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/reject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$handle$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/handle-sync.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/strip-newline.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$input$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/input-sync.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$output$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/output-sync.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/max-buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$all$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/all-sync.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/exit-sync.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
const execaCoreSync = (rawFile, rawArguments, rawOptions)=>{
    const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleSyncArguments(rawFile, rawArguments, rawOptions);
    const result = spawnSubprocessSync({
        file,
        commandArguments,
        options,
        command,
        escapedCommand,
        verboseInfo,
        fileDescriptors,
        startTime
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$reject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleResult"])(result, verboseInfo, options);
};
// Compute arguments to pass to `child_process.spawnSync()`
const handleSyncArguments = (rawFile, rawArguments, rawOptions)=>{
    const { command, escapedCommand, startTime, verboseInfo } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$command$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleCommand"])(rawFile, rawArguments, rawOptions);
    const syncOptions = normalizeSyncOptions(rawOptions);
    const { file, commandArguments, options } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeOptions"])(rawFile, rawArguments, syncOptions);
    validateSyncOptions(options);
    const fileDescriptors = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$handle$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleStdioSync"])(options, verboseInfo);
    return {
        file,
        commandArguments,
        command,
        escapedCommand,
        startTime,
        verboseInfo,
        options,
        fileDescriptors
    };
};
// Options normalization logic specific to sync methods
const normalizeSyncOptions = (options)=>options.node && !options.ipc ? {
        ...options,
        ipc: false
    } : options;
// Options validation logic specific to sync methods
const validateSyncOptions = ({ ipc, ipcInput, detached, cancelSignal })=>{
    if (ipcInput) {
        throwInvalidSyncOption('ipcInput');
    }
    if (ipc) {
        throwInvalidSyncOption('ipc: true');
    }
    if (detached) {
        throwInvalidSyncOption('detached: true');
    }
    if (cancelSignal) {
        throwInvalidSyncOption('cancelSignal');
    }
};
const throwInvalidSyncOption = (value)=>{
    throw new TypeError(`The "${value}" option cannot be used with synchronous methods.`);
};
const spawnSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime })=>{
    const syncResult = runSubprocessSync({
        file,
        commandArguments,
        options,
        command,
        escapedCommand,
        fileDescriptors,
        startTime
    });
    if (syncResult.failed) {
        return syncResult;
    }
    const { resultError, exitCode, signal, timedOut, isMaxBuffer } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getExitResultSync"])(syncResult, options);
    const { output, error = resultError } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$output$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformOutputSync"])({
        fileDescriptors,
        syncResult,
        options,
        isMaxBuffer,
        verboseInfo
    });
    const stdio = output.map((stdioOutput, fdNumber)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stripNewline"])(stdioOutput, options, fdNumber));
    const all = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stripNewline"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$all$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAllSync"])(output, options), options, 'all');
    return getSyncResult({
        error,
        exitCode,
        signal,
        timedOut,
        isMaxBuffer,
        stdio,
        all,
        options,
        command,
        escapedCommand,
        startTime
    });
};
const runSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime })=>{
    try {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$input$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addInputOptionsSync"])(fileDescriptors, options);
        const normalizedOptions = normalizeSpawnSyncOptions(options);
        return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["spawnSync"])(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$shell$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concatenateShell"])(file, commandArguments, normalizedOptions));
    } catch (error) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeEarlyError"])({
            error,
            command,
            escapedCommand,
            fileDescriptors,
            options,
            startTime,
            isSync: true
        });
    }
};
// The `encoding` option is handled by Execa, not by `child_process.spawnSync()`
const normalizeSpawnSyncOptions = ({ encoding, maxBuffer, ...options })=>({
        ...options,
        encoding: 'buffer',
        maxBuffer: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getMaxBufferSync"])(maxBuffer)
    });
const getSyncResult = ({ error, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command, escapedCommand, startTime })=>error === undefined ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeSuccessResult"])({
        command,
        escapedCommand,
        stdio,
        all,
        ipcOutput: [],
        options,
        startTime
    }) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeError"])({
        error,
        command,
        escapedCommand,
        timedOut,
        isCanceled: false,
        isGracefullyCanceled: false,
        isMaxBuffer,
        isForcefullyTerminated: false,
        exitCode,
        signal,
        stdio,
        all,
        ipcOutput: [],
        options,
        startTime,
        isSync: true
    });
}),
"[project]/node_modules/execa/lib/ipc/get-one.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getOneMessage",
    ()=>getOneMessage
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/validation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/forward.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/reference.js [app-ssr] (ecmascript)");
;
;
;
;
const getOneMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference = true, filter } = {})=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIpcMethod"])({
        methodName: 'getOneMessage',
        isSubprocess,
        ipc,
        isConnected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isConnected"])(anyProcess)
    });
    return getOneMessageAsync({
        anyProcess,
        channel,
        isSubprocess,
        filter,
        reference
    });
};
const getOneMessageAsync = async ({ anyProcess, channel, isSubprocess, filter, reference })=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addReference"])(channel, reference);
    const ipcEmitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getIpcEmitter"])(anyProcess, channel, isSubprocess);
    const controller = new AbortController();
    try {
        return await Promise.race([
            getMessage(ipcEmitter, filter, controller),
            throwOnDisconnect(ipcEmitter, isSubprocess, controller),
            throwOnStrictError(ipcEmitter, isSubprocess, controller)
        ]);
    } catch (error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["disconnect"])(anyProcess);
        throw error;
    } finally{
        controller.abort();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["removeReference"])(channel, reference);
    }
};
const getMessage = async (ipcEmitter, filter, { signal })=>{
    if (filter === undefined) {
        const [message] = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(ipcEmitter, 'message', {
            signal
        });
        return message;
    }
    for await (const [message] of (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["on"])(ipcEmitter, 'message', {
        signal
    })){
        if (filter(message)) {
            return message;
        }
    }
};
const throwOnDisconnect = async (ipcEmitter, isSubprocess, { signal })=>{
    await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(ipcEmitter, 'disconnect', {
        signal
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["throwOnEarlyDisconnect"])(isSubprocess);
};
const throwOnStrictError = async (ipcEmitter, isSubprocess, { signal })=>{
    const [error] = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(ipcEmitter, 'strict:error', {
        signal
    });
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStrictResponseError"])(error, isSubprocess);
};
}),
"[project]/node_modules/execa/lib/ipc/get-each.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getEachMessage",
    ()=>getEachMessage,
    "loopOnMessages",
    ()=>loopOnMessages
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/validation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/forward.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/reference.js [app-ssr] (ecmascript)");
;
;
;
;
const getEachMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference = true } = {})=>loopOnMessages({
        anyProcess,
        channel,
        isSubprocess,
        ipc,
        shouldAwait: !isSubprocess,
        reference
    });
const loopOnMessages = ({ anyProcess, channel, isSubprocess, ipc, shouldAwait, reference })=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateIpcMethod"])({
        methodName: 'getEachMessage',
        isSubprocess,
        ipc,
        isConnected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isConnected"])(anyProcess)
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addReference"])(channel, reference);
    const ipcEmitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getIpcEmitter"])(anyProcess, channel, isSubprocess);
    const controller = new AbortController();
    const state = {};
    stopOnDisconnect(anyProcess, ipcEmitter, controller);
    abortOnStrictError({
        ipcEmitter,
        isSubprocess,
        controller,
        state
    });
    return iterateOnMessages({
        anyProcess,
        channel,
        ipcEmitter,
        isSubprocess,
        shouldAwait,
        controller,
        state,
        reference
    });
};
const stopOnDisconnect = async (anyProcess, ipcEmitter, controller)=>{
    try {
        await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(ipcEmitter, 'disconnect', {
            signal: controller.signal
        });
        controller.abort();
    } catch  {}
};
const abortOnStrictError = async ({ ipcEmitter, isSubprocess, controller, state })=>{
    try {
        const [error] = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(ipcEmitter, 'strict:error', {
            signal: controller.signal
        });
        state.error = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStrictResponseError"])(error, isSubprocess);
        controller.abort();
    } catch  {}
};
const iterateOnMessages = async function*({ anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference }) {
    try {
        for await (const [message] of (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["on"])(ipcEmitter, 'message', {
            signal: controller.signal
        })){
            throwIfStrictError(state);
            yield message;
        }
    } catch  {
        throwIfStrictError(state);
    } finally{
        controller.abort();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["removeReference"])(channel, reference);
        if (!isSubprocess) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["disconnect"])(anyProcess);
        }
        if (shouldAwait) {
            await anyProcess;
        }
    }
};
const throwIfStrictError = ({ error })=>{
    if (error) {
        throw error;
    }
};
}),
"[project]/node_modules/execa/lib/ipc/methods.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addIpcMethods",
    ()=>addIpcMethods,
    "getIpcExport",
    ()=>getIpcExport
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:process [external] (node:process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$send$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/send.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$one$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/get-one.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$each$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/get-each.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/graceful.js [app-ssr] (ecmascript)");
;
;
;
;
;
const addIpcMethods = (subprocess, { ipc })=>{
    Object.assign(subprocess, getIpcMethods(subprocess, false, ipc));
};
const getIpcExport = ()=>{
    const anyProcess = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"];
    const isSubprocess = true;
    const ipc = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$process__$5b$external$5d$__$28$node$3a$process$2c$__cjs$29$__["default"].channel !== undefined;
    return {
        ...getIpcMethods(anyProcess, isSubprocess, ipc),
        getCancelSignal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCancelSignal"].bind(undefined, {
            anyProcess,
            channel: anyProcess.channel,
            isSubprocess,
            ipc
        })
    };
};
// Retrieve the `ipc` shared by both the current process and the subprocess
const getIpcMethods = (anyProcess, isSubprocess, ipc)=>({
        sendMessage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$send$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sendMessage"].bind(undefined, {
            anyProcess,
            channel: anyProcess.channel,
            isSubprocess,
            ipc
        }),
        getOneMessage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$one$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOneMessage"].bind(undefined, {
            anyProcess,
            channel: anyProcess.channel,
            isSubprocess,
            ipc
        }),
        getEachMessage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$each$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getEachMessage"].bind(undefined, {
            anyProcess,
            channel: anyProcess.channel,
            isSubprocess,
            ipc
        })
    });
}),
"[project]/node_modules/execa/lib/return/early-error.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleEarlyError",
    ()=>handleEarlyError
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:child_process [external] (node:child_process, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$handle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/handle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/result.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$reject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/reject.js [app-ssr] (ecmascript)");
;
;
;
;
;
const handleEarlyError = ({ error, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo })=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$handle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cleanupCustomStreams"])(fileDescriptors);
    const subprocess = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["ChildProcess"]();
    createDummyStreams(subprocess, fileDescriptors);
    Object.assign(subprocess, {
        readable,
        writable,
        duplex
    });
    const earlyError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeEarlyError"])({
        error,
        command,
        escapedCommand,
        fileDescriptors,
        options,
        startTime,
        isSync: false
    });
    const promise = handleDummyPromise(earlyError, verboseInfo, options);
    return {
        subprocess,
        promise
    };
};
const createDummyStreams = (subprocess, fileDescriptors)=>{
    const stdin = createDummyStream();
    const stdout = createDummyStream();
    const stderr = createDummyStream();
    const extraStdio = Array.from({
        length: fileDescriptors.length - 3
    }, createDummyStream);
    const all = createDummyStream();
    const stdio = [
        stdin,
        stdout,
        stderr,
        ...extraStdio
    ];
    Object.assign(subprocess, {
        stdin,
        stdout,
        stderr,
        all,
        stdio
    });
};
const createDummyStream = ()=>{
    const stream = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["PassThrough"]();
    stream.end();
    return stream;
};
const readable = ()=>new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Readable"]({
        read () {}
    });
const writable = ()=>new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Writable"]({
        write () {}
    });
const duplex = ()=>new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Duplex"]({
        read () {},
        write () {}
    });
const handleDummyPromise = async (error, verboseInfo, options)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$reject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleResult"])(error, verboseInfo, options);
}),
"[project]/node_modules/execa/lib/stdio/handle-async.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleStdioAsync",
    ()=>handleStdioAsync
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:buffer [external] (node:buffer, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$generator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/generator.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$handle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/handle.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
const handleStdioAsync = (options, verboseInfo)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$handle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleStdio"])(addPropertiesAsync, options, verboseInfo, false);
const forbiddenIfAsync = ({ type, optionName })=>{
    throw new TypeError(`The \`${optionName}\` option cannot be ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TYPE_TO_MESSAGE"][type]}.`);
};
// Create streams used internally for piping when using specific values for the `std*` options, in async mode.
// For example, `stdout: {file}` creates a file stream, which is piped from/to.
const addProperties = {
    fileNumber: forbiddenIfAsync,
    generator: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$generator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generatorToStream"],
    asyncGenerator: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$generator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generatorToStream"],
    nodeStream: ({ value })=>({
            stream: value
        }),
    webTransform ({ value: { transform, writableObjectMode, readableObjectMode } }) {
        const objectMode = writableObjectMode || readableObjectMode;
        const stream = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Duplex"].fromWeb(transform, {
            objectMode
        });
        return {
            stream
        };
    },
    duplex: ({ value: { transform } })=>({
            stream: transform
        }),
    native () {}
};
const addPropertiesAsync = {
    input: {
        ...addProperties,
        fileUrl: ({ value })=>({
                stream: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["createReadStream"])(value)
            }),
        filePath: ({ value: { file } })=>({
                stream: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["createReadStream"])(file)
            }),
        webStream: ({ value })=>({
                stream: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Readable"].fromWeb(value)
            }),
        iterable: ({ value })=>({
                stream: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Readable"].from(value)
            }),
        asyncIterable: ({ value })=>({
                stream: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Readable"].from(value)
            }),
        string: ({ value })=>({
                stream: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Readable"].from(value)
            }),
        uint8Array: ({ value })=>({
                stream: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Readable"].from(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].from(value))
            })
    },
    output: {
        ...addProperties,
        fileUrl: ({ value })=>({
                stream: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["createWriteStream"])(value)
            }),
        filePath: ({ value: { file, append } })=>({
                stream: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["createWriteStream"])(file, append ? {
                    flags: 'a'
                } : {})
            }),
        webStream: ({ value })=>({
                stream: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Writable"].fromWeb(value)
            }),
        iterable: forbiddenIfAsync,
        asyncIterable: forbiddenIfAsync,
        string: forbiddenIfAsync,
        uint8Array: forbiddenIfAsync
    }
};
}),
"[project]/node_modules/execa/lib/io/pipeline.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "abortSourceStream",
    ()=>abortSourceStream,
    "endDestinationStream",
    ()=>endDestinationStream,
    "pipeStreams",
    ()=>pipeStreams
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$promises__$5b$external$5d$__$28$node$3a$stream$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream/promises [external] (node:stream/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-ssr] (ecmascript)");
;
;
const pipeStreams = (source, destination)=>{
    source.pipe(destination);
    onSourceFinish(source, destination);
    onDestinationFinish(source, destination);
};
// `source.pipe(destination)` makes `destination` end when `source` ends.
// But it does not propagate aborts or errors. This function does it.
const onSourceFinish = async (source, destination)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStandardStream"])(source) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStandardStream"])(destination)) {
        return;
    }
    try {
        await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$promises__$5b$external$5d$__$28$node$3a$stream$2f$promises$2c$__cjs$29$__["finished"])(source, {
            cleanup: true,
            readable: true,
            writable: false
        });
    } catch  {}
    endDestinationStream(destination);
};
const endDestinationStream = (destination)=>{
    if (destination.writable) {
        destination.end();
    }
};
// We do the same thing in the other direction as well.
const onDestinationFinish = async (source, destination)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStandardStream"])(source) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStandardStream"])(destination)) {
        return;
    }
    try {
        await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$promises__$5b$external$5d$__$28$node$3a$stream$2f$promises$2c$__cjs$29$__["finished"])(destination, {
            cleanup: true,
            readable: false,
            writable: true
        });
    } catch  {}
    abortSourceStream(source);
};
const abortSourceStream = (source)=>{
    if (source.readable) {
        source.destroy();
    }
};
}),
"[project]/node_modules/execa/lib/io/output-async.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "pipeOutputAsync",
    ()=>pipeOutputAsync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$merge$2d$streams$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/merge-streams/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/max-listeners.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/pipeline.js [app-ssr] (ecmascript)");
;
;
;
;
;
const pipeOutputAsync = (subprocess, fileDescriptors, controller)=>{
    const pipeGroups = new Map();
    for (const [fdNumber, { stdioItems, direction }] of Object.entries(fileDescriptors)){
        for (const { stream } of stdioItems.filter(({ type })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type))){
            pipeTransform(subprocess, stream, direction, fdNumber);
        }
        for (const { stream } of stdioItems.filter(({ type })=>!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type))){
            pipeStdioItem({
                subprocess,
                stream,
                direction,
                fdNumber,
                pipeGroups,
                controller
            });
        }
    }
    for (const [outputStream, inputStreams] of pipeGroups.entries()){
        const inputStream = inputStreams.length === 1 ? inputStreams[0] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$merge$2d$streams$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(inputStreams);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipeStreams"])(inputStream, outputStream);
    }
};
// When using transforms, `subprocess.stdin|stdout|stderr|stdio` is directly mutated
const pipeTransform = (subprocess, stream, direction, fdNumber)=>{
    if (direction === 'output') {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipeStreams"])(subprocess.stdio[fdNumber], stream);
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipeStreams"])(stream, subprocess.stdio[fdNumber]);
    }
    const streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];
    if (streamProperty !== undefined) {
        subprocess[streamProperty] = stream;
    }
    subprocess.stdio[fdNumber] = stream;
};
const SUBPROCESS_STREAM_PROPERTIES = [
    'stdin',
    'stdout',
    'stderr'
];
// Most `std*` option values involve piping `subprocess.std*` to a stream.
// The stream is either passed by the user or created internally.
const pipeStdioItem = ({ subprocess, stream, direction, fdNumber, pipeGroups, controller })=>{
    if (stream === undefined) {
        return;
    }
    setStandardStreamMaxListeners(stream, controller);
    const [inputStream, outputStream] = direction === 'output' ? [
        stream,
        subprocess.stdio[fdNumber]
    ] : [
        subprocess.stdio[fdNumber],
        stream
    ];
    const outputStreams = pipeGroups.get(inputStream) ?? [];
    pipeGroups.set(inputStream, [
        ...outputStreams,
        outputStream
    ]);
};
// Multiple subprocesses might be piping from/to `process.std*` at the same time.
// This is not necessarily an error and should not print a `maxListeners` warning.
const setStandardStreamMaxListeners = (stream, { signal })=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStandardStream"])(stream)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["incrementMaxListeners"])(stream, MAX_LISTENERS_INCREMENT, signal);
    }
};
// `source.pipe(destination)` adds at most 1 listener for each event.
// If `stdin` option is an array, the values might be combined with `merge-streams`.
// That library also listens for `source` end, which adds 1 more listener.
const MAX_LISTENERS_INCREMENT = 2;
}),
"[project]/node_modules/execa/lib/terminate/cleanup.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cleanupOnExit",
    ()=>cleanupOnExit
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$signal$2d$exit$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/signal-exit/dist/mjs/index.js [app-ssr] (ecmascript) <locals>");
;
;
const cleanupOnExit = (subprocess, { cleanup, detached }, { signal })=>{
    if (!cleanup || detached) {
        return;
    }
    const removeExitHandler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$signal$2d$exit$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["onExit"])(()=>{
        subprocess.kill();
    });
    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["addAbortListener"])(signal, ()=>{
        removeExitHandler();
    });
};
}),
"[project]/node_modules/execa/lib/pipe/pipe-arguments.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizePipeArguments",
    ()=>normalizePipeArguments
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$parameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/parameters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/duration.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/file-url.js [app-ssr] (ecmascript)");
;
;
;
;
const normalizePipeArguments = ({ source, sourcePromise, boundOptions, createNested }, ...pipeArguments)=>{
    const startTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStartTime"])();
    const { destination, destinationStream, destinationError, from, unpipeSignal } = getDestinationStream(boundOptions, createNested, pipeArguments);
    const { sourceStream, sourceError } = getSourceStream(source, from);
    const { options: sourceOptions, fileDescriptors } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SUBPROCESS_OPTIONS"].get(source);
    return {
        sourcePromise,
        sourceStream,
        sourceOptions,
        sourceError,
        destination,
        destinationStream,
        destinationError,
        unpipeSignal,
        fileDescriptors,
        startTime
    };
};
const getDestinationStream = (boundOptions, createNested, pipeArguments)=>{
    try {
        const { destination, pipeOptions: { from, to, unpipeSignal } = {} } = getDestination(boundOptions, createNested, ...pipeArguments);
        const destinationStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getToStream"])(destination, to);
        return {
            destination,
            destinationStream,
            from,
            unpipeSignal
        };
    } catch (error) {
        return {
            destinationError: error
        };
    }
};
// Piping subprocesses can use three syntaxes:
//  - source.pipe('command', commandArguments, pipeOptionsOrDestinationOptions)
//  - source.pipe`command commandArgument` or source.pipe(pipeOptionsOrDestinationOptions)`command commandArgument`
//  - source.pipe(execa(...), pipeOptions)
const getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments)=>{
    if (Array.isArray(firstArgument)) {
        const destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);
        return {
            destination,
            pipeOptions: boundOptions
        };
    }
    if (typeof firstArgument === 'string' || firstArgument instanceof URL || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isDenoExecPath"])(firstArgument)) {
        if (Object.keys(boundOptions).length > 0) {
            throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');
        }
        const [rawFile, rawArguments, rawOptions] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$parameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeParameters"])(firstArgument, ...pipeArguments);
        const destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);
        return {
            destination,
            pipeOptions: rawOptions
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SUBPROCESS_OPTIONS"].has(firstArgument)) {
        if (Object.keys(boundOptions).length > 0) {
            throw new TypeError('Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).');
        }
        return {
            destination: firstArgument,
            pipeOptions: pipeArguments[0]
        };
    }
    throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);
};
// Force `stdin: 'pipe'` with the destination subprocess
const mapDestinationArguments = ({ options })=>({
        options: {
            ...options,
            stdin: 'pipe',
            piped: true
        }
    });
const getSourceStream = (source, from)=>{
    try {
        const sourceStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFromStream"])(source, from);
        return {
            sourceStream
        };
    } catch (error) {
        return {
            sourceError: error
        };
    }
};
}),
"[project]/node_modules/execa/lib/pipe/throw.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createNonCommandError",
    ()=>createNonCommandError,
    "handlePipeArgumentsError",
    ()=>handlePipeArgumentsError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/result.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/pipeline.js [app-ssr] (ecmascript)");
;
;
const handlePipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError, fileDescriptors, sourceOptions, startTime })=>{
    const error = getPipeArgumentsError({
        sourceStream,
        sourceError,
        destinationStream,
        destinationError
    });
    if (error !== undefined) {
        throw createNonCommandError({
            error,
            fileDescriptors,
            sourceOptions,
            startTime
        });
    }
};
const getPipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError })=>{
    if (sourceError !== undefined && destinationError !== undefined) {
        return destinationError;
    }
    if (destinationError !== undefined) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abortSourceStream"])(sourceStream);
        return destinationError;
    }
    if (sourceError !== undefined) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["endDestinationStream"])(destinationStream);
        return sourceError;
    }
};
const createNonCommandError = ({ error, fileDescriptors, sourceOptions, startTime })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeEarlyError"])({
        error,
        command: PIPE_COMMAND_MESSAGE,
        escapedCommand: PIPE_COMMAND_MESSAGE,
        fileDescriptors,
        options: sourceOptions,
        startTime,
        isSync: false
    });
const PIPE_COMMAND_MESSAGE = 'source.pipe(destination)';
}),
"[project]/node_modules/execa/lib/pipe/sequence.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Like Bash, we await both subprocesses. This is unlike some other shells which only await the destination subprocess.
// Like Bash with the `pipefail` option, if either subprocess fails, the whole pipe fails.
// Like Bash, if both subprocesses fail, we return the failure of the destination.
// This ensures both subprocesses' errors are present, using `error.pipedFrom`.
__turbopack_context__.s([
    "waitForBothSubprocesses",
    ()=>waitForBothSubprocesses
]);
const waitForBothSubprocesses = async (subprocessPromises)=>{
    const [{ status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason }, { status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason }] = await subprocessPromises;
    if (!destinationResult.pipedFrom.includes(sourceResult)) {
        destinationResult.pipedFrom.push(sourceResult);
    }
    if (destinationStatus === 'rejected') {
        throw destinationResult;
    }
    if (sourceStatus === 'rejected') {
        throw sourceResult;
    }
    return destinationResult;
};
}),
"[project]/node_modules/execa/lib/pipe/streaming.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "pipeSubprocessStream",
    ()=>pipeSubprocessStream
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$promises__$5b$external$5d$__$28$node$3a$stream$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream/promises [external] (node:stream/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$merge$2d$streams$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/merge-streams/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/max-listeners.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/pipeline.js [app-ssr] (ecmascript)");
;
;
;
;
const pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController)=>{
    const mergedStream = MERGED_STREAMS.has(destinationStream) ? pipeMoreSubprocessStream(sourceStream, destinationStream) : pipeFirstSubprocessStream(sourceStream, destinationStream);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["incrementMaxListeners"])(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["incrementMaxListeners"])(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);
    cleanupMergedStreamsMap(destinationStream);
    return mergedStream;
};
// We use `merge-streams` to allow for multiple sources to pipe to the same destination.
const pipeFirstSubprocessStream = (sourceStream, destinationStream)=>{
    const mergedStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$merge$2d$streams$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])([
        sourceStream
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipeStreams"])(mergedStream, destinationStream);
    MERGED_STREAMS.set(destinationStream, mergedStream);
    return mergedStream;
};
const pipeMoreSubprocessStream = (sourceStream, destinationStream)=>{
    const mergedStream = MERGED_STREAMS.get(destinationStream);
    mergedStream.add(sourceStream);
    return mergedStream;
};
const cleanupMergedStreamsMap = async (destinationStream)=>{
    try {
        await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$promises__$5b$external$5d$__$28$node$3a$stream$2f$promises$2c$__cjs$29$__["finished"])(destinationStream, {
            cleanup: true,
            readable: false,
            writable: true
        });
    } catch  {}
    MERGED_STREAMS.delete(destinationStream);
};
const MERGED_STREAMS = new WeakMap();
// Number of listeners set up on `sourceStream` by each `sourceStream.pipe(destinationStream)`
// Those are added by `merge-streams`
const SOURCE_LISTENERS_PER_PIPE = 2;
// Number of listeners set up on `destinationStream` by each `sourceStream.pipe(destinationStream)`
// Those are added by `finished()` in `cleanupMergedStreamsMap()`
const DESTINATION_LISTENERS_PER_PIPE = 1;
}),
"[project]/node_modules/execa/lib/pipe/abort.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unpipeOnAbort",
    ()=>unpipeOnAbort
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$throw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/throw.js [app-ssr] (ecmascript)");
;
;
const unpipeOnAbort = (unpipeSignal, unpipeContext)=>unpipeSignal === undefined ? [] : [
        unpipeOnSignalAbort(unpipeSignal, unpipeContext)
    ];
const unpipeOnSignalAbort = async (unpipeSignal, { sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime })=>{
    await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["aborted"])(unpipeSignal, sourceStream);
    await mergedStream.remove(sourceStream);
    const error = new Error('Pipe canceled by `unpipeSignal` option.');
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$throw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNonCommandError"])({
        error,
        fileDescriptors,
        sourceOptions,
        startTime
    });
};
}),
"[project]/node_modules/execa/lib/pipe/setup.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "pipeToSubprocess",
    ()=>pipeToSubprocess
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$pipe$2d$arguments$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/pipe-arguments.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$throw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/throw.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$sequence$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/sequence.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$streaming$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/streaming.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$abort$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/abort.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
const pipeToSubprocess = (sourceInfo, ...pipeArguments)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(pipeArguments[0])) {
        return pipeToSubprocess.bind(undefined, {
            ...sourceInfo,
            boundOptions: {
                ...sourceInfo.boundOptions,
                ...pipeArguments[0]
            }
        });
    }
    const { destination, ...normalizedInfo } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$pipe$2d$arguments$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizePipeArguments"])(sourceInfo, ...pipeArguments);
    const promise = handlePipePromise({
        ...normalizedInfo,
        destination
    });
    promise.pipe = pipeToSubprocess.bind(undefined, {
        ...sourceInfo,
        source: destination,
        sourcePromise: promise,
        boundOptions: {}
    });
    return promise;
};
// Asynchronous logic when piping subprocesses
const handlePipePromise = async ({ sourcePromise, sourceStream, sourceOptions, sourceError, destination, destinationStream, destinationError, unpipeSignal, fileDescriptors, startTime })=>{
    const subprocessPromises = getSubprocessPromises(sourcePromise, destination);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$throw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handlePipeArgumentsError"])({
        sourceStream,
        sourceError,
        destinationStream,
        destinationError,
        fileDescriptors,
        sourceOptions,
        startTime
    });
    const maxListenersController = new AbortController();
    try {
        const mergedStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$streaming$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipeSubprocessStream"])(sourceStream, destinationStream, maxListenersController);
        return await Promise.race([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$sequence$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForBothSubprocesses"])(subprocessPromises),
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$abort$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unpipeOnAbort"])(unpipeSignal, {
                sourceStream,
                mergedStream,
                sourceOptions,
                fileDescriptors,
                startTime
            })
        ]);
    } finally{
        maxListenersController.abort();
    }
};
// `.pipe()` awaits the subprocess promises.
// When invalid arguments are passed to `.pipe()`, we throw an error, which prevents awaiting them.
// We need to ensure this does not create unhandled rejections.
const getSubprocessPromises = (sourcePromise, destination)=>Promise.allSettled([
        sourcePromise,
        destination
    ]);
}),
"[project]/node_modules/execa/lib/io/iterate.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_OBJECT_HIGH_WATER_MARK",
    ()=>DEFAULT_OBJECT_HIGH_WATER_MARK,
    "iterateForResult",
    ()=>iterateForResult,
    "iterateOnSubprocessStream",
    ()=>iterateOnSubprocessStream
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$encoding$2d$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/encoding-transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/split.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/run-sync.js [app-ssr] (ecmascript)");
;
;
;
;
;
const iterateOnSubprocessStream = ({ subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines })=>{
    const controller = new AbortController();
    stopReadingOnExit(subprocess, controller);
    return iterateOnStream({
        stream: subprocessStdout,
        controller,
        binary,
        shouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,
        encoding,
        shouldSplit: !subprocessStdout.readableObjectMode,
        preserveNewlines
    });
};
const stopReadingOnExit = async (subprocess, controller)=>{
    try {
        await subprocess;
    } catch  {} finally{
        controller.abort();
    }
};
const iterateForResult = ({ stream, onStreamEnd, lines, encoding, stripFinalNewline, allMixed })=>{
    const controller = new AbortController();
    stopReadingOnStreamEnd(onStreamEnd, controller, stream);
    const objectMode = stream.readableObjectMode && !allMixed;
    return iterateOnStream({
        stream,
        controller,
        binary: encoding === 'buffer',
        shouldEncode: !objectMode,
        encoding,
        shouldSplit: !objectMode && lines,
        preserveNewlines: !stripFinalNewline
    });
};
const stopReadingOnStreamEnd = async (onStreamEnd, controller, stream)=>{
    try {
        await onStreamEnd;
    } catch  {
        stream.destroy();
    } finally{
        controller.abort();
    }
};
const iterateOnStream = ({ stream, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines })=>{
    const onStdoutChunk = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["on"])(stream, 'data', {
        signal: controller.signal,
        highWaterMark: HIGH_WATER_MARK,
        // Backward compatibility with older name for this option
        // See https://github.com/nodejs/node/pull/52080#discussion_r1525227861
        // @todo Remove after removing support for Node 21
        highWatermark: HIGH_WATER_MARK
    });
    return iterateOnData({
        onStdoutChunk,
        controller,
        binary,
        shouldEncode,
        encoding,
        shouldSplit,
        preserveNewlines
    });
};
const DEFAULT_OBJECT_HIGH_WATER_MARK = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["getDefaultHighWaterMark"])(true);
// The `highWaterMark` of `events.on()` is measured in number of events, not in bytes.
// Not knowing the average amount of bytes per `data` event, we use the same heuristic as streams in objectMode, since they have the same issue.
// Therefore, we use the value of `getDefaultHighWaterMark(true)`.
// Note: this option does not exist on Node 18, but this is ok since the logic works without it. It just consumes more memory.
const HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;
const iterateOnData = async function*({ onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) {
    const generators = getGenerators({
        binary,
        shouldEncode,
        encoding,
        shouldSplit,
        preserveNewlines
    });
    try {
        for await (const [chunk] of onStdoutChunk){
            yield* (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformChunkSync"])(chunk, generators, 0);
        }
    } catch (error) {
        if (!controller.signal.aborted) {
            throw error;
        }
    } finally{
        yield* (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["finalChunksSync"])(generators);
    }
};
const getGenerators = ({ binary, shouldEncode, encoding, shouldSplit, preserveNewlines })=>[
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$encoding$2d$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getEncodingTransformGenerator"])(binary, encoding, !shouldEncode),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSplitLinesGenerator"])(binary, preserveNewlines, !shouldSplit, {})
    ].filter(Boolean);
}),
"[project]/node_modules/execa/lib/io/contents.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getBufferedData",
    ()=>getBufferedData,
    "getStreamOutput",
    ()=>getStreamOutput
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:timers/promises [external] (node:timers/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__getStreamAsString__as__default$3e$__ = __turbopack_context__.i("[project]/node_modules/get-stream/source/string.js [app-ssr] (ecmascript) <export getStreamAsString as default>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$array$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-stream/source/array-buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-stream/source/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$output$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/output.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/iterate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/max-buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/strip-newline.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const getStreamOutput = async ({ stream, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo })=>{
    const logPromise = logOutputAsync({
        stream,
        onStreamEnd,
        fdNumber,
        encoding,
        allMixed,
        verboseInfo,
        streamInfo
    });
    if (!buffer) {
        await Promise.all([
            resumeStream(stream),
            logPromise
        ]);
        return;
    }
    const stripFinalNewlineValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStripFinalNewline"])(stripFinalNewline, fdNumber);
    const iterable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["iterateForResult"])({
        stream,
        onStreamEnd,
        lines,
        encoding,
        stripFinalNewline: stripFinalNewlineValue,
        allMixed
    });
    const [output] = await Promise.all([
        getStreamContents({
            stream,
            iterable,
            fdNumber,
            encoding,
            maxBuffer,
            lines
        }),
        logPromise
    ]);
    return output;
};
const logOutputAsync = async ({ stream, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: { fileDescriptors } })=>{
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$output$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shouldLogOutput"])({
        stdioItems: fileDescriptors[fdNumber]?.stdioItems,
        encoding,
        verboseInfo,
        fdNumber
    })) {
        return;
    }
    const linesIterable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["iterateForResult"])({
        stream,
        onStreamEnd,
        lines: true,
        encoding,
        stripFinalNewline: true,
        allMixed
    });
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$output$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logLines"])(linesIterable, stream, fdNumber, verboseInfo);
};
// When using `buffer: false`, users need to read `subprocess.stdout|stderr|all` right away
// See https://github.com/sindresorhus/execa/issues/730 and https://github.com/sindresorhus/execa/pull/729#discussion_r1465496310
const resumeStream = async (stream)=>{
    await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$timers$2f$promises__$5b$external$5d$__$28$node$3a$timers$2f$promises$2c$__cjs$29$__["setImmediate"])();
    if (stream.readableFlowing === null) {
        stream.resume();
    }
};
const getStreamContents = async ({ stream, stream: { readableObjectMode }, iterable, fdNumber, encoding, maxBuffer, lines })=>{
    try {
        if (readableObjectMode || lines) {
            return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStreamAsArray"])(iterable, {
                maxBuffer
            });
        }
        if (encoding === 'buffer') {
            return new Uint8Array(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$array$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStreamAsArrayBuffer"])(iterable, {
                maxBuffer
            }));
        }
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__getStreamAsString__as__default$3e$__["default"])(iterable, {
            maxBuffer
        });
    } catch (error) {
        return handleBufferedData((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleMaxBuffer"])({
            error,
            stream,
            readableObjectMode,
            lines,
            encoding,
            fdNumber
        }));
    }
};
const getBufferedData = async (streamPromise)=>{
    try {
        return await streamPromise;
    } catch (error) {
        return handleBufferedData(error);
    }
};
// Ensure we are returning Uint8Arrays when using `encoding: 'buffer'`
const handleBufferedData = ({ bufferedData })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isArrayBuffer"])(bufferedData) ? new Uint8Array(bufferedData) : bufferedData;
}),
"[project]/node_modules/execa/lib/resolve/wait-stream.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isInputFileDescriptor",
    ()=>isInputFileDescriptor,
    "isStreamAbort",
    ()=>isStreamAbort,
    "waitForStream",
    ()=>waitForStream
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$promises__$5b$external$5d$__$28$node$3a$stream$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream/promises [external] (node:stream/promises, cjs)");
;
const waitForStream = async (stream, fdNumber, streamInfo, { isSameDirection, stopOnExit = false } = {})=>{
    const state = handleStdinDestroy(stream, streamInfo);
    const abortController = new AbortController();
    try {
        await Promise.race([
            ...stopOnExit ? [
                streamInfo.exitPromise
            ] : [],
            (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$promises__$5b$external$5d$__$28$node$3a$stream$2f$promises$2c$__cjs$29$__["finished"])(stream, {
                cleanup: true,
                signal: abortController.signal
            })
        ]);
    } catch (error) {
        if (!state.stdinCleanedUp) {
            handleStreamError(error, fdNumber, streamInfo, isSameDirection);
        }
    } finally{
        abortController.abort();
    }
};
// If `subprocess.stdin` is destroyed before being fully written to, it is considered aborted and should throw an error.
// This can happen for example when user called `subprocess.stdin.destroy()` before `subprocess.stdin.end()`.
// However, Node.js calls `subprocess.stdin.destroy()` on exit for cleanup purposes.
// https://github.com/nodejs/node/blob/0b4cdb4b42956cbd7019058e409e06700a199e11/lib/internal/child_process.js#L278
// This is normal and should not throw an error.
// Therefore, we need to differentiate between both situations to know whether to throw an error.
// Unfortunately, events (`close`, `error`, `end`, `exit`) cannot be used because `.destroy()` can take an arbitrary amount of time.
// For example, `stdin: 'pipe'` is implemented as a TCP socket, and its `.destroy()` method waits for TCP disconnection.
// Therefore `.destroy()` might end before or after subprocess exit, based on OS speed and load.
// The only way to detect this is to spy on `subprocess.stdin._destroy()` by wrapping it.
// If `subprocess.exitCode` or `subprocess.signalCode` is set, it means `.destroy()` is being called by Node.js itself.
const handleStdinDestroy = (stream, { originalStreams: [originalStdin], subprocess })=>{
    const state = {
        stdinCleanedUp: false
    };
    if (stream === originalStdin) {
        spyOnStdinDestroy(stream, subprocess, state);
    }
    return state;
};
const spyOnStdinDestroy = (subprocessStdin, subprocess, state)=>{
    const { _destroy } = subprocessStdin;
    subprocessStdin._destroy = (...destroyArguments)=>{
        setStdinCleanedUp(subprocess, state);
        _destroy.call(subprocessStdin, ...destroyArguments);
    };
};
const setStdinCleanedUp = ({ exitCode, signalCode }, state)=>{
    if (exitCode !== null || signalCode !== null) {
        state.stdinCleanedUp = true;
    }
};
// We ignore EPIPEs on writable streams and aborts on readable streams since those can happen normally.
// When one stream errors, the error is propagated to the other streams on the same file descriptor.
// Those other streams might have a different direction due to the above.
// When this happens, the direction of both the initial stream and the others should then be taken into account.
// Therefore, we keep track of whether a stream error is currently propagating.
const handleStreamError = (error, fdNumber, streamInfo, isSameDirection)=>{
    if (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) {
        throw error;
    }
};
const shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true)=>{
    if (streamInfo.propagating) {
        return isStreamEpipe(error) || isStreamAbort(error);
    }
    streamInfo.propagating = true;
    return isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection ? isStreamEpipe(error) : isStreamAbort(error);
};
const isInputFileDescriptor = ({ fileDescriptors }, fdNumber)=>fdNumber !== 'all' && fileDescriptors[fdNumber].direction === 'input';
const isStreamAbort = (error)=>error?.code === 'ERR_STREAM_PREMATURE_CLOSE';
// When `stream.write()` is called but the underlying source has been closed, `EPIPE` is emitted.
// When piping subprocesses, the source subprocess usually decides when to stop piping.
// However, there are some instances when the destination does instead, such as `... | head -n1`.
// It notifies the source by using `EPIPE`.
// Therefore, we ignore this error on writable streams.
const isStreamEpipe = (error)=>error?.code === 'EPIPE';
}),
"[project]/node_modules/execa/lib/resolve/stdio.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "waitForStdioStreams",
    ()=>waitForStdioStreams,
    "waitForSubprocessStream",
    ()=>waitForSubprocessStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$contents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/contents.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/wait-stream.js [app-ssr] (ecmascript)");
;
;
const waitForStdioStreams = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo })=>subprocess.stdio.map((stream, fdNumber)=>waitForSubprocessStream({
            stream,
            fdNumber,
            encoding,
            buffer: buffer[fdNumber],
            maxBuffer: maxBuffer[fdNumber],
            lines: lines[fdNumber],
            allMixed: false,
            stripFinalNewline,
            verboseInfo,
            streamInfo
        }));
const waitForSubprocessStream = async ({ stream, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo })=>{
    if (!stream) {
        return;
    }
    const onStreamEnd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForStream"])(stream, fdNumber, streamInfo);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInputFileDescriptor"])(streamInfo, fdNumber)) {
        await onStreamEnd;
        return;
    }
    const [output] = await Promise.all([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$contents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getStreamOutput"])({
            stream,
            onStreamEnd,
            fdNumber,
            encoding,
            buffer,
            maxBuffer,
            lines,
            allMixed,
            stripFinalNewline,
            verboseInfo,
            streamInfo
        }),
        onStreamEnd
    ]);
    return output;
};
}),
"[project]/node_modules/execa/lib/resolve/all-async.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "makeAllStream",
    ()=>makeAllStream,
    "waitForAllStream",
    ()=>waitForAllStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$merge$2d$streams$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/merge-streams/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$stdio$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/stdio.js [app-ssr] (ecmascript)");
;
;
const makeAllStream = ({ stdout, stderr }, { all })=>all && (stdout || stderr) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$merge$2d$streams$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])([
        stdout,
        stderr
    ].filter(Boolean)) : undefined;
const waitForAllStream = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$stdio$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForSubprocessStream"])({
        ...getAllStream(subprocess, buffer),
        fdNumber: 'all',
        encoding,
        maxBuffer: maxBuffer[1] + maxBuffer[2],
        lines: lines[1] || lines[2],
        allMixed: getAllMixed(subprocess),
        stripFinalNewline,
        verboseInfo,
        streamInfo
    });
const getAllStream = ({ stdout, stderr, all }, [, bufferStdout, bufferStderr])=>{
    const buffer = bufferStdout || bufferStderr;
    if (!buffer) {
        return {
            stream: all,
            buffer
        };
    }
    if (!bufferStdout) {
        return {
            stream: stderr,
            buffer
        };
    }
    if (!bufferStderr) {
        return {
            stream: stdout,
            buffer
        };
    }
    return {
        stream: all,
        buffer
    };
};
// When `subprocess.stdout` is in objectMode but not `subprocess.stderr` (or the opposite), we need to use both:
//  - `getStreamAsArray()` for the chunks in objectMode, to return as an array without changing each chunk
//  - `getStreamAsArrayBuffer()` or `getStream()` for the chunks not in objectMode, to convert them from Buffers to string or Uint8Array
// We do this by emulating the Buffer -> string|Uint8Array conversion performed by `get-stream` with our own, which is identical.
const getAllMixed = ({ all, stdout, stderr })=>all && stdout && stderr && stdout.readableObjectMode !== stderr.readableObjectMode;
}),
"[project]/node_modules/execa/lib/verbose/ipc.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logIpcOutput",
    ()=>logIpcOutput,
    "shouldLogIpc",
    ()=>shouldLogIpc
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/log.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-ssr] (ecmascript)");
;
;
const shouldLogIpc = (verboseInfo)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFullVerbose"])(verboseInfo, 'ipc');
const logIpcOutput = (message, verboseInfo)=>{
    const verboseMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeVerboseMessage"])(message);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["verboseLog"])({
        type: 'ipc',
        verboseMessage,
        fdNumber: 'ipc',
        verboseInfo
    });
};
}),
"[project]/node_modules/execa/lib/ipc/buffer-messages.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getBufferedIpcOutput",
    ()=>getBufferedIpcOutput,
    "waitForIpcOutput",
    ()=>waitForIpcOutput
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/max-buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$ipc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/ipc.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$each$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/get-each.js [app-ssr] (ecmascript)");
;
;
;
;
const waitForIpcOutput = async ({ subprocess, buffer: bufferArray, maxBuffer: maxBufferArray, ipc, ipcOutput, verboseInfo })=>{
    if (!ipc) {
        return ipcOutput;
    }
    const isVerbose = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$ipc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shouldLogIpc"])(verboseInfo);
    const buffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFdSpecificValue"])(bufferArray, 'ipc');
    const maxBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFdSpecificValue"])(maxBufferArray, 'ipc');
    for await (const message of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$each$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["loopOnMessages"])({
        anyProcess: subprocess,
        channel: subprocess.channel,
        isSubprocess: false,
        ipc,
        shouldAwait: false,
        reference: true
    })){
        if (buffer) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["checkIpcMaxBuffer"])(subprocess, ipcOutput, maxBuffer);
            ipcOutput.push(message);
        }
        if (isVerbose) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$ipc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logIpcOutput"])(message, verboseInfo);
        }
    }
    return ipcOutput;
};
const getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput)=>{
    await Promise.allSettled([
        ipcOutputPromise
    ]);
    return ipcOutput;
};
}),
"[project]/node_modules/execa/lib/resolve/wait-subprocess.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "waitForSubprocessResult",
    ()=>waitForSubprocessResult
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-stream/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$timeout$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/timeout.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$cancel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/cancel.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/graceful.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$contents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/contents.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$buffer$2d$messages$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/buffer-messages.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$ipc$2d$input$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/ipc-input.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$all$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/all-async.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$stdio$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/stdio.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/exit-async.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/wait-stream.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const waitForSubprocessResult = async ({ subprocess, options: { encoding, buffer, maxBuffer, lines, timeoutDuration: timeout, cancelSignal, gracefulCancel, forceKillAfterDelay, stripFinalNewline, ipc, ipcInput }, context, verboseInfo, fileDescriptors, originalStreams, onInternalError, controller })=>{
    const exitPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForExit"])(subprocess, context);
    const streamInfo = {
        originalStreams,
        fileDescriptors,
        subprocess,
        exitPromise,
        propagating: false
    };
    const stdioPromises = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$stdio$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForStdioStreams"])({
        subprocess,
        encoding,
        buffer,
        maxBuffer,
        lines,
        stripFinalNewline,
        verboseInfo,
        streamInfo
    });
    const allPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$all$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForAllStream"])({
        subprocess,
        encoding,
        buffer,
        maxBuffer,
        lines,
        stripFinalNewline,
        verboseInfo,
        streamInfo
    });
    const ipcOutput = [];
    const ipcOutputPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$buffer$2d$messages$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForIpcOutput"])({
        subprocess,
        buffer,
        maxBuffer,
        ipc,
        ipcOutput,
        verboseInfo
    });
    const originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);
    const customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);
    try {
        return await Promise.race([
            Promise.all([
                {},
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForSuccessfulExit"])(exitPromise),
                Promise.all(stdioPromises),
                allPromise,
                ipcOutputPromise,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$ipc$2d$input$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sendIpcInput"])(subprocess, ipcInput),
                ...originalPromises,
                ...customStreamsEndPromises
            ]),
            onInternalError,
            throwOnSubprocessError(subprocess, controller),
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$timeout$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["throwOnTimeout"])(subprocess, timeout, context, controller),
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$cancel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["throwOnCancel"])({
                subprocess,
                cancelSignal,
                gracefulCancel,
                context,
                controller
            }),
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$graceful$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["throwOnGracefulCancel"])({
                subprocess,
                cancelSignal,
                gracefulCancel,
                forceKillAfterDelay,
                context,
                controller
            })
        ]);
    } catch (error) {
        context.terminationReason ??= 'other';
        return Promise.all([
            {
                error
            },
            exitPromise,
            Promise.all(stdioPromises.map((stdioPromise)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$contents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBufferedData"])(stdioPromise))),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$contents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBufferedData"])(allPromise),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$buffer$2d$messages$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBufferedIpcOutput"])(ipcOutputPromise, ipcOutput),
            Promise.allSettled(originalPromises),
            Promise.allSettled(customStreamsEndPromises)
        ]);
    }
};
// Transforms replace `subprocess.std*`, which means they are not exposed to users.
// However, we still want to wait for their completion.
const waitForOriginalStreams = (originalStreams, subprocess, streamInfo)=>originalStreams.map((stream, fdNumber)=>stream === subprocess.stdio[fdNumber] ? undefined : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForStream"])(stream, fdNumber, streamInfo));
// Some `stdin`/`stdout`/`stderr` options create a stream, e.g. when passing a file path.
// The `.pipe()` method automatically ends that stream when `subprocess` ends.
// This makes sure we wait for the completion of those streams, in order to catch any error.
const waitForCustomStreamsEnd = (fileDescriptors, streamInfo)=>fileDescriptors.flatMap(({ stdioItems }, fdNumber)=>stdioItems.filter(({ value, stream = value })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStream"])(stream, {
                checkOpen: false
            }) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStandardStream"])(stream)).map(({ type, value, stream = value })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForStream"])(stream, fdNumber, streamInfo, {
                isSameDirection: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type),
                stopOnExit: type === 'native'
            })));
// Fails when the subprocess emits an `error` event
const throwOnSubprocessError = async (subprocess, { signal })=>{
    const [error] = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["once"])(subprocess, 'error', {
        signal
    });
    throw error;
};
}),
"[project]/node_modules/execa/lib/convert/concurrent.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addConcurrentStream",
    ()=>addConcurrentStream,
    "initializeConcurrentStreams",
    ()=>initializeConcurrentStreams,
    "waitForConcurrentStreams",
    ()=>waitForConcurrentStreams
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/deferred.js [app-ssr] (ecmascript)");
;
const initializeConcurrentStreams = ()=>({
        readableDestroy: new WeakMap(),
        writableFinal: new WeakMap(),
        writableDestroy: new WeakMap()
    });
const addConcurrentStream = (concurrentStreams, stream, waitName)=>{
    const weakMap = concurrentStreams[waitName];
    if (!weakMap.has(stream)) {
        weakMap.set(stream, []);
    }
    const promises = weakMap.get(stream);
    const promise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDeferred"])();
    promises.push(promise);
    const resolve = promise.resolve.bind(promise);
    return {
        resolve,
        promises
    };
};
const waitForConcurrentStreams = async ({ resolve, promises }, subprocess)=>{
    resolve();
    const [isSubprocessExit] = await Promise.race([
        Promise.allSettled([
            true,
            subprocess
        ]),
        Promise.all([
            false,
            ...promises
        ])
    ]);
    return !isSubprocessExit;
};
}),
"[project]/node_modules/execa/lib/convert/shared.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "destroyOtherStream",
    ()=>destroyOtherStream,
    "safeWaitForSubprocessStdin",
    ()=>safeWaitForSubprocessStdin,
    "safeWaitForSubprocessStdout",
    ()=>safeWaitForSubprocessStdout,
    "waitForSubprocess",
    ()=>waitForSubprocess,
    "waitForSubprocessStdin",
    ()=>waitForSubprocessStdin,
    "waitForSubprocessStdout",
    ()=>waitForSubprocessStdout
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$promises__$5b$external$5d$__$28$node$3a$stream$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream/promises [external] (node:stream/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/wait-stream.js [app-ssr] (ecmascript)");
;
;
const safeWaitForSubprocessStdin = async (subprocessStdin)=>{
    if (subprocessStdin === undefined) {
        return;
    }
    try {
        await waitForSubprocessStdin(subprocessStdin);
    } catch  {}
};
const safeWaitForSubprocessStdout = async (subprocessStdout)=>{
    if (subprocessStdout === undefined) {
        return;
    }
    try {
        await waitForSubprocessStdout(subprocessStdout);
    } catch  {}
};
const waitForSubprocessStdin = async (subprocessStdin)=>{
    await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$promises__$5b$external$5d$__$28$node$3a$stream$2f$promises$2c$__cjs$29$__["finished"])(subprocessStdin, {
        cleanup: true,
        readable: false,
        writable: true
    });
};
const waitForSubprocessStdout = async (subprocessStdout)=>{
    await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$promises__$5b$external$5d$__$28$node$3a$stream$2f$promises$2c$__cjs$29$__["finished"])(subprocessStdout, {
        cleanup: true,
        readable: true,
        writable: false
    });
};
const waitForSubprocess = async (subprocess, error)=>{
    await subprocess;
    if (error) {
        throw error;
    }
};
const destroyOtherStream = (stream, isOpen, error)=>{
    if (error && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStreamAbort"])(error)) {
        stream.destroy(error);
    } else if (isOpen) {
        stream.destroy();
    }
};
}),
"[project]/node_modules/execa/lib/convert/readable.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createReadable",
    ()=>createReadable,
    "getReadableMethods",
    ()=>getReadableMethods,
    "getReadableOptions",
    ()=>getReadableOptions,
    "getSubprocessStdout",
    ()=>getSubprocessStdout,
    "onReadableDestroy",
    ()=>onReadableDestroy,
    "onStdoutFinished",
    ()=>onStdoutFinished
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/iterate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/deferred.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/concurrent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/shared.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
const createReadable = ({ subprocess, concurrentStreams, encoding }, { from, binary: binaryOption = true, preserveNewlines = true } = {})=>{
    const binary = binaryOption || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(encoding);
    const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
    const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
    const { read, onStdoutDataDone } = getReadableMethods({
        subprocessStdout,
        subprocess,
        binary,
        encoding,
        preserveNewlines
    });
    const readable = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Readable"]({
        read,
        destroy: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["callbackify"])(onReadableDestroy.bind(undefined, {
            subprocessStdout,
            subprocess,
            waitReadableDestroy
        })),
        highWaterMark: readableHighWaterMark,
        objectMode: readableObjectMode,
        encoding: readableEncoding
    });
    onStdoutFinished({
        subprocessStdout,
        onStdoutDataDone,
        readable,
        subprocess
    });
    return readable;
};
const getSubprocessStdout = (subprocess, from, concurrentStreams)=>{
    const subprocessStdout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFromStream"])(subprocess, from);
    const waitReadableDestroy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addConcurrentStream"])(concurrentStreams, subprocessStdout, 'readableDestroy');
    return {
        subprocessStdout,
        waitReadableDestroy
    };
};
const getReadableOptions = ({ readableEncoding, readableObjectMode, readableHighWaterMark }, binary)=>binary ? {
        readableEncoding,
        readableObjectMode,
        readableHighWaterMark
    } : {
        readableEncoding,
        readableObjectMode: true,
        readableHighWaterMark: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_OBJECT_HIGH_WATER_MARK"]
    };
const getReadableMethods = ({ subprocessStdout, subprocess, binary, encoding, preserveNewlines })=>{
    const onStdoutDataDone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDeferred"])();
    const onStdoutData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["iterateOnSubprocessStream"])({
        subprocessStdout,
        subprocess,
        binary,
        shouldEncode: !binary,
        encoding,
        preserveNewlines
    });
    return {
        read () {
            onRead(this, onStdoutData, onStdoutDataDone);
        },
        onStdoutDataDone
    };
};
// Forwards data from `stdout` to `readable`
const onRead = async (readable, onStdoutData, onStdoutDataDone)=>{
    try {
        const { value, done } = await onStdoutData.next();
        if (done) {
            onStdoutDataDone.resolve();
        } else {
            readable.push(value);
        }
    } catch  {}
};
const onStdoutFinished = async ({ subprocessStdout, onStdoutDataDone, readable, subprocess, subprocessStdin })=>{
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForSubprocessStdout"])(subprocessStdout);
        await subprocess;
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeWaitForSubprocessStdin"])(subprocessStdin);
        await onStdoutDataDone;
        if (readable.readable) {
            readable.push(null);
        }
    } catch (error) {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeWaitForSubprocessStdin"])(subprocessStdin);
        destroyOtherReadable(readable, error);
    }
};
const onReadableDestroy = async ({ subprocessStdout, subprocess, waitReadableDestroy }, error)=>{
    if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForConcurrentStreams"])(waitReadableDestroy, subprocess)) {
        destroyOtherReadable(subprocessStdout, error);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForSubprocess"])(subprocess, error);
    }
};
const destroyOtherReadable = (stream, error)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["destroyOtherStream"])(stream, stream.readable, error);
};
}),
"[project]/node_modules/execa/lib/convert/writable.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createWritable",
    ()=>createWritable,
    "getSubprocessStdin",
    ()=>getSubprocessStdin,
    "getWritableMethods",
    ()=>getWritableMethods,
    "onStdinFinished",
    ()=>onStdinFinished,
    "onWritableDestroy",
    ()=>onWritableDestroy
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/concurrent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/shared.js [app-ssr] (ecmascript)");
;
;
;
;
;
const createWritable = ({ subprocess, concurrentStreams }, { to } = {})=>{
    const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
    const writable = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Writable"]({
        ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
        destroy: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["callbackify"])(onWritableDestroy.bind(undefined, {
            subprocessStdin,
            subprocess,
            waitWritableFinal,
            waitWritableDestroy
        })),
        highWaterMark: subprocessStdin.writableHighWaterMark,
        objectMode: subprocessStdin.writableObjectMode
    });
    onStdinFinished(subprocessStdin, writable);
    return writable;
};
const getSubprocessStdin = (subprocess, to, concurrentStreams)=>{
    const subprocessStdin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getToStream"])(subprocess, to);
    const waitWritableFinal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addConcurrentStream"])(concurrentStreams, subprocessStdin, 'writableFinal');
    const waitWritableDestroy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addConcurrentStream"])(concurrentStreams, subprocessStdin, 'writableDestroy');
    return {
        subprocessStdin,
        waitWritableFinal,
        waitWritableDestroy
    };
};
const getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal)=>({
        write: onWrite.bind(undefined, subprocessStdin),
        final: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["callbackify"])(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal))
    });
// Forwards data from `writable` to `stdin`
const onWrite = (subprocessStdin, chunk, encoding, done)=>{
    if (subprocessStdin.write(chunk, encoding)) {
        done();
    } else {
        subprocessStdin.once('drain', done);
    }
};
// Ensures that the writable `final` and readable `end` events awaits the subprocess.
// Like this, any subprocess failure is propagated as a stream `error` event, instead of being lost.
// The user does not need to `await` the subprocess anymore, but now needs to await the stream completion or error.
// When multiple writables are targeting the same stream, they wait for each other, unless the subprocess ends first.
const onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal)=>{
    if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForConcurrentStreams"])(waitWritableFinal, subprocess)) {
        if (subprocessStdin.writable) {
            subprocessStdin.end();
        }
        await subprocess;
    }
};
const onStdinFinished = async (subprocessStdin, writable, subprocessStdout)=>{
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForSubprocessStdin"])(subprocessStdin);
        if (writable.writable) {
            writable.end();
        }
    } catch (error) {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeWaitForSubprocessStdout"])(subprocessStdout);
        destroyOtherWritable(writable, error);
    }
};
const onWritableDestroy = async ({ subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy }, error)=>{
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForConcurrentStreams"])(waitWritableFinal, subprocess);
    if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForConcurrentStreams"])(waitWritableDestroy, subprocess)) {
        destroyOtherWritable(subprocessStdin, error);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForSubprocess"])(subprocess, error);
    }
};
const destroyOtherWritable = (stream, error)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["destroyOtherStream"])(stream, stream.writable, error);
};
}),
"[project]/node_modules/execa/lib/convert/duplex.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createDuplex",
    ()=>createDuplex
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/readable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/writable.js [app-ssr] (ecmascript)");
;
;
;
;
;
const createDuplex = ({ subprocess, concurrentStreams, encoding }, { from, to, binary: binaryOption = true, preserveNewlines = true } = {})=>{
    const binary = binaryOption || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(encoding);
    const { subprocessStdout, waitReadableDestroy } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSubprocessStdout"])(subprocess, from, concurrentStreams);
    const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSubprocessStdin"])(subprocess, to, concurrentStreams);
    const { readableEncoding, readableObjectMode, readableHighWaterMark } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getReadableOptions"])(subprocessStdout, binary);
    const { read, onStdoutDataDone } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getReadableMethods"])({
        subprocessStdout,
        subprocess,
        binary,
        encoding,
        preserveNewlines
    });
    const duplex = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Duplex"]({
        read,
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWritableMethods"])(subprocessStdin, subprocess, waitWritableFinal),
        destroy: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["callbackify"])(onDuplexDestroy.bind(undefined, {
            subprocessStdout,
            subprocessStdin,
            subprocess,
            waitReadableDestroy,
            waitWritableFinal,
            waitWritableDestroy
        })),
        readableHighWaterMark,
        writableHighWaterMark: subprocessStdin.writableHighWaterMark,
        readableObjectMode,
        writableObjectMode: subprocessStdin.writableObjectMode,
        encoding: readableEncoding
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["onStdoutFinished"])({
        subprocessStdout,
        onStdoutDataDone,
        readable: duplex,
        subprocess,
        subprocessStdin
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["onStdinFinished"])(subprocessStdin, duplex, subprocessStdout);
    return duplex;
};
const onDuplexDestroy = async ({ subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy }, error)=>{
    await Promise.all([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["onReadableDestroy"])({
            subprocessStdout,
            subprocess,
            waitReadableDestroy
        }, error),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["onWritableDestroy"])({
            subprocessStdin,
            subprocess,
            waitWritableFinal,
            waitWritableDestroy
        }, error)
    ]);
};
}),
"[project]/node_modules/execa/lib/convert/iterable.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createIterable",
    ()=>createIterable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/iterate.js [app-ssr] (ecmascript)");
;
;
;
const createIterable = (subprocess, encoding, { from, binary: binaryOption = false, preserveNewlines = false } = {})=>{
    const binary = binaryOption || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(encoding);
    const subprocessStdout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getFromStream"])(subprocess, from);
    const onStdoutData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["iterateOnSubprocessStream"])({
        subprocessStdout,
        subprocess,
        binary,
        shouldEncode: true,
        encoding,
        preserveNewlines
    });
    return iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);
};
const iterateOnStdoutData = async function*(onStdoutData, subprocessStdout, subprocess) {
    try {
        yield* onStdoutData;
    } finally{
        if (subprocessStdout.readable) {
            subprocessStdout.destroy();
        }
        await subprocess;
    }
};
}),
"[project]/node_modules/execa/lib/convert/add.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addConvertedStreams",
    ()=>addConvertedStreams
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/concurrent.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/readable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/writable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$duplex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/duplex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$iterable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/iterable.js [app-ssr] (ecmascript)");
;
;
;
;
;
const addConvertedStreams = (subprocess, { encoding })=>{
    const concurrentStreams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["initializeConcurrentStreams"])();
    subprocess.readable = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createReadable"].bind(undefined, {
        subprocess,
        concurrentStreams,
        encoding
    });
    subprocess.writable = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createWritable"].bind(undefined, {
        subprocess,
        concurrentStreams
    });
    subprocess.duplex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$duplex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDuplex"].bind(undefined, {
        subprocess,
        concurrentStreams,
        encoding
    });
    subprocess.iterable = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$iterable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createIterable"].bind(undefined, subprocess, encoding);
    subprocess[Symbol.asyncIterator] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$iterable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createIterable"].bind(undefined, subprocess, encoding, {});
};
}),
"[project]/node_modules/execa/lib/methods/promise.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// The return value is a mixin of `subprocess` and `Promise`
__turbopack_context__.s([
    "mergePromise",
    ()=>mergePromise
]);
const mergePromise = (subprocess, promise)=>{
    for (const [property, descriptor] of descriptors){
        const value = descriptor.value.bind(promise);
        Reflect.defineProperty(subprocess, property, {
            ...descriptor,
            value
        });
    }
};
// eslint-disable-next-line unicorn/prefer-top-level-await
const nativePromisePrototype = (async ()=>{})().constructor.prototype;
const descriptors = [
    'then',
    'catch',
    'finally'
].map((property)=>[
        property,
        Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
}),
"[project]/node_modules/execa/lib/methods/main-async.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "execaCoreAsync",
    ()=>execaCoreAsync
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:events [external] (node:events, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:child_process [external] (node:child_process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$contents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-stream/source/contents.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$command$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/command.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/options.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$shell$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/shell.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$methods$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/methods.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/result.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$reject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/reject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$early$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/early-error.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$handle$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/handle-async.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/strip-newline.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$output$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/output-async.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$kill$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/kill.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$cleanup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/cleanup.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$setup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/setup.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$all$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/all-async.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$subprocess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/wait-subprocess.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$add$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/add.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/deferred.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$promise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/promise.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested)=>{
    const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleAsyncArguments(rawFile, rawArguments, rawOptions);
    const { subprocess, promise } = spawnSubprocessAsync({
        file,
        commandArguments,
        options,
        startTime,
        verboseInfo,
        command,
        escapedCommand,
        fileDescriptors
    });
    subprocess.pipe = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$setup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipeToSubprocess"].bind(undefined, {
        source: subprocess,
        sourcePromise: promise,
        boundOptions: {},
        createNested
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$promise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergePromise"])(subprocess, promise);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SUBPROCESS_OPTIONS"].set(subprocess, {
        options,
        fileDescriptors
    });
    return subprocess;
};
// Compute arguments to pass to `child_process.spawn()`
const handleAsyncArguments = (rawFile, rawArguments, rawOptions)=>{
    const { command, escapedCommand, startTime, verboseInfo } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$command$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleCommand"])(rawFile, rawArguments, rawOptions);
    const { file, commandArguments, options: normalizedOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$options$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeOptions"])(rawFile, rawArguments, rawOptions);
    const options = handleAsyncOptions(normalizedOptions);
    const fileDescriptors = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$handle$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleStdioAsync"])(options, verboseInfo);
    return {
        file,
        commandArguments,
        command,
        escapedCommand,
        startTime,
        verboseInfo,
        options,
        fileDescriptors
    };
};
// Options normalization logic specific to async methods.
// Prevent passing the `timeout` option directly to `child_process.spawn()`.
const handleAsyncOptions = ({ timeout, signal, ...options })=>{
    if (signal !== undefined) {
        throw new TypeError('The "signal" option has been renamed to "cancelSignal" instead.');
    }
    return {
        ...options,
        timeoutDuration: timeout
    };
};
const spawnSubprocessAsync = ({ file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors })=>{
    let subprocess;
    try {
        subprocess = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["spawn"])(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$shell$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concatenateShell"])(file, commandArguments, options));
    } catch (error) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$early$2d$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleEarlyError"])({
            error,
            command,
            escapedCommand,
            fileDescriptors,
            options,
            startTime,
            verboseInfo
        });
    }
    const controller = new AbortController();
    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$events__$5b$external$5d$__$28$node$3a$events$2c$__cjs$29$__["setMaxListeners"])(Number.POSITIVE_INFINITY, controller.signal);
    const originalStreams = [
        ...subprocess.stdio
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$output$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pipeOutputAsync"])(subprocess, fileDescriptors, controller);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$cleanup$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cleanupOnExit"])(subprocess, options, controller);
    const context = {};
    const onInternalError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDeferred"])();
    subprocess.kill = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$kill$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["subprocessKill"].bind(undefined, {
        kill: subprocess.kill.bind(subprocess),
        options,
        onInternalError,
        context,
        controller
    });
    subprocess.all = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$all$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeAllStream"])(subprocess, options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$add$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addConvertedStreams"])(subprocess, options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$methods$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addIpcMethods"])(subprocess, options);
    const promise = handlePromise({
        subprocess,
        options,
        startTime,
        verboseInfo,
        fileDescriptors,
        originalStreams,
        command,
        escapedCommand,
        context,
        onInternalError,
        controller
    });
    return {
        subprocess,
        promise
    };
};
// Asynchronous logic, as opposed to the previous logic which can be run synchronously, i.e. can be returned to user right away
const handlePromise = async ({ subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, context, onInternalError, controller })=>{
    const [errorInfo, [exitCode, signal], stdioResults, allResult, ipcOutput] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$subprocess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForSubprocessResult"])({
        subprocess,
        options,
        context,
        verboseInfo,
        fileDescriptors,
        originalStreams,
        onInternalError,
        controller
    });
    controller.abort();
    onInternalError.resolve();
    const stdio = stdioResults.map((stdioResult, fdNumber)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stripNewline"])(stdioResult, options, fdNumber));
    const all = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stripNewline"])(allResult, options, 'all');
    const result = getAsyncResult({
        errorInfo,
        exitCode,
        signal,
        stdio,
        all,
        ipcOutput,
        context,
        options,
        command,
        escapedCommand,
        startTime
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$reject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["handleResult"])(result, verboseInfo, options);
};
const getAsyncResult = ({ errorInfo, exitCode, signal, stdio, all, ipcOutput, context, options, command, escapedCommand, startTime })=>'error' in errorInfo ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeError"])({
        error: errorInfo.error,
        command,
        escapedCommand,
        timedOut: context.terminationReason === 'timeout',
        isCanceled: context.terminationReason === 'cancel' || context.terminationReason === 'gracefulCancel',
        isGracefullyCanceled: context.terminationReason === 'gracefulCancel',
        isMaxBuffer: errorInfo.error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$contents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MaxBufferError"],
        isForcefullyTerminated: context.isForcefullyTerminated,
        exitCode,
        signal,
        stdio,
        all,
        ipcOutput,
        options,
        startTime,
        isSync: false
    }) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeSuccessResult"])({
        command,
        escapedCommand,
        stdio,
        all,
        ipcOutput,
        options,
        startTime
    });
}),
"[project]/node_modules/execa/lib/methods/bind.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "mergeOptions",
    ()=>mergeOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-ssr] (ecmascript)");
;
;
const mergeOptions = (boundOptions, options)=>{
    const newOptions = Object.fromEntries(Object.entries(options).map(([optionName, optionValue])=>[
            optionName,
            mergeOption(optionName, boundOptions[optionName], optionValue)
        ]));
    return {
        ...boundOptions,
        ...newOptions
    };
};
const mergeOption = (optionName, boundOptionValue, optionValue)=>{
    if (DEEP_OPTIONS.has(optionName) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(boundOptionValue) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(optionValue)) {
        return {
            ...boundOptionValue,
            ...optionValue
        };
    }
    return optionValue;
};
const DEEP_OPTIONS = new Set([
    'env',
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FD_SPECIFIC_OPTIONS"]
]);
}),
"[project]/node_modules/execa/lib/methods/create.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createExeca",
    ()=>createExeca
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$parameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/parameters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$template$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/template.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$main$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/main-sync.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$main$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/main-async.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$bind$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/bind.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
const createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca)=>{
    const createNested = (mapArguments, boundOptions, setBoundExeca)=>createExeca(mapArguments, boundOptions, deepOptions, setBoundExeca);
    const boundExeca = (...execaArguments)=>callBoundExeca({
            mapArguments,
            deepOptions,
            boundOptions,
            setBoundExeca,
            createNested
        }, ...execaArguments);
    if (setBoundExeca !== undefined) {
        setBoundExeca(boundExeca, createNested, boundOptions);
    }
    return boundExeca;
};
const callBoundExeca = ({ mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested }, firstArgument, ...nextArguments)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(firstArgument)) {
        return createNested(mapArguments, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$bind$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeOptions"])(boundOptions, firstArgument), setBoundExeca);
    }
    const { file, commandArguments, options, isSync } = parseArguments({
        mapArguments,
        firstArgument,
        nextArguments,
        deepOptions,
        boundOptions
    });
    return isSync ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$main$2d$sync$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execaCoreSync"])(file, commandArguments, options) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$main$2d$async$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execaCoreAsync"])(file, commandArguments, options, createNested);
};
const parseArguments = ({ mapArguments, firstArgument, nextArguments, deepOptions, boundOptions })=>{
    const callArguments = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$template$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isTemplateString"])(firstArgument) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$template$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseTemplates"])(firstArgument, nextArguments) : [
        firstArgument,
        ...nextArguments
    ];
    const [initialFile, initialArguments, initialOptions] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$parameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeParameters"])(...callArguments);
    const mergedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$bind$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeOptions"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$bind$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeOptions"])(deepOptions, boundOptions), initialOptions);
    const { file = initialFile, commandArguments = initialArguments, options = mergedOptions, isSync = false } = mapArguments({
        file: initialFile,
        commandArguments: initialArguments,
        options: mergedOptions
    });
    return {
        file,
        commandArguments,
        options,
        isSync
    };
};
}),
"[project]/node_modules/execa/lib/methods/command.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Main logic for `execaCommand()`
__turbopack_context__.s([
    "mapCommandAsync",
    ()=>mapCommandAsync,
    "mapCommandSync",
    ()=>mapCommandSync,
    "parseCommandString",
    ()=>parseCommandString
]);
const mapCommandAsync = ({ file, commandArguments })=>parseCommand(file, commandArguments);
const mapCommandSync = ({ file, commandArguments })=>({
        ...parseCommand(file, commandArguments),
        isSync: true
    });
// Convert `execaCommand(command)` into `execa(file, ...commandArguments)`
const parseCommand = (command, unusedArguments)=>{
    if (unusedArguments.length > 0) {
        throw new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);
    }
    const [file, ...commandArguments] = parseCommandString(command);
    return {
        file,
        commandArguments
    };
};
const parseCommandString = (command)=>{
    if (typeof command !== 'string') {
        throw new TypeError(`The command must be a string: ${String(command)}.`);
    }
    const trimmedCommand = command.trim();
    if (trimmedCommand === '') {
        return [];
    }
    const tokens = [];
    for (const token of trimmedCommand.split(SPACES_REGEXP)){
        // Allow spaces to be escaped by a backslash if not meant as a delimiter
        const previousToken = tokens.at(-1);
        if (previousToken && previousToken.endsWith('\\')) {
            // Merge previous token with current one
            tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        } else {
            tokens.push(token);
        }
    }
    return tokens;
};
const SPACES_REGEXP = / +/g;
}),
"[project]/node_modules/execa/lib/methods/script.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Sets `$.sync` and `$.s`
__turbopack_context__.s([
    "deepScriptOptions",
    ()=>deepScriptOptions,
    "mapScriptAsync",
    ()=>mapScriptAsync,
    "setScriptSync",
    ()=>setScriptSync
]);
const setScriptSync = (boundExeca, createNested, boundOptions)=>{
    boundExeca.sync = createNested(mapScriptSync, boundOptions);
    boundExeca.s = boundExeca.sync;
};
const mapScriptAsync = ({ options })=>getScriptOptions(options);
// Main logic for `$.sync`
const mapScriptSync = ({ options })=>({
        ...getScriptOptions(options),
        isSync: true
    });
// `$` is like `execa` but with script-friendly options: `{stdin: 'inherit', preferLocal: true}`
const getScriptOptions = (options)=>({
        options: {
            ...getScriptStdinOption(options),
            ...options
        }
    });
const getScriptStdinOption = ({ input, inputFile, stdio })=>input === undefined && inputFile === undefined && stdio === undefined ? {
        stdin: 'inherit'
    } : {};
const deepScriptOptions = {
    preferLocal: true
};
}),
"[project]/node_modules/execa/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$",
    ()=>$,
    "execa",
    ()=>execa,
    "execaCommand",
    ()=>execaCommand,
    "execaCommandSync",
    ()=>execaCommandSync,
    "execaNode",
    ()=>execaNode,
    "execaSync",
    ()=>execaSync,
    "getCancelSignal",
    ()=>getCancelSignal,
    "getEachMessage",
    ()=>getEachMessage,
    "getOneMessage",
    ()=>getOneMessage,
    "sendMessage",
    ()=>sendMessage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/create.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$command$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/command.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/node.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$script$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/script.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$methods$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/methods.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const execa = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createExeca"])(()=>({}));
const execaSync = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createExeca"])(()=>({
        isSync: true
    }));
const execaCommand = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createExeca"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$command$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mapCommandAsync"]);
const execaCommandSync = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createExeca"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$command$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mapCommandSync"]);
const execaNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createExeca"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$node$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mapNode"]);
const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createExeca"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$script$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mapScriptAsync"], {}, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$script$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepScriptOptions"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$script$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setScriptSync"]);
const { sendMessage, getOneMessage, getEachMessage, getCancelSignal } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$methods$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getIpcExport"])();
;
}),
];

//# sourceMappingURL=node_modules_execa_a62177ac._.js.map