{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/arguments/file-url.js"],"sourcesContent":["import {fileURLToPath} from 'node:url';\n\n// Allow some arguments/options to be either a file path string or a file URL\nexport const safeNormalizeFileUrl = (file, name) => {\n\tconst fileString = normalizeFileUrl(normalizeDenoExecPath(file));\n\n\tif (typeof fileString !== 'string') {\n\t\tthrow new TypeError(`${name} must be a string or a file URL: ${fileString}.`);\n\t}\n\n\treturn fileString;\n};\n\n// In Deno node:process execPath is a special object, not just a string:\n// https://github.com/denoland/deno/blob/f460188e583f00144000aa0d8ade08218d47c3c1/ext/node/polyfills/process.ts#L344\nconst normalizeDenoExecPath = file => isDenoExecPath(file)\n\t? file.toString()\n\t: file;\n\nexport const isDenoExecPath = file => typeof file !== 'string'\n\t&& file\n\t&& Object.getPrototypeOf(file) === String.prototype;\n\n// Same but also allows other values, e.g. `boolean` for the `shell` option\nexport const normalizeFileUrl = file => file instanceof URL ? fileURLToPath(file) : file;\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAGO,MAAM,uBAAuB,CAAC,MAAM;IAC1C,MAAM,aAAa,iBAAiB,sBAAsB;IAE1D,IAAI,OAAO,eAAe,UAAU;QACnC,MAAM,IAAI,UAAU,GAAG,KAAK,iCAAiC,EAAE,WAAW,CAAC,CAAC;IAC7E;IAEA,OAAO;AACR;AAEA,wEAAwE;AACxE,oHAAoH;AACpH,MAAM,wBAAwB,CAAA,OAAQ,eAAe,QAClD,KAAK,QAAQ,KACb;AAEI,MAAM,iBAAiB,CAAA,OAAQ,OAAO,SAAS,YAClD,QACA,OAAO,cAAc,CAAC,UAAU,OAAO,SAAS;AAG7C,MAAM,mBAAmB,CAAA,OAAQ,gBAAgB,MAAM,IAAA,gIAAa,EAAC,QAAQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/methods/parameters.js"],"sourcesContent":["import isPlainObject from 'is-plain-obj';\nimport {safeNormalizeFileUrl} from '../arguments/file-url.js';\n\n// The command `arguments` and `options` are both optional.\n// This also does basic validation on them and on the command file.\nexport const normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {\n\tconst filePath = safeNormalizeFileUrl(rawFile, 'First argument');\n\tconst [commandArguments, options] = isPlainObject(rawArguments)\n\t\t? [[], rawArguments]\n\t\t: [rawArguments, rawOptions];\n\n\tif (!Array.isArray(commandArguments)) {\n\t\tthrow new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);\n\t}\n\n\tif (commandArguments.some(commandArgument => typeof commandArgument === 'object' && commandArgument !== null)) {\n\t\tthrow new TypeError(`Second argument must be an array of strings: ${commandArguments}`);\n\t}\n\n\tconst normalizedArguments = commandArguments.map(String);\n\tconst nullByteArgument = normalizedArguments.find(normalizedArgument => normalizedArgument.includes('\\0'));\n\tif (nullByteArgument !== undefined) {\n\t\tthrow new TypeError(`Arguments cannot contain null bytes (\"\\\\0\"): ${nullByteArgument}`);\n\t}\n\n\tif (!isPlainObject(options)) {\n\t\tthrow new TypeError(`Last argument must be an options object: ${options}`);\n\t}\n\n\treturn [filePath, normalizedArguments, options];\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAIO,MAAM,sBAAsB,CAAC,SAAS,eAAe,EAAE,EAAE,aAAa,CAAC,CAAC;IAC9E,MAAM,WAAW,IAAA,gLAAoB,EAAC,SAAS;IAC/C,MAAM,CAAC,kBAAkB,QAAQ,GAAG,IAAA,sJAAa,EAAC,gBAC/C;QAAC,EAAE;QAAE;KAAa,GAClB;QAAC;QAAc;KAAW;IAE7B,IAAI,CAAC,MAAM,OAAO,CAAC,mBAAmB;QACrC,MAAM,IAAI,UAAU,CAAC,2EAA2E,EAAE,kBAAkB;IACrH;IAEA,IAAI,iBAAiB,IAAI,CAAC,CAAA,kBAAmB,OAAO,oBAAoB,YAAY,oBAAoB,OAAO;QAC9G,MAAM,IAAI,UAAU,CAAC,6CAA6C,EAAE,kBAAkB;IACvF;IAEA,MAAM,sBAAsB,iBAAiB,GAAG,CAAC;IACjD,MAAM,mBAAmB,oBAAoB,IAAI,CAAC,CAAA,qBAAsB,mBAAmB,QAAQ,CAAC;IACpG,IAAI,qBAAqB,WAAW;QACnC,MAAM,IAAI,UAAU,CAAC,6CAA6C,EAAE,kBAAkB;IACvF;IAEA,IAAI,CAAC,IAAA,sJAAa,EAAC,UAAU;QAC5B,MAAM,IAAI,UAAU,CAAC,yCAAyC,EAAE,SAAS;IAC1E;IAEA,OAAO;QAAC;QAAU;QAAqB;KAAQ;AAChD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/utils/uint-array.js"],"sourcesContent":["import {StringDecoder} from 'node:string_decoder';\n\nconst {toString: objectToString} = Object.prototype;\n\nexport const isArrayBuffer = value => objectToString.call(value) === '[object ArrayBuffer]';\n\n// Is either Uint8Array or Buffer\nexport const isUint8Array = value => objectToString.call(value) === '[object Uint8Array]';\n\nexport const bufferToUint8Array = buffer => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n\nconst textEncoder = new TextEncoder();\nconst stringToUint8Array = string => textEncoder.encode(string);\n\nconst textDecoder = new TextDecoder();\nexport const uint8ArrayToString = uint8Array => textDecoder.decode(uint8Array);\n\nexport const joinToString = (uint8ArraysOrStrings, encoding) => {\n\tconst strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);\n\treturn strings.join('');\n};\n\nconst uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {\n\tif (encoding === 'utf8' && uint8ArraysOrStrings.every(uint8ArrayOrString => typeof uint8ArrayOrString === 'string')) {\n\t\treturn uint8ArraysOrStrings;\n\t}\n\n\tconst decoder = new StringDecoder(encoding);\n\tconst strings = uint8ArraysOrStrings\n\t\t.map(uint8ArrayOrString => typeof uint8ArrayOrString === 'string'\n\t\t\t? stringToUint8Array(uint8ArrayOrString)\n\t\t\t: uint8ArrayOrString)\n\t\t.map(uint8Array => decoder.write(uint8Array));\n\tconst finalString = decoder.end();\n\treturn finalString === '' ? strings : [...strings, finalString];\n};\n\nexport const joinToUint8Array = uint8ArraysOrStrings => {\n\tif (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {\n\t\treturn uint8ArraysOrStrings[0];\n\t}\n\n\treturn concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));\n};\n\nconst stringsToUint8Arrays = uint8ArraysOrStrings => uint8ArraysOrStrings.map(uint8ArrayOrString => typeof uint8ArrayOrString === 'string'\n\t? stringToUint8Array(uint8ArrayOrString)\n\t: uint8ArrayOrString);\n\nexport const concatUint8Arrays = uint8Arrays => {\n\tconst result = new Uint8Array(getJoinLength(uint8Arrays));\n\n\tlet index = 0;\n\tfor (const uint8Array of uint8Arrays) {\n\t\tresult.set(uint8Array, index);\n\t\tindex += uint8Array.length;\n\t}\n\n\treturn result;\n};\n\nconst getJoinLength = uint8Arrays => {\n\tlet joinLength = 0;\n\tfor (const uint8Array of uint8Arrays) {\n\t\tjoinLength += uint8Array.length;\n\t}\n\n\treturn joinLength;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;AAEA,MAAM,EAAC,UAAU,cAAc,EAAC,GAAG,OAAO,SAAS;AAE5C,MAAM,gBAAgB,CAAA,QAAS,eAAe,IAAI,CAAC,WAAW;AAG9D,MAAM,eAAe,CAAA,QAAS,eAAe,IAAI,CAAC,WAAW;AAE7D,MAAM,qBAAqB,CAAA,SAAU,IAAI,WAAW,OAAO,MAAM,EAAE,OAAO,UAAU,EAAE,OAAO,UAAU;AAE9G,MAAM,cAAc,IAAI;AACxB,MAAM,qBAAqB,CAAA,SAAU,YAAY,MAAM,CAAC;AAExD,MAAM,cAAc,IAAI;AACjB,MAAM,qBAAqB,CAAA,aAAc,YAAY,MAAM,CAAC;AAE5D,MAAM,eAAe,CAAC,sBAAsB;IAClD,MAAM,UAAU,qBAAqB,sBAAsB;IAC3D,OAAO,QAAQ,IAAI,CAAC;AACrB;AAEA,MAAM,uBAAuB,CAAC,sBAAsB;IACnD,IAAI,aAAa,UAAU,qBAAqB,KAAK,CAAC,CAAA,qBAAsB,OAAO,uBAAuB,WAAW;QACpH,OAAO;IACR;IAEA,MAAM,UAAU,IAAI,sJAAa,CAAC;IAClC,MAAM,UAAU,qBACd,GAAG,CAAC,CAAA,qBAAsB,OAAO,uBAAuB,WACtD,mBAAmB,sBACnB,oBACF,GAAG,CAAC,CAAA,aAAc,QAAQ,KAAK,CAAC;IAClC,MAAM,cAAc,QAAQ,GAAG;IAC/B,OAAO,gBAAgB,KAAK,UAAU;WAAI;QAAS;KAAY;AAChE;AAEO,MAAM,mBAAmB,CAAA;IAC/B,IAAI,qBAAqB,MAAM,KAAK,KAAK,aAAa,oBAAoB,CAAC,EAAE,GAAG;QAC/E,OAAO,oBAAoB,CAAC,EAAE;IAC/B;IAEA,OAAO,kBAAkB,qBAAqB;AAC/C;AAEA,MAAM,uBAAuB,CAAA,uBAAwB,qBAAqB,GAAG,CAAC,CAAA,qBAAsB,OAAO,uBAAuB,WAC/H,mBAAmB,sBACnB;AAEI,MAAM,oBAAoB,CAAA;IAChC,MAAM,SAAS,IAAI,WAAW,cAAc;IAE5C,IAAI,QAAQ;IACZ,KAAK,MAAM,cAAc,YAAa;QACrC,OAAO,GAAG,CAAC,YAAY;QACvB,SAAS,WAAW,MAAM;IAC3B;IAEA,OAAO;AACR;AAEA,MAAM,gBAAgB,CAAA;IACrB,IAAI,aAAa;IACjB,KAAK,MAAM,cAAc,YAAa;QACrC,cAAc,WAAW,MAAM;IAChC;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/methods/template.js"],"sourcesContent":["import {ChildProcess} from 'node:child_process';\nimport isPlainObject from 'is-plain-obj';\nimport {isUint8Array, uint8ArrayToString} from '../utils/uint-array.js';\n\n// Check whether the template string syntax is being used\nexport const isTemplateString = templates => Array.isArray(templates) && Array.isArray(templates.raw);\n\n// Convert execa`file ...commandArguments` to execa(file, commandArguments)\nexport const parseTemplates = (templates, expressions) => {\n\tlet tokens = [];\n\n\tfor (const [index, template] of templates.entries()) {\n\t\ttokens = parseTemplate({\n\t\t\ttemplates,\n\t\t\texpressions,\n\t\t\ttokens,\n\t\t\tindex,\n\t\t\ttemplate,\n\t\t});\n\t}\n\n\tif (tokens.length === 0) {\n\t\tthrow new TypeError('Template script must not be empty');\n\t}\n\n\tconst [file, ...commandArguments] = tokens;\n\treturn [file, commandArguments, {}];\n};\n\nconst parseTemplate = ({templates, expressions, tokens, index, template}) => {\n\tif (template === undefined) {\n\t\tthrow new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);\n\t}\n\n\tconst {nextTokens, leadingWhitespaces, trailingWhitespaces} = splitByWhitespaces(template, templates.raw[index]);\n\tconst newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);\n\n\tif (index === expressions.length) {\n\t\treturn newTokens;\n\t}\n\n\tconst expression = expressions[index];\n\tconst expressionTokens = Array.isArray(expression)\n\t\t? expression.map(expression => parseExpression(expression))\n\t\t: [parseExpression(expression)];\n\treturn concatTokens(newTokens, expressionTokens, trailingWhitespaces);\n};\n\n// Like `string.split(/[ \\t\\r\\n]+/)` except newlines and tabs are:\n//  - ignored when input as a backslash sequence like: `echo foo\\n bar`\n//  - not ignored when input directly\n// The only way to distinguish those in JavaScript is to use a tagged template and compare:\n//  - the first array argument, which does not escape backslash sequences\n//  - its `raw` property, which escapes them\nconst splitByWhitespaces = (template, rawTemplate) => {\n\tif (rawTemplate.length === 0) {\n\t\treturn {nextTokens: [], leadingWhitespaces: false, trailingWhitespaces: false};\n\t}\n\n\tconst nextTokens = [];\n\tlet templateStart = 0;\n\tconst leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);\n\n\tfor (\n\t\tlet templateIndex = 0, rawIndex = 0;\n\t\ttemplateIndex < template.length;\n\t\ttemplateIndex += 1, rawIndex += 1\n\t) {\n\t\tconst rawCharacter = rawTemplate[rawIndex];\n\t\tif (DELIMITERS.has(rawCharacter)) {\n\t\t\tif (templateStart !== templateIndex) {\n\t\t\t\tnextTokens.push(template.slice(templateStart, templateIndex));\n\t\t\t}\n\n\t\t\ttemplateStart = templateIndex + 1;\n\t\t} else if (rawCharacter === '\\\\') {\n\t\t\tconst nextRawCharacter = rawTemplate[rawIndex + 1];\n\t\t\tif (nextRawCharacter === '\\n') {\n\t\t\t\t// Handles escaped newlines in templates\n\t\t\t\ttemplateIndex -= 1;\n\t\t\t\trawIndex += 1;\n\t\t\t} else if (nextRawCharacter === 'u' && rawTemplate[rawIndex + 2] === '{') {\n\t\t\t\trawIndex = rawTemplate.indexOf('}', rawIndex + 3);\n\t\t\t} else {\n\t\t\t\trawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst trailingWhitespaces = templateStart === template.length;\n\tif (!trailingWhitespaces) {\n\t\tnextTokens.push(template.slice(templateStart));\n\t}\n\n\treturn {nextTokens, leadingWhitespaces, trailingWhitespaces};\n};\n\nconst DELIMITERS = new Set([' ', '\\t', '\\r', '\\n']);\n\n// Number of characters in backslash escape sequences: \\0 \\xXX or \\uXXXX\n// \\cX is allowed in RegExps but not in strings\n// Octal sequences are not allowed in strict mode\nconst ESCAPE_LENGTH = {x: 3, u: 5};\n\nconst concatTokens = (tokens, nextTokens, isSeparated) => isSeparated\n\t|| tokens.length === 0\n\t|| nextTokens.length === 0\n\t? [...tokens, ...nextTokens]\n\t: [\n\t\t...tokens.slice(0, -1),\n\t\t`${tokens.at(-1)}${nextTokens[0]}`,\n\t\t...nextTokens.slice(1),\n\t];\n\n// Handle `${expression}` inside the template string syntax\nconst parseExpression = expression => {\n\tconst typeOfExpression = typeof expression;\n\n\tif (typeOfExpression === 'string') {\n\t\treturn expression;\n\t}\n\n\tif (typeOfExpression === 'number') {\n\t\treturn String(expression);\n\t}\n\n\tif (isPlainObject(expression) && ('stdout' in expression || 'isMaxBuffer' in expression)) {\n\t\treturn getSubprocessResult(expression);\n\t}\n\n\tif (expression instanceof ChildProcess || Object.prototype.toString.call(expression) === '[object Promise]') {\n\t\t// eslint-disable-next-line no-template-curly-in-string\n\t\tthrow new TypeError('Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.');\n\t}\n\n\tthrow new TypeError(`Unexpected \"${typeOfExpression}\" in template expression`);\n};\n\nconst getSubprocessResult = ({stdout}) => {\n\tif (typeof stdout === 'string') {\n\t\treturn stdout;\n\t}\n\n\tif (isUint8Array(stdout)) {\n\t\treturn uint8ArrayToString(stdout);\n\t}\n\n\tif (stdout === undefined) {\n\t\tthrow new TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\\' \"stdout\" option.');\n\t}\n\n\tthrow new TypeError(`Unexpected \"${typeof stdout}\" stdout in template expression`);\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 291, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/utils/standard-stream.js"],"sourcesContent":["import process from 'node:process';\n\nexport const isStandardStream = stream => STANDARD_STREAMS.includes(stream);\nexport const STANDARD_STREAMS = [process.stdin, process.stdout, process.stderr];\nexport const STANDARD_STREAMS_ALIASES = ['stdin', 'stdout', 'stderr'];\nexport const getStreamName = fdNumber => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEO,MAAM,mBAAmB,CAAA,SAAU,iBAAiB,QAAQ,CAAC;AAC7D,MAAM,mBAAmB;IAAC,kIAAO,CAAC,KAAK;IAAE,kIAAO,CAAC,MAAM;IAAE,kIAAO,CAAC,MAAM;CAAC;AACxE,MAAM,2BAA2B;IAAC;IAAS;IAAU;CAAS;AAC9D,MAAM,gBAAgB,CAAA,WAAY,wBAAwB,CAAC,SAAS,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 319, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/arguments/specific.js"],"sourcesContent":["import {debuglog} from 'node:util';\nimport isPlainObject from 'is-plain-obj';\nimport {STANDARD_STREAMS_ALIASES} from '../utils/standard-stream.js';\n\n// Some options can have different values for `stdout`/`stderr`/`fd3`.\n// This normalizes those to array of values.\n// For example, `{verbose: {stdout: 'none', stderr: 'full'}}` becomes `{verbose: ['none', 'none', 'full']}`\nexport const normalizeFdSpecificOptions = options => {\n\tconst optionsCopy = {...options};\n\n\tfor (const optionName of FD_SPECIFIC_OPTIONS) {\n\t\toptionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);\n\t}\n\n\treturn optionsCopy;\n};\n\nexport const normalizeFdSpecificOption = (options, optionName) => {\n\tconst optionBaseArray = Array.from({length: getStdioLength(options) + 1});\n\tconst optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);\n\treturn addDefaultValue(optionArray, optionName);\n};\n\nconst getStdioLength = ({stdio}) => Array.isArray(stdio)\n\t? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length)\n\t: STANDARD_STREAMS_ALIASES.length;\n\nconst normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject(optionValue)\n\t? normalizeOptionObject(optionValue, optionArray, optionName)\n\t: optionArray.fill(optionValue);\n\nconst normalizeOptionObject = (optionValue, optionArray, optionName) => {\n\tfor (const fdName of Object.keys(optionValue).sort(compareFdName)) {\n\t\tfor (const fdNumber of parseFdName(fdName, optionName, optionArray)) {\n\t\t\toptionArray[fdNumber] = optionValue[fdName];\n\t\t}\n\t}\n\n\treturn optionArray;\n};\n\n// Ensure priority order when setting both `stdout`/`stderr`, `fd1`/`fd2`, and `all`\nconst compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;\n\nconst getFdNameOrder = fdName => {\n\tif (fdName === 'stdout' || fdName === 'stderr') {\n\t\treturn 0;\n\t}\n\n\treturn fdName === 'all' ? 2 : 1;\n};\n\nconst parseFdName = (fdName, optionName, optionArray) => {\n\tif (fdName === 'ipc') {\n\t\treturn [optionArray.length - 1];\n\t}\n\n\tconst fdNumber = parseFd(fdName);\n\tif (fdNumber === undefined || fdNumber === 0) {\n\t\tthrow new TypeError(`\"${optionName}.${fdName}\" is invalid.\nIt must be \"${optionName}.stdout\", \"${optionName}.stderr\", \"${optionName}.all\", \"${optionName}.ipc\", or \"${optionName}.fd3\", \"${optionName}.fd4\" (and so on).`);\n\t}\n\n\tif (fdNumber >= optionArray.length) {\n\t\tthrow new TypeError(`\"${optionName}.${fdName}\" is invalid: that file descriptor does not exist.\nPlease set the \"stdio\" option to ensure that file descriptor exists.`);\n\t}\n\n\treturn fdNumber === 'all' ? [1, 2] : [fdNumber];\n};\n\n// Use the same syntax for fd-specific options and the `from`/`to` options\nexport const parseFd = fdName => {\n\tif (fdName === 'all') {\n\t\treturn fdName;\n\t}\n\n\tif (STANDARD_STREAMS_ALIASES.includes(fdName)) {\n\t\treturn STANDARD_STREAMS_ALIASES.indexOf(fdName);\n\t}\n\n\tconst regexpResult = FD_REGEXP.exec(fdName);\n\tif (regexpResult !== null) {\n\t\treturn Number(regexpResult[1]);\n\t}\n};\n\nconst FD_REGEXP = /^fd(\\d+)$/;\n\nconst addDefaultValue = (optionArray, optionName) => optionArray.map(optionValue => optionValue === undefined\n\t? DEFAULT_OPTIONS[optionName]\n\t: optionValue);\n\n// Default value for the `verbose` option\nconst verboseDefault = debuglog('execa').enabled ? 'full' : 'none';\n\nconst DEFAULT_OPTIONS = {\n\tlines: false,\n\tbuffer: true,\n\tmaxBuffer: 1000 * 1000 * 100,\n\tverbose: verboseDefault,\n\tstripFinalNewline: true,\n};\n\n// List of options which can have different values for `stdout`/`stderr`\nexport const FD_SPECIFIC_OPTIONS = ['lines', 'buffer', 'maxBuffer', 'verbose', 'stripFinalNewline'];\n\n// Retrieve fd-specific option\nexport const getFdSpecificValue = (optionArray, fdNumber) => fdNumber === 'ipc'\n\t? optionArray.at(-1)\n\t: optionArray[fdNumber];\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 428, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/verbose/values.js"],"sourcesContent":["import {getFdSpecificValue} from '../arguments/specific.js';\n\n// The `verbose` option can have different values for `stdout`/`stderr`\nexport const isVerbose = ({verbose}, fdNumber) => getFdVerbose(verbose, fdNumber) !== 'none';\n\n// Whether IPC and output and logged\nexport const isFullVerbose = ({verbose}, fdNumber) => !['none', 'short'].includes(getFdVerbose(verbose, fdNumber));\n\n// The `verbose` option can be a function to customize logging\nexport const getVerboseFunction = ({verbose}, fdNumber) => {\n\tconst fdVerbose = getFdVerbose(verbose, fdNumber);\n\treturn isVerboseFunction(fdVerbose) ? fdVerbose : undefined;\n};\n\n// When using `verbose: {stdout, stderr, fd3, ipc}`:\n//  - `verbose.stdout|stderr|fd3` is used for 'output'\n//  - `verbose.ipc` is only used for 'ipc'\n//  - highest `verbose.*` value is used for 'command', 'error' and 'duration'\nconst getFdVerbose = (verbose, fdNumber) => fdNumber === undefined\n\t? getFdGenericVerbose(verbose)\n\t: getFdSpecificValue(verbose, fdNumber);\n\n// When using `verbose: {stdout, stderr, fd3, ipc}` and logging is not specific to a file descriptor.\n// We then use the highest `verbose.*` value, using the following order:\n//  - function > 'full' > 'short' > 'none'\n//  - if several functions are defined: stdout > stderr > fd3 > ipc\nconst getFdGenericVerbose = verbose => verbose.find(fdVerbose => isVerboseFunction(fdVerbose))\n\t?? VERBOSE_VALUES.findLast(fdVerbose => verbose.includes(fdVerbose));\n\n// Whether the `verbose` option is customized using a function\nexport const isVerboseFunction = fdVerbose => typeof fdVerbose === 'function';\n\nexport const VERBOSE_VALUES = ['none', 'short', 'full'];\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAGO,MAAM,YAAY,CAAC,EAAC,OAAO,EAAC,EAAE,WAAa,aAAa,SAAS,cAAc;AAG/E,MAAM,gBAAgB,CAAC,EAAC,OAAO,EAAC,EAAE,WAAa,CAAC;QAAC;QAAQ;KAAQ,CAAC,QAAQ,CAAC,aAAa,SAAS;AAGjG,MAAM,qBAAqB,CAAC,EAAC,OAAO,EAAC,EAAE;IAC7C,MAAM,YAAY,aAAa,SAAS;IACxC,OAAO,kBAAkB,aAAa,YAAY;AACnD;AAEA,oDAAoD;AACpD,sDAAsD;AACtD,0CAA0C;AAC1C,6EAA6E;AAC7E,MAAM,eAAe,CAAC,SAAS,WAAa,aAAa,YACtD,oBAAoB,WACpB,IAAA,2KAAkB,EAAC,SAAS;AAE/B,qGAAqG;AACrG,wEAAwE;AACxE,0CAA0C;AAC1C,mEAAmE;AACnE,MAAM,sBAAsB,CAAA,UAAW,QAAQ,IAAI,CAAC,CAAA,YAAa,kBAAkB,eAC/E,eAAe,QAAQ,CAAC,CAAA,YAAa,QAAQ,QAAQ,CAAC;AAGnD,MAAM,oBAAoB,CAAA,YAAa,OAAO,cAAc;AAE5D,MAAM,iBAAiB;IAAC;IAAQ;IAAS;CAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 471, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/arguments/escape.js"],"sourcesContent":["import {platform} from 'node:process';\nimport {stripVTControlCharacters} from 'node:util';\n\n// Compute `result.command` and `result.escapedCommand`\nexport const joinCommand = (filePath, rawArguments) => {\n\tconst fileAndArguments = [filePath, ...rawArguments];\n\tconst command = fileAndArguments.join(' ');\n\tconst escapedCommand = fileAndArguments\n\t\t.map(fileAndArgument => quoteString(escapeControlCharacters(fileAndArgument)))\n\t\t.join(' ');\n\treturn {command, escapedCommand};\n};\n\n// Remove ANSI sequences and escape control characters and newlines\nexport const escapeLines = lines => stripVTControlCharacters(lines)\n\t.split('\\n')\n\t.map(line => escapeControlCharacters(line))\n\t.join('\\n');\n\nconst escapeControlCharacters = line => line.replaceAll(SPECIAL_CHAR_REGEXP, character => escapeControlCharacter(character));\n\nconst escapeControlCharacter = character => {\n\tconst commonEscape = COMMON_ESCAPES[character];\n\tif (commonEscape !== undefined) {\n\t\treturn commonEscape;\n\t}\n\n\tconst codepoint = character.codePointAt(0);\n\tconst codepointHex = codepoint.toString(16);\n\treturn codepoint <= ASTRAL_START\n\t\t? `\\\\u${codepointHex.padStart(4, '0')}`\n\t\t: `\\\\U${codepointHex}`;\n};\n\n// Characters that would create issues when printed are escaped using the \\u or \\U notation.\n// Those include control characters and newlines.\n// The \\u and \\U notation is Bash specific, but there is no way to do this in a shell-agnostic way.\n// Some shells do not even have a way to print those characters in an escaped fashion.\n// Therefore, we prioritize printing those safely, instead of allowing those to be copy-pasted.\n// List of Unicode character categories: https://www.fileformat.info/info/unicode/category/index.htm\nconst getSpecialCharRegExp = () => {\n\ttry {\n\t\t// This throws when using Node.js without ICU support.\n\t\t// When using a RegExp literal, this would throw at parsing-time, instead of runtime.\n\t\t// eslint-disable-next-line prefer-regex-literals\n\t\treturn new RegExp('\\\\p{Separator}|\\\\p{Other}', 'gu');\n\t} catch {\n\t\t// Similar to the above RegExp, but works even when Node.js has been built without ICU support.\n\t\t// Unlike the above RegExp, it only covers whitespaces and C0/C1 control characters.\n\t\t// It does not cover some edge cases, such as Unicode reserved characters.\n\t\t// See https://github.com/sindresorhus/execa/issues/1143\n\t\t// eslint-disable-next-line no-control-regex\n\t\treturn /[\\s\\u0000-\\u001F\\u007F-\\u009F\\u00AD]/g;\n\t}\n};\n\nconst SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();\n\n// Accepted by $'...' in Bash.\n// Exclude \\a \\e \\v which are accepted in Bash but not in JavaScript (except \\v) and JSON.\nconst COMMON_ESCAPES = {\n\t' ': ' ',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t',\n};\n\n// Up until that codepoint, \\u notation can be used instead of \\U\nconst ASTRAL_START = 65_535;\n\n// Some characters are shell-specific, i.e. need to be escaped when the command is copy-pasted then run.\n// Escaping is shell-specific. We cannot know which shell is used: `process.platform` detection is not enough.\n// For example, Windows users could be using `cmd.exe`, Powershell or Bash for Windows which all use different escaping.\n// We use '...' on Unix, which is POSIX shell compliant and escape all characters but ' so this is fairly safe.\n// On Windows, we assume cmd.exe is used and escape with \"...\", which also works with Powershell.\nconst quoteString = escapedArgument => {\n\tif (NO_ESCAPE_REGEXP.test(escapedArgument)) {\n\t\treturn escapedArgument;\n\t}\n\n\treturn platform === 'win32'\n\t\t? `\"${escapedArgument.replaceAll('\"', '\"\"')}\"`\n\t\t: `'${escapedArgument.replaceAll('\\'', '\\'\\\\\\'\\'')}'`;\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w./-]+$/;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAGO,MAAM,cAAc,CAAC,UAAU;IACrC,MAAM,mBAAmB;QAAC;WAAa;KAAa;IACpD,MAAM,UAAU,iBAAiB,IAAI,CAAC;IACtC,MAAM,iBAAiB,iBACrB,GAAG,CAAC,CAAA,kBAAmB,YAAY,wBAAwB,mBAC3D,IAAI,CAAC;IACP,OAAO;QAAC;QAAS;IAAc;AAChC;AAGO,MAAM,cAAc,CAAA,QAAS,IAAA,6IAAwB,EAAC,OAC3D,KAAK,CAAC,MACN,GAAG,CAAC,CAAA,OAAQ,wBAAwB,OACpC,IAAI,CAAC;AAEP,MAAM,0BAA0B,CAAA,OAAQ,KAAK,UAAU,CAAC,qBAAqB,CAAA,YAAa,uBAAuB;AAEjH,MAAM,yBAAyB,CAAA;IAC9B,MAAM,eAAe,cAAc,CAAC,UAAU;IAC9C,IAAI,iBAAiB,WAAW;QAC/B,OAAO;IACR;IAEA,MAAM,YAAY,UAAU,WAAW,CAAC;IACxC,MAAM,eAAe,UAAU,QAAQ,CAAC;IACxC,OAAO,aAAa,eACjB,CAAC,GAAG,EAAE,aAAa,QAAQ,CAAC,GAAG,MAAM,GACrC,CAAC,GAAG,EAAE,cAAc;AACxB;AAEA,4FAA4F;AAC5F,iDAAiD;AACjD,mGAAmG;AACnG,sFAAsF;AACtF,+FAA+F;AAC/F,oGAAoG;AACpG,MAAM,uBAAuB;IAC5B,IAAI;QACH,sDAAsD;QACtD,qFAAqF;QACrF,iDAAiD;QACjD,OAAO,IAAI,OAAO,6BAA6B;IAChD,EAAE,OAAM;QACP,+FAA+F;QAC/F,oFAAoF;QACpF,0EAA0E;QAC1E,wDAAwD;QACxD,4CAA4C;QAC5C,OAAO;IACR;AACD;AAEA,MAAM,sBAAsB;AAE5B,8BAA8B;AAC9B,0FAA0F;AAC1F,MAAM,iBAAiB;IACtB,KAAK;IACL,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;AACP;AAEA,iEAAiE;AACjE,MAAM,eAAe;AAErB,wGAAwG;AACxG,8GAA8G;AAC9G,wHAAwH;AACxH,+GAA+G;AAC/G,iGAAiG;AACjG,MAAM,cAAc,CAAA;IACnB,IAAI,iBAAiB,IAAI,CAAC,kBAAkB;QAC3C,OAAO;IACR;IAEA,OAAO,uCACJ,CAAC,CAAC,EAAE,gBAAgB,UAAU,CAAC,KAAK,MAAM,CAAC,CAAC,GAC5C;AACJ;AAEA,MAAM,mBAAmB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 554, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/verbose/default.js"],"sourcesContent":["import figures from 'figures';\nimport {\n\tgray,\n\tbold,\n\tredBright,\n\tyellowBright,\n} from 'yoctocolors';\n\n// Default when `verbose` is not a function\nexport const defaultVerboseFunction = ({\n\ttype,\n\tmessage,\n\ttimestamp,\n\tpiped,\n\tcommandId,\n\tresult: {failed = false} = {},\n\toptions: {reject = true},\n}) => {\n\tconst timestampString = serializeTimestamp(timestamp);\n\tconst icon = ICONS[type]({failed, reject, piped});\n\tconst color = COLORS[type]({reject});\n\treturn `${gray(`[${timestampString}]`)} ${gray(`[${commandId}]`)} ${color(icon)} ${color(message)}`;\n};\n\n// Prepending the timestamp allows debugging the slow paths of a subprocess\nconst serializeTimestamp = timestamp => `${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;\n\nconst padField = (field, padding) => String(field).padStart(padding, '0');\n\nconst getFinalIcon = ({failed, reject}) => {\n\tif (!failed) {\n\t\treturn figures.tick;\n\t}\n\n\treturn reject ? figures.cross : figures.warning;\n};\n\nconst ICONS = {\n\tcommand: ({piped}) => piped ? '|' : '$',\n\toutput: () => ' ',\n\tipc: () => '*',\n\terror: getFinalIcon,\n\tduration: getFinalIcon,\n};\n\nconst identity = string => string;\n\nconst COLORS = {\n\tcommand: () => bold,\n\toutput: () => identity,\n\tipc: () => identity,\n\terror: ({reject}) => reject ? redBright : yellowBright,\n\tduration: () => gray,\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAQO,MAAM,yBAAyB,CAAC,EACtC,IAAI,EACJ,OAAO,EACP,SAAS,EACT,KAAK,EACL,SAAS,EACT,QAAQ,EAAC,SAAS,KAAK,EAAC,GAAG,CAAC,CAAC,EAC7B,SAAS,EAAC,SAAS,IAAI,EAAC,EACxB;IACA,MAAM,kBAAkB,mBAAmB;IAC3C,MAAM,OAAO,KAAK,CAAC,KAAK,CAAC;QAAC;QAAQ;QAAQ;IAAK;IAC/C,MAAM,QAAQ,MAAM,CAAC,KAAK,CAAC;QAAC;IAAM;IAClC,OAAO,GAAG,IAAA,2IAAI,EAAC,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC,EAAE,CAAC,EAAE,IAAA,2IAAI,EAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,MAAM,CAAC,EAAE,MAAM,UAAU;AACpG;AAEA,2EAA2E;AAC3E,MAAM,qBAAqB,CAAA,YAAa,GAAG,SAAS,UAAU,QAAQ,IAAI,GAAG,CAAC,EAAE,SAAS,UAAU,UAAU,IAAI,GAAG,CAAC,EAAE,SAAS,UAAU,UAAU,IAAI,GAAG,CAAC,EAAE,SAAS,UAAU,eAAe,IAAI,IAAI;AAExM,MAAM,WAAW,CAAC,OAAO,UAAY,OAAO,OAAO,QAAQ,CAAC,SAAS;AAErE,MAAM,eAAe,CAAC,EAAC,MAAM,EAAE,MAAM,EAAC;IACrC,IAAI,CAAC,QAAQ;QACZ,OAAO,2IAAO,CAAC,IAAI;IACpB;IAEA,OAAO,SAAS,2IAAO,CAAC,KAAK,GAAG,2IAAO,CAAC,OAAO;AAChD;AAEA,MAAM,QAAQ;IACb,SAAS,CAAC,EAAC,KAAK,EAAC,GAAK,QAAQ,MAAM;IACpC,QAAQ,IAAM;IACd,KAAK,IAAM;IACX,OAAO;IACP,UAAU;AACX;AAEA,MAAM,WAAW,CAAA,SAAU;AAE3B,MAAM,SAAS;IACd,SAAS,IAAM,2IAAI;IACnB,QAAQ,IAAM;IACd,KAAK,IAAM;IACX,OAAO,CAAC,EAAC,MAAM,EAAC,GAAK,SAAS,gJAAS,GAAG,mJAAY;IACtD,UAAU,IAAM,2IAAI;AACrB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 602, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/verbose/custom.js"],"sourcesContent":["import {getVerboseFunction} from './values.js';\n\n// Apply the `verbose` function on each line\nexport const applyVerboseOnLines = (printedLines, verboseInfo, fdNumber) => {\n\tconst verboseFunction = getVerboseFunction(verboseInfo, fdNumber);\n\treturn printedLines\n\t\t.map(({verboseLine, verboseObject}) => applyVerboseFunction(verboseLine, verboseObject, verboseFunction))\n\t\t.filter(printedLine => printedLine !== undefined)\n\t\t.map(printedLine => appendNewline(printedLine))\n\t\t.join('');\n};\n\nconst applyVerboseFunction = (verboseLine, verboseObject, verboseFunction) => {\n\tif (verboseFunction === undefined) {\n\t\treturn verboseLine;\n\t}\n\n\tconst printedLine = verboseFunction(verboseLine, verboseObject);\n\tif (typeof printedLine === 'string') {\n\t\treturn printedLine;\n\t}\n};\n\nconst appendNewline = printedLine => printedLine.endsWith('\\n')\n\t? printedLine\n\t: `${printedLine}\\n`;\n"],"names":[],"mappings":";;;;AAAA;;AAGO,MAAM,sBAAsB,CAAC,cAAc,aAAa;IAC9D,MAAM,kBAAkB,IAAA,uKAAkB,EAAC,aAAa;IACxD,OAAO,aACL,GAAG,CAAC,CAAC,EAAC,WAAW,EAAE,aAAa,EAAC,GAAK,qBAAqB,aAAa,eAAe,kBACvF,MAAM,CAAC,CAAA,cAAe,gBAAgB,WACtC,GAAG,CAAC,CAAA,cAAe,cAAc,cACjC,IAAI,CAAC;AACR;AAEA,MAAM,uBAAuB,CAAC,aAAa,eAAe;IACzD,IAAI,oBAAoB,WAAW;QAClC,OAAO;IACR;IAEA,MAAM,cAAc,gBAAgB,aAAa;IACjD,IAAI,OAAO,gBAAgB,UAAU;QACpC,OAAO;IACR;AACD;AAEA,MAAM,gBAAgB,CAAA,cAAe,YAAY,QAAQ,CAAC,QACvD,cACA,GAAG,YAAY,EAAE,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 626, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/verbose/log.js"],"sourcesContent":["import {inspect} from 'node:util';\nimport {escapeLines} from '../arguments/escape.js';\nimport {defaultVerboseFunction} from './default.js';\nimport {applyVerboseOnLines} from './custom.js';\n\n// This prints on stderr.\n// If the subprocess prints on stdout and is using `stdout: 'inherit'`,\n// there is a chance both writes will compete (introducing a race condition).\n// This means their respective order is not deterministic.\n// In particular, this means the verbose command lines might be after the start of the subprocess output.\n// Using synchronous I/O does not solve this problem.\n// However, this only seems to happen when the stdout/stderr target\n// (e.g. a terminal) is being written to by many subprocesses at once, which is unlikely in real scenarios.\nexport const verboseLog = ({type, verboseMessage, fdNumber, verboseInfo, result}) => {\n\tconst verboseObject = getVerboseObject({type, result, verboseInfo});\n\tconst printedLines = getPrintedLines(verboseMessage, verboseObject);\n\tconst finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);\n\tif (finalLines !== '') {\n\t\tconsole.warn(finalLines.slice(0, -1));\n\t}\n};\n\nconst getVerboseObject = ({\n\ttype,\n\tresult,\n\tverboseInfo: {escapedCommand, commandId, rawOptions: {piped = false, ...options}},\n}) => ({\n\ttype,\n\tescapedCommand,\n\tcommandId: `${commandId}`,\n\ttimestamp: new Date(),\n\tpiped,\n\tresult,\n\toptions,\n});\n\nconst getPrintedLines = (verboseMessage, verboseObject) => verboseMessage\n\t.split('\\n')\n\t.map(message => getPrintedLine({...verboseObject, message}));\n\nconst getPrintedLine = verboseObject => {\n\tconst verboseLine = defaultVerboseFunction(verboseObject);\n\treturn {verboseLine, verboseObject};\n};\n\n// Serialize any type to a line string, for logging\nexport const serializeVerboseMessage = message => {\n\tconst messageString = typeof message === 'string' ? message : inspect(message);\n\tconst escapedMessage = escapeLines(messageString);\n\treturn escapedMessage.replaceAll('\\t', ' '.repeat(TAB_SIZE));\n};\n\n// Same as `util.inspect()`\nconst TAB_SIZE = 2;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAUO,MAAM,aAAa,CAAC,EAAC,IAAI,EAAE,cAAc,EAAE,QAAQ,EAAE,WAAW,EAAE,MAAM,EAAC;IAC/E,MAAM,gBAAgB,iBAAiB;QAAC;QAAM;QAAQ;IAAW;IACjE,MAAM,eAAe,gBAAgB,gBAAgB;IACrD,MAAM,aAAa,IAAA,wKAAmB,EAAC,cAAc,aAAa;IAClE,IAAI,eAAe,IAAI;QACtB,QAAQ,IAAI,CAAC,WAAW,KAAK,CAAC,GAAG,CAAC;IACnC;AACD;AAEA,MAAM,mBAAmB,CAAC,EACzB,IAAI,EACJ,MAAM,EACN,aAAa,EAAC,cAAc,EAAE,SAAS,EAAE,YAAY,EAAC,QAAQ,KAAK,EAAE,GAAG,SAAQ,EAAC,EACjF,GAAK,CAAC;QACN;QACA;QACA,WAAW,GAAG,WAAW;QACzB,WAAW,IAAI;QACf;QACA;QACA;IACD,CAAC;AAED,MAAM,kBAAkB,CAAC,gBAAgB,gBAAkB,eACzD,KAAK,CAAC,MACN,GAAG,CAAC,CAAA,UAAW,eAAe;YAAC,GAAG,aAAa;YAAE;QAAO;AAE1D,MAAM,iBAAiB,CAAA;IACtB,MAAM,cAAc,IAAA,4KAAsB,EAAC;IAC3C,OAAO;QAAC;QAAa;IAAa;AACnC;AAGO,MAAM,0BAA0B,CAAA;IACtC,MAAM,gBAAgB,OAAO,YAAY,WAAW,UAAU,IAAA,4HAAO,EAAC;IACtE,MAAM,iBAAiB,IAAA,kKAAW,EAAC;IACnC,OAAO,eAAe,UAAU,CAAC,MAAM,IAAI,MAAM,CAAC;AACnD;AAEA,2BAA2B;AAC3B,MAAM,WAAW","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 683, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/verbose/start.js"],"sourcesContent":["import {isVerbose} from './values.js';\nimport {verboseLog} from './log.js';\n\n// When `verbose` is `short|full|custom`, print each command\nexport const logCommand = (escapedCommand, verboseInfo) => {\n\tif (!isVerbose(verboseInfo)) {\n\t\treturn;\n\t}\n\n\tverboseLog({\n\t\ttype: 'command',\n\t\tverboseMessage: escapedCommand,\n\t\tverboseInfo,\n\t});\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAGO,MAAM,aAAa,CAAC,gBAAgB;IAC1C,IAAI,CAAC,IAAA,8JAAS,EAAC,cAAc;QAC5B;IACD;IAEA,IAAA,4JAAU,EAAC;QACV,MAAM;QACN,gBAAgB;QAChB;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 705, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/verbose/info.js"],"sourcesContent":["import {isVerbose, VERBOSE_VALUES, isVerboseFunction} from './values.js';\n\n// Information computed before spawning, used by the `verbose` option\nexport const getVerboseInfo = (verbose, escapedCommand, rawOptions) => {\n\tvalidateVerbose(verbose);\n\tconst commandId = getCommandId(verbose);\n\treturn {\n\t\tverbose,\n\t\tescapedCommand,\n\t\tcommandId,\n\t\trawOptions,\n\t};\n};\n\nconst getCommandId = verbose => isVerbose({verbose}) ? COMMAND_ID++ : undefined;\n\n// Prepending the `pid` is useful when multiple commands print their output at the same time.\n// However, we cannot use the real PID since this is not available with `child_process.spawnSync()`.\n// Also, we cannot use the real PID if we want to print it before `child_process.spawn()` is run.\n// As a pro, it is shorter than a normal PID and never re-uses the same id.\n// As a con, it cannot be used to send signals.\nlet COMMAND_ID = 0n;\n\nconst validateVerbose = verbose => {\n\tfor (const fdVerbose of verbose) {\n\t\tif (fdVerbose === false) {\n\t\t\tthrow new TypeError('The \"verbose: false\" option was renamed to \"verbose: \\'none\\'\".');\n\t\t}\n\n\t\tif (fdVerbose === true) {\n\t\t\tthrow new TypeError('The \"verbose: true\" option was renamed to \"verbose: \\'short\\'\".');\n\t\t}\n\n\t\tif (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {\n\t\t\tconst allowedValues = VERBOSE_VALUES.map(allowedValue => `'${allowedValue}'`).join(', ');\n\t\t\tthrow new TypeError(`The \"verbose\" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);\n\t\t}\n\t}\n};\n"],"names":[],"mappings":";;;;AAAA;;AAGO,MAAM,iBAAiB,CAAC,SAAS,gBAAgB;IACvD,gBAAgB;IAChB,MAAM,YAAY,aAAa;IAC/B,OAAO;QACN;QACA;QACA;QACA;IACD;AACD;AAEA,MAAM,eAAe,CAAA,UAAW,IAAA,8JAAS,EAAC;QAAC;IAAO,KAAK,eAAe;AAEtE,6FAA6F;AAC7F,oGAAoG;AACpG,iGAAiG;AACjG,2EAA2E;AAC3E,+CAA+C;AAC/C,IAAI,aAAa,EAAE;AAEnB,MAAM,kBAAkB,CAAA;IACvB,KAAK,MAAM,aAAa,QAAS;QAChC,IAAI,cAAc,OAAO;YACxB,MAAM,IAAI,UAAU;QACrB;QAEA,IAAI,cAAc,MAAM;YACvB,MAAM,IAAI,UAAU;QACrB;QAEA,IAAI,CAAC,mKAAc,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAA,sKAAiB,EAAC,YAAY;YACzE,MAAM,gBAAgB,mKAAc,CAAC,GAAG,CAAC,CAAA,eAAgB,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC;YACnF,MAAM,IAAI,UAAU,CAAC,iCAAiC,EAAE,UAAU,sBAAsB,EAAE,cAAc,eAAe,CAAC;QACzH;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 748, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/return/duration.js"],"sourcesContent":["import {hrtime} from 'node:process';\n\n// Start counting time before spawning the subprocess\nexport const getStartTime = () => hrtime.bigint();\n\n// Compute duration after the subprocess ended.\n// Printed by the `verbose` option.\nexport const getDurationMs = startTime => Number(hrtime.bigint() - startTime) / 1e6;\n"],"names":[],"mappings":";;;;;;AAAA;;AAGO,MAAM,eAAe,IAAM,iIAAM,CAAC,MAAM;AAIxC,MAAM,gBAAgB,CAAA,YAAa,OAAO,iIAAM,CAAC,MAAM,KAAK,aAAa","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 762, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/arguments/command.js"],"sourcesContent":["import {logCommand} from '../verbose/start.js';\nimport {getVerboseInfo} from '../verbose/info.js';\nimport {getStartTime} from '../return/duration.js';\nimport {joinCommand} from './escape.js';\nimport {normalizeFdSpecificOption} from './specific.js';\n\n// Compute `result.command`, `result.escapedCommand` and `verbose`-related information\nexport const handleCommand = (filePath, rawArguments, rawOptions) => {\n\tconst startTime = getStartTime();\n\tconst {command, escapedCommand} = joinCommand(filePath, rawArguments);\n\tconst verbose = normalizeFdSpecificOption(rawOptions, 'verbose');\n\tconst verboseInfo = getVerboseInfo(verbose, escapedCommand, {...rawOptions});\n\tlogCommand(escapedCommand, verboseInfo);\n\treturn {\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\tverboseInfo,\n\t};\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAGO,MAAM,gBAAgB,CAAC,UAAU,cAAc;IACrD,MAAM,YAAY,IAAA,kKAAY;IAC9B,MAAM,EAAC,OAAO,EAAE,cAAc,EAAC,GAAG,IAAA,kKAAW,EAAC,UAAU;IACxD,MAAM,UAAU,IAAA,kLAAyB,EAAC,YAAY;IACtD,MAAM,cAAc,IAAA,iKAAc,EAAC,SAAS,gBAAgB;QAAC,GAAG,UAAU;IAAA;IAC1E,IAAA,8JAAU,EAAC,gBAAgB;IAC3B,OAAO;QACN;QACA;QACA;QACA;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 795, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/return/final-error.js"],"sourcesContent":["// When the subprocess fails, this is the error instance being returned.\n// If another error instance is being thrown, it is kept as `error.cause`.\nexport const getFinalError = (originalError, message, isSync) => {\n\tconst ErrorClass = isSync ? ExecaSyncError : ExecaError;\n\tconst options = originalError instanceof DiscardedError ? {} : {cause: originalError};\n\treturn new ErrorClass(message, options);\n};\n\n// Indicates that the error is used only to interrupt control flow, but not in the return value\nexport class DiscardedError extends Error {}\n\n// Proper way to set `error.name`: it should be inherited and non-enumerable\nconst setErrorName = (ErrorClass, value) => {\n\tObject.defineProperty(ErrorClass.prototype, 'name', {\n\t\tvalue,\n\t\twritable: true,\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t});\n\tObject.defineProperty(ErrorClass.prototype, execaErrorSymbol, {\n\t\tvalue: true,\n\t\twritable: false,\n\t\tenumerable: false,\n\t\tconfigurable: false,\n\t});\n};\n\n// Unlike `instanceof`, this works across realms\nexport const isExecaError = error => isErrorInstance(error) && execaErrorSymbol in error;\n\nconst execaErrorSymbol = Symbol('isExecaError');\n\nexport const isErrorInstance = value => Object.prototype.toString.call(value) === '[object Error]';\n\n// We use two different Error classes for async/sync methods since they have slightly different shape and types\nexport class ExecaError extends Error {}\nsetErrorName(ExecaError, ExecaError.name);\n\nexport class ExecaSyncError extends Error {}\nsetErrorName(ExecaSyncError, ExecaSyncError.name);\n"],"names":[],"mappings":"AAAA,wEAAwE;AACxE,0EAA0E;;;;;;;;;;;;;;;AACnE,MAAM,gBAAgB,CAAC,eAAe,SAAS;IACrD,MAAM,aAAa,SAAS,iBAAiB;IAC7C,MAAM,UAAU,yBAAyB,iBAAiB,CAAC,IAAI;QAAC,OAAO;IAAa;IACpF,OAAO,IAAI,WAAW,SAAS;AAChC;AAGO,MAAM,uBAAuB;AAAO;AAE3C,4EAA4E;AAC5E,MAAM,eAAe,CAAC,YAAY;IACjC,OAAO,cAAc,CAAC,WAAW,SAAS,EAAE,QAAQ;QACnD;QACA,UAAU;QACV,YAAY;QACZ,cAAc;IACf;IACA,OAAO,cAAc,CAAC,WAAW,SAAS,EAAE,kBAAkB;QAC7D,OAAO;QACP,UAAU;QACV,YAAY;QACZ,cAAc;IACf;AACD;AAGO,MAAM,eAAe,CAAA,QAAS,gBAAgB,UAAU,oBAAoB;AAEnF,MAAM,mBAAmB,OAAO;AAEzB,MAAM,kBAAkB,CAAA,QAAS,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW;AAG3E,MAAM,mBAAmB;AAAO;AACvC,aAAa,YAAY,WAAW,IAAI;AAEjC,MAAM,uBAAuB;AAAO;AAC3C,aAAa,gBAAgB,eAAe,IAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 848, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/terminate/signal.js"],"sourcesContent":["import {constants} from 'node:os';\nimport {signalsByName} from 'human-signals';\n\n// Normalize signals for comparison purpose.\n// Also validate the signal exists.\nexport const normalizeKillSignal = killSignal => {\n\tconst optionName = 'option `killSignal`';\n\tif (killSignal === 0) {\n\t\tthrow new TypeError(`Invalid ${optionName}: 0 cannot be used.`);\n\t}\n\n\treturn normalizeSignal(killSignal, optionName);\n};\n\nexport const normalizeSignalArgument = signal => signal === 0\n\t? signal\n\t: normalizeSignal(signal, '`subprocess.kill()`\\'s argument');\n\nconst normalizeSignal = (signalNameOrInteger, optionName) => {\n\tif (Number.isInteger(signalNameOrInteger)) {\n\t\treturn normalizeSignalInteger(signalNameOrInteger, optionName);\n\t}\n\n\tif (typeof signalNameOrInteger === 'string') {\n\t\treturn normalizeSignalName(signalNameOrInteger, optionName);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.\\n${getAvailableSignals()}`);\n};\n\nconst normalizeSignalInteger = (signalInteger, optionName) => {\n\tif (signalsIntegerToName.has(signalInteger)) {\n\t\treturn signalsIntegerToName.get(signalInteger);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.\\n${getAvailableSignals()}`);\n};\n\nconst getSignalsIntegerToName = () => new Map(Object.entries(constants.signals)\n\t.reverse()\n\t.map(([signalName, signalInteger]) => [signalInteger, signalName]));\n\nconst signalsIntegerToName = getSignalsIntegerToName();\n\nconst normalizeSignalName = (signalName, optionName) => {\n\tif (signalName in constants.signals) {\n\t\treturn signalName;\n\t}\n\n\tif (signalName.toUpperCase() in constants.signals) {\n\t\tthrow new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.\\n${getAvailableSignals()}`);\n};\n\nconst getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.\nAvailable signal numbers: ${getAvailableSignalIntegers()}.`;\n\nconst getAvailableSignalNames = () => Object.keys(constants.signals)\n\t.sort()\n\t.map(signalName => `'${signalName}'`)\n\t.join(', ');\n\nconst getAvailableSignalIntegers = () => [...new Set(Object.values(constants.signals)\n\t.sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))]\n\t.join(', ');\n\n// Human-friendly description of a signal\nexport const getSignalDescription = signal => signalsByName[signal].description;\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAIO,MAAM,sBAAsB,CAAA;IAClC,MAAM,aAAa;IACnB,IAAI,eAAe,GAAG;QACrB,MAAM,IAAI,UAAU,CAAC,QAAQ,EAAE,WAAW,mBAAmB,CAAC;IAC/D;IAEA,OAAO,gBAAgB,YAAY;AACpC;AAEO,MAAM,0BAA0B,CAAA,SAAU,WAAW,IACzD,SACA,gBAAgB,QAAQ;AAE3B,MAAM,kBAAkB,CAAC,qBAAqB;IAC7C,IAAI,OAAO,SAAS,CAAC,sBAAsB;QAC1C,OAAO,uBAAuB,qBAAqB;IACpD;IAEA,IAAI,OAAO,wBAAwB,UAAU;QAC5C,OAAO,oBAAoB,qBAAqB;IACjD;IAEA,MAAM,IAAI,UAAU,CAAC,QAAQ,EAAE,WAAW,CAAC,EAAE,OAAO,qBAAqB,sCAAsC,EAAE,uBAAuB;AACzI;AAEA,MAAM,yBAAyB,CAAC,eAAe;IAC9C,IAAI,qBAAqB,GAAG,CAAC,gBAAgB;QAC5C,OAAO,qBAAqB,GAAG,CAAC;IACjC;IAEA,MAAM,IAAI,UAAU,CAAC,QAAQ,EAAE,WAAW,CAAC,EAAE,cAAc,uCAAuC,EAAE,uBAAuB;AAC5H;AAEA,MAAM,0BAA0B,IAAM,IAAI,IAAI,OAAO,OAAO,CAAC,0HAAS,CAAC,OAAO,EAC5E,OAAO,GACP,GAAG,CAAC,CAAC,CAAC,YAAY,cAAc,GAAK;YAAC;YAAe;SAAW;AAElE,MAAM,uBAAuB;AAE7B,MAAM,sBAAsB,CAAC,YAAY;IACxC,IAAI,cAAc,0HAAS,CAAC,OAAO,EAAE;QACpC,OAAO;IACR;IAEA,IAAI,WAAW,WAAW,MAAM,0HAAS,CAAC,OAAO,EAAE;QAClD,MAAM,IAAI,UAAU,CAAC,QAAQ,EAAE,WAAW,EAAE,EAAE,WAAW,wBAAwB,EAAE,WAAW,WAAW,GAAG,EAAE,CAAC;IAChH;IAEA,MAAM,IAAI,UAAU,CAAC,QAAQ,EAAE,WAAW,EAAE,EAAE,WAAW,qCAAqC,EAAE,uBAAuB;AACxH;AAEA,MAAM,sBAAsB,IAAM,CAAC,wBAAwB,EAAE,0BAA0B;0BAC7D,EAAE,6BAA6B,CAAC,CAAC;AAE3D,MAAM,0BAA0B,IAAM,OAAO,IAAI,CAAC,0HAAS,CAAC,OAAO,EACjE,IAAI,GACJ,GAAG,CAAC,CAAA,aAAc,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC,EACnC,IAAI,CAAC;AAEP,MAAM,6BAA6B,IAAM;WAAI,IAAI,IAAI,OAAO,MAAM,CAAC,0HAAS,CAAC,OAAO,EAClF,IAAI,CAAC,CAAC,eAAe,mBAAqB,gBAAgB;KAAmB,CAC7E,IAAI,CAAC;AAGA,MAAM,uBAAuB,CAAA,SAAU,yKAAa,CAAC,OAAO,CAAC,WAAW","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 908, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/terminate/kill.js"],"sourcesContent":["import {setTimeout} from 'node:timers/promises';\nimport {isErrorInstance} from '../return/final-error.js';\nimport {normalizeSignalArgument} from './signal.js';\n\n// Normalize the `forceKillAfterDelay` option\nexport const normalizeForceKillAfterDelay = forceKillAfterDelay => {\n\tif (forceKillAfterDelay === false) {\n\t\treturn forceKillAfterDelay;\n\t}\n\n\tif (forceKillAfterDelay === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterDelay\\` option to be a non-negative integer, got \\`${forceKillAfterDelay}\\` (${typeof forceKillAfterDelay})`);\n\t}\n\n\treturn forceKillAfterDelay;\n};\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `subprocess.kill()` to add `forceKillAfterDelay` behavior and `.kill(error)`\nexport const subprocessKill = (\n\t{kill, options: {forceKillAfterDelay, killSignal}, onInternalError, context, controller},\n\tsignalOrError,\n\terrorArgument,\n) => {\n\tconst {signal, error} = parseKillArguments(signalOrError, errorArgument, killSignal);\n\temitKillError(error, onInternalError);\n\tconst killResult = kill(signal);\n\tsetKillTimeout({\n\t\tkill,\n\t\tsignal,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t\tkillResult,\n\t\tcontext,\n\t\tcontroller,\n\t});\n\treturn killResult;\n};\n\nconst parseKillArguments = (signalOrError, errorArgument, killSignal) => {\n\tconst [signal = killSignal, error] = isErrorInstance(signalOrError)\n\t\t? [undefined, signalOrError]\n\t\t: [signalOrError, errorArgument];\n\n\tif (typeof signal !== 'string' && !Number.isInteger(signal)) {\n\t\tthrow new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);\n\t}\n\n\tif (error !== undefined && !isErrorInstance(error)) {\n\t\tthrow new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);\n\t}\n\n\treturn {signal: normalizeSignalArgument(signal), error};\n};\n\n// Fails right away when calling `subprocess.kill(error)`.\n// Does not wait for actual signal termination.\n// Uses a deferred promise instead of the `error` event on the subprocess, as this is less intrusive.\nconst emitKillError = (error, onInternalError) => {\n\tif (error !== undefined) {\n\t\tonInternalError.reject(error);\n\t}\n};\n\nconst setKillTimeout = async ({kill, signal, forceKillAfterDelay, killSignal, killResult, context, controller}) => {\n\tif (signal === killSignal && killResult) {\n\t\tkillOnTimeout({\n\t\t\tkill,\n\t\t\tforceKillAfterDelay,\n\t\t\tcontext,\n\t\t\tcontrollerSignal: controller.signal,\n\t\t});\n\t}\n};\n\n// Forcefully terminate a subprocess after a timeout\nexport const killOnTimeout = async ({kill, forceKillAfterDelay, context, controllerSignal}) => {\n\tif (forceKillAfterDelay === false) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait setTimeout(forceKillAfterDelay, undefined, {signal: controllerSignal});\n\t\tif (kill('SIGKILL')) {\n\t\t\tcontext.isForcefullyTerminated ??= true;\n\t\t}\n\t} catch {}\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAGO,MAAM,+BAA+B,CAAA;IAC3C,IAAI,wBAAwB,OAAO;QAClC,OAAO;IACR;IAEA,IAAI,wBAAwB,MAAM;QACjC,OAAO;IACR;IAEA,IAAI,CAAC,OAAO,QAAQ,CAAC,wBAAwB,sBAAsB,GAAG;QACrE,MAAM,IAAI,UAAU,CAAC,gFAAgF,EAAE,oBAAoB,IAAI,EAAE,OAAO,oBAAoB,CAAC,CAAC;IAC/J;IAEA,OAAO;AACR;AAEA,MAAM,6BAA6B,OAAO;AAGnC,MAAM,iBAAiB,CAC7B,EAAC,IAAI,EAAE,SAAS,EAAC,mBAAmB,EAAE,UAAU,EAAC,EAAE,eAAe,EAAE,OAAO,EAAE,UAAU,EAAC,EACxF,eACA;IAEA,MAAM,EAAC,MAAM,EAAE,KAAK,EAAC,GAAG,mBAAmB,eAAe,eAAe;IACzE,cAAc,OAAO;IACrB,MAAM,aAAa,KAAK;IACxB,eAAe;QACd;QACA;QACA;QACA;QACA;QACA;QACA;IACD;IACA,OAAO;AACR;AAEA,MAAM,qBAAqB,CAAC,eAAe,eAAe;IACzD,MAAM,CAAC,SAAS,UAAU,EAAE,MAAM,GAAG,IAAA,2KAAe,EAAC,iBAClD;QAAC;QAAW;KAAc,GAC1B;QAAC;QAAe;KAAc;IAEjC,IAAI,OAAO,WAAW,YAAY,CAAC,OAAO,SAAS,CAAC,SAAS;QAC5D,MAAM,IAAI,UAAU,CAAC,8EAA8E,EAAE,OAAO,SAAS;IACtH;IAEA,IAAI,UAAU,aAAa,CAAC,IAAA,2KAAe,EAAC,QAAQ;QACnD,MAAM,IAAI,UAAU,CAAC,6EAA6E,EAAE,OAAO;IAC5G;IAEA,OAAO;QAAC,QAAQ,IAAA,8KAAuB,EAAC;QAAS;IAAK;AACvD;AAEA,0DAA0D;AAC1D,+CAA+C;AAC/C,qGAAqG;AACrG,MAAM,gBAAgB,CAAC,OAAO;IAC7B,IAAI,UAAU,WAAW;QACxB,gBAAgB,MAAM,CAAC;IACxB;AACD;AAEA,MAAM,iBAAiB,OAAO,EAAC,IAAI,EAAE,MAAM,EAAE,mBAAmB,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,UAAU,EAAC;IAC7G,IAAI,WAAW,cAAc,YAAY;QACxC,cAAc;YACb;YACA;YACA;YACA,kBAAkB,WAAW,MAAM;QACpC;IACD;AACD;AAGO,MAAM,gBAAgB,OAAO,EAAC,IAAI,EAAE,mBAAmB,EAAE,OAAO,EAAE,gBAAgB,EAAC;IACzF,IAAI,wBAAwB,OAAO;QAClC;IACD;IAEA,IAAI;QACH,MAAM,IAAA,2JAAU,EAAC,qBAAqB,WAAW;YAAC,QAAQ;QAAgB;QAC1E,IAAI,KAAK,YAAY;YACpB,QAAQ,sBAAsB,KAAK;QACpC;IACD,EAAE,OAAM,CAAC;AACV","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1004, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/utils/abort-signal.js"],"sourcesContent":["import {once} from 'node:events';\n\n// Combines `util.aborted()` and `events.addAbortListener()`: promise-based and cleaned up with a stop signal\nexport const onAbortedSignal = async (mainSignal, stopSignal) => {\n\tif (!mainSignal.aborted) {\n\t\tawait once(mainSignal, 'abort', {signal: stopSignal});\n\t}\n};\n"],"names":[],"mappings":";;;;AAAA;;AAGO,MAAM,kBAAkB,OAAO,YAAY;IACjD,IAAI,CAAC,WAAW,OAAO,EAAE;QACxB,MAAM,IAAA,6HAAI,EAAC,YAAY,SAAS;YAAC,QAAQ;QAAU;IACpD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1021, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/terminate/cancel.js"],"sourcesContent":["import {onAbortedSignal} from '../utils/abort-signal.js';\n\n// Validate the `cancelSignal` option\nexport const validateCancelSignal = ({cancelSignal}) => {\n\tif (cancelSignal !== undefined && Object.prototype.toString.call(cancelSignal) !== '[object AbortSignal]') {\n\t\tthrow new Error(`The \\`cancelSignal\\` option must be an AbortSignal: ${String(cancelSignal)}`);\n\t}\n};\n\n// Terminate the subprocess when aborting the `cancelSignal` option and `gracefulSignal` is `false`\nexport const throwOnCancel = ({subprocess, cancelSignal, gracefulCancel, context, controller}) => cancelSignal === undefined || gracefulCancel\n\t? []\n\t: [terminateOnCancel(subprocess, cancelSignal, context, controller)];\n\nconst terminateOnCancel = async (subprocess, cancelSignal, context, {signal}) => {\n\tawait onAbortedSignal(cancelSignal, signal);\n\tcontext.terminationReason ??= 'cancel';\n\tsubprocess.kill();\n\tthrow cancelSignal.reason;\n};\n"],"names":[],"mappings":";;;;;;AAAA;;AAGO,MAAM,uBAAuB,CAAC,EAAC,YAAY,EAAC;IAClD,IAAI,iBAAiB,aAAa,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,kBAAkB,wBAAwB;QAC1G,MAAM,IAAI,MAAM,CAAC,oDAAoD,EAAE,OAAO,eAAe;IAC9F;AACD;AAGO,MAAM,gBAAgB,CAAC,EAAC,UAAU,EAAE,YAAY,EAAE,cAAc,EAAE,OAAO,EAAE,UAAU,EAAC,GAAK,iBAAiB,aAAa,iBAC7H,EAAE,GACF;QAAC,kBAAkB,YAAY,cAAc,SAAS;KAAY;AAErE,MAAM,oBAAoB,OAAO,YAAY,cAAc,SAAS,EAAC,MAAM,EAAC;IAC3E,MAAM,IAAA,2KAAe,EAAC,cAAc;IACpC,QAAQ,iBAAiB,KAAK;IAC9B,WAAW,IAAI;IACf,MAAM,aAAa,MAAM;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1047, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/validation.js"],"sourcesContent":["// Validate the IPC channel is connected before receiving/sending messages\nexport const validateIpcMethod = ({methodName, isSubprocess, ipc, isConnected}) => {\n\tvalidateIpcOption(methodName, isSubprocess, ipc);\n\tvalidateConnection(methodName, isSubprocess, isConnected);\n};\n\n// Better error message when forgetting to set `ipc: true` and using the IPC methods\nconst validateIpcOption = (methodName, isSubprocess, ipc) => {\n\tif (!ipc) {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \\`ipc\\` option is \\`true\\`.`);\n\t}\n};\n\n// Better error message when one process does not send/receive messages once the other process has disconnected.\n// This also makes it clear that any buffered messages are lost once either process has disconnected.\n// Also when aborting `cancelSignal` after disconnecting the IPC.\nexport const validateConnection = (methodName, isSubprocess, isConnected) => {\n\tif (!isConnected) {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);\n\t}\n};\n\n// When `getOneMessage()` could not complete due to an early disconnection\nexport const throwOnEarlyDisconnect = isSubprocess => {\n\tthrow new Error(`${getMethodName('getOneMessage', isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);\n};\n\n// When both processes use `sendMessage()` with `strict` at the same time\nexport const throwOnStrictDeadlockError = isSubprocess => {\n\tthrow new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.\nThis can be fixed by both sending a message and listening to incoming messages at the same time:\n\nconst [receivedMessage] = await Promise.all([\n\t${getMethodName('getOneMessage', isSubprocess)},\n\t${getMethodName('sendMessage', isSubprocess, 'message, {strict: true}')},\n]);`);\n};\n\n// When the other process used `strict` but the current process had I/O error calling `sendMessage()` for the response\nexport const getStrictResponseError = (error, isSubprocess) => new Error(`${getMethodName('sendMessage', isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, {cause: error});\n\n// When using `strict` but the other process was not listening for messages\nexport const throwOnMissingStrict = isSubprocess => {\n\tthrow new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);\n};\n\n// When using `strict` but the other process disconnected before receiving the message\nexport const throwOnStrictDisconnect = isSubprocess => {\n\tthrow new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);\n};\n\n// When the current process disconnects while the subprocess is listening to `cancelSignal`\nexport const getAbortDisconnectError = () => new Error(`\\`cancelSignal\\` aborted: the ${getOtherProcessName(true)} disconnected.`);\n\n// When the subprocess uses `cancelSignal` but not the current process\nexport const throwOnMissingParent = () => {\n\tthrow new Error('`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.');\n};\n\n// EPIPE can happen when sending a message to a subprocess that is closing but has not disconnected yet\nexport const handleEpipeError = ({error, methodName, isSubprocess}) => {\n\tif (error.code === 'EPIPE') {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, {cause: error});\n\t}\n};\n\n// Better error message when sending messages which cannot be serialized.\n// Works with both `serialization: 'advanced'` and `serialization: 'json'`.\nexport const handleSerializationError = ({error, methodName, isSubprocess, message}) => {\n\tif (isSerializationError(error)) {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, {cause: error});\n\t}\n};\n\nconst isSerializationError = ({code, message}) => SERIALIZATION_ERROR_CODES.has(code)\n\t|| SERIALIZATION_ERROR_MESSAGES.some(serializationErrorMessage => message.includes(serializationErrorMessage));\n\n// `error.code` set by Node.js when it failed to serialize the message\nconst SERIALIZATION_ERROR_CODES = new Set([\n\t// Message is `undefined`\n\t'ERR_MISSING_ARGS',\n\t// Message is a function, a bigint, a symbol\n\t'ERR_INVALID_ARG_TYPE',\n]);\n\n// `error.message` set by Node.js when it failed to serialize the message\nconst SERIALIZATION_ERROR_MESSAGES = [\n\t// Message is a promise or a proxy, with `serialization: 'advanced'`\n\t'could not be cloned',\n\t// Message has cycles, with `serialization: 'json'`\n\t'circular structure',\n\t// Message has cycles inside toJSON(), with `serialization: 'json'`\n\t'call stack size exceeded',\n];\n\nconst getMethodName = (methodName, isSubprocess, parameters = '') => methodName === 'cancelSignal'\n\t? '`cancelSignal`\\'s `controller.abort()`'\n\t: `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;\n\nconst getNamespaceName = isSubprocess => isSubprocess ? '' : 'subprocess.';\n\nconst getOtherProcessName = isSubprocess => isSubprocess ? 'parent process' : 'subprocess';\n\n// When any error arises, we disconnect the IPC.\n// Otherwise, it is likely that one of the processes will stop sending/receiving messages.\n// This would leave the other process hanging.\nexport const disconnect = anyProcess => {\n\tif (anyProcess.connected) {\n\t\tanyProcess.disconnect();\n\t}\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1157, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/utils/deferred.js"],"sourcesContent":["export const createDeferred = () => {\n\tconst methods = {};\n\tconst promise = new Promise((resolve, reject) => {\n\t\tObject.assign(methods, {resolve, reject});\n\t});\n\treturn Object.assign(promise, methods);\n};\n"],"names":[],"mappings":";;;;AAAO,MAAM,iBAAiB;IAC7B,MAAM,UAAU,CAAC;IACjB,MAAM,UAAU,IAAI,QAAQ,CAAC,SAAS;QACrC,OAAO,MAAM,CAAC,SAAS;YAAC;YAAS;QAAM;IACxC;IACA,OAAO,OAAO,MAAM,CAAC,SAAS;AAC/B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1175, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/arguments/fd-options.js"],"sourcesContent":["import {parseFd} from './specific.js';\n\n// Retrieve stream targeted by the `to` option\nexport const getToStream = (destination, to = 'stdin') => {\n\tconst isWritable = true;\n\tconst {options, fileDescriptors} = SUBPROCESS_OPTIONS.get(destination);\n\tconst fdNumber = getFdNumber(fileDescriptors, to, isWritable);\n\tconst destinationStream = destination.stdio[fdNumber];\n\n\tif (destinationStream === null) {\n\t\tthrow new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));\n\t}\n\n\treturn destinationStream;\n};\n\n// Retrieve stream targeted by the `from` option\nexport const getFromStream = (source, from = 'stdout') => {\n\tconst isWritable = false;\n\tconst {options, fileDescriptors} = SUBPROCESS_OPTIONS.get(source);\n\tconst fdNumber = getFdNumber(fileDescriptors, from, isWritable);\n\tconst sourceStream = fdNumber === 'all' ? source.all : source.stdio[fdNumber];\n\n\tif (sourceStream === null || sourceStream === undefined) {\n\t\tthrow new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));\n\t}\n\n\treturn sourceStream;\n};\n\n// Keeps track of the options passed to each Execa call\nexport const SUBPROCESS_OPTIONS = new WeakMap();\n\nconst getFdNumber = (fileDescriptors, fdName, isWritable) => {\n\tconst fdNumber = parseFdNumber(fdName, isWritable);\n\tvalidateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);\n\treturn fdNumber;\n};\n\nconst parseFdNumber = (fdName, isWritable) => {\n\tconst fdNumber = parseFd(fdName);\n\tif (fdNumber !== undefined) {\n\t\treturn fdNumber;\n\t}\n\n\tconst {validOptions, defaultValue} = isWritable\n\t\t? {validOptions: '\"stdin\"', defaultValue: 'stdin'}\n\t\t: {validOptions: '\"stdout\", \"stderr\", \"all\"', defaultValue: 'stdout'};\n\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be \"${fdName}\".\nIt must be ${validOptions} or \"fd3\", \"fd4\" (and so on).\nIt is optional and defaults to \"${defaultValue}\".`);\n};\n\nconst validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors) => {\n\tconst fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];\n\tif (fileDescriptor === undefined) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. That file descriptor does not exist.\nPlease set the \"stdio\" option to ensure that file descriptor exists.`);\n\t}\n\n\tif (fileDescriptor.direction === 'input' && !isWritable) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. It must be a readable stream, not writable.`);\n\t}\n\n\tif (fileDescriptor.direction !== 'input' && isWritable) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. It must be a writable stream, not readable.`);\n\t}\n};\n\nconst getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable) => {\n\tif (fdNumber === 'all' && !options.all) {\n\t\treturn 'The \"all\" option must be true to use \"from: \\'all\\'\".';\n\t}\n\n\tconst {optionName, optionValue} = getInvalidStdioOption(fdNumber, options);\n\treturn `The \"${optionName}: ${serializeOptionValue(optionValue)}\" option is incompatible with using \"${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}\".\nPlease set this option with \"pipe\" instead.`;\n};\n\nconst getInvalidStdioOption = (fdNumber, {stdin, stdout, stderr, stdio}) => {\n\tconst usedDescriptor = getUsedDescriptor(fdNumber);\n\n\tif (usedDescriptor === 0 && stdin !== undefined) {\n\t\treturn {optionName: 'stdin', optionValue: stdin};\n\t}\n\n\tif (usedDescriptor === 1 && stdout !== undefined) {\n\t\treturn {optionName: 'stdout', optionValue: stdout};\n\t}\n\n\tif (usedDescriptor === 2 && stderr !== undefined) {\n\t\treturn {optionName: 'stderr', optionValue: stderr};\n\t}\n\n\treturn {optionName: `stdio[${usedDescriptor}]`, optionValue: stdio[usedDescriptor]};\n};\n\nconst getUsedDescriptor = fdNumber => fdNumber === 'all' ? 1 : fdNumber;\n\nconst getOptionName = isWritable => isWritable ? 'to' : 'from';\n\nexport const serializeOptionValue = value => {\n\tif (typeof value === 'string') {\n\t\treturn `'${value}'`;\n\t}\n\n\treturn typeof value === 'number' ? `${value}` : 'Stream';\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1287, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/utils/max-listeners.js"],"sourcesContent":["import {addAbortListener} from 'node:events';\n\n// Temporarily increase the maximum number of listeners on an eventEmitter\nexport const incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal) => {\n\tconst maxListeners = eventEmitter.getMaxListeners();\n\tif (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {\n\t\treturn;\n\t}\n\n\teventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);\n\taddAbortListener(signal, () => {\n\t\teventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);\n\t});\n};\n"],"names":[],"mappings":";;;;AAAA;;AAGO,MAAM,wBAAwB,CAAC,cAAc,uBAAuB;IAC1E,MAAM,eAAe,aAAa,eAAe;IACjD,IAAI,iBAAiB,KAAK,iBAAiB,OAAO,iBAAiB,EAAE;QACpE;IACD;IAEA,aAAa,eAAe,CAAC,eAAe;IAC5C,IAAA,yIAAgB,EAAC,QAAQ;QACxB,aAAa,eAAe,CAAC,aAAa,eAAe,KAAK;IAC/D;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1307, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/reference.js"],"sourcesContent":["// By default, Node.js keeps the subprocess alive while it has a `message` or `disconnect` listener.\n// We replicate the same logic for the events that we proxy.\n// This ensures the subprocess is kept alive while `getOneMessage()` and `getEachMessage()` are ongoing.\n// This is not a problem with `sendMessage()` since Node.js handles that method automatically.\n// We do not use `anyProcess.channel.ref()` since this would prevent the automatic `.channel.refCounted()` Node.js is doing.\n// We keep a reference to `anyProcess.channel` since it might be `null` while `getOneMessage()` or `getEachMessage()` is still processing debounced messages.\n// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L547\nexport const addReference = (channel, reference) => {\n\tif (reference) {\n\t\taddReferenceCount(channel);\n\t}\n};\n\nconst addReferenceCount = channel => {\n\tchannel.refCounted();\n};\n\nexport const removeReference = (channel, reference) => {\n\tif (reference) {\n\t\tremoveReferenceCount(channel);\n\t}\n};\n\nconst removeReferenceCount = channel => {\n\tchannel.unrefCounted();\n};\n\n// To proxy events, we setup some global listeners on the `message` and `disconnect` events.\n// Those should not keep the subprocess alive, so we remove the automatic counting that Node.js is doing.\n// See https://github.com/nodejs/node/blob/1b965270a9c273d4cf70e8808e9d28b9ada7844f/lib/child_process.js#L180\nexport const undoAddedReferences = (channel, isSubprocess) => {\n\tif (isSubprocess) {\n\t\tremoveReferenceCount(channel);\n\t\tremoveReferenceCount(channel);\n\t}\n};\n\n// Reverse it during `disconnect`\nexport const redoAddedReferences = (channel, isSubprocess) => {\n\tif (isSubprocess) {\n\t\taddReferenceCount(channel);\n\t\taddReferenceCount(channel);\n\t}\n};\n"],"names":[],"mappings":"AAAA,oGAAoG;AACpG,4DAA4D;AAC5D,wGAAwG;AACxG,8FAA8F;AAC9F,4HAA4H;AAC5H,6JAA6J;AAC7J,sHAAsH;;;;;;;;;;;AAC/G,MAAM,eAAe,CAAC,SAAS;IACrC,IAAI,WAAW;QACd,kBAAkB;IACnB;AACD;AAEA,MAAM,oBAAoB,CAAA;IACzB,QAAQ,UAAU;AACnB;AAEO,MAAM,kBAAkB,CAAC,SAAS;IACxC,IAAI,WAAW;QACd,qBAAqB;IACtB;AACD;AAEA,MAAM,uBAAuB,CAAA;IAC5B,QAAQ,YAAY;AACrB;AAKO,MAAM,sBAAsB,CAAC,SAAS;IAC5C,IAAI,cAAc;QACjB,qBAAqB;QACrB,qBAAqB;IACtB;AACD;AAGO,MAAM,sBAAsB,CAAC,SAAS;IAC5C,IAAI,cAAc;QACjB,kBAAkB;QAClB,kBAAkB;IACnB;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1356, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/incoming.js"],"sourcesContent":["import {once} from 'node:events';\nimport {scheduler} from 'node:timers/promises';\nimport {waitForOutgoingMessages} from './outgoing.js';\nimport {redoAddedReferences} from './reference.js';\nimport {handleStrictRequest, handleStrictResponse} from './strict.js';\nimport {handleAbort, abortOnDisconnect} from './graceful.js';\n\n// By default, Node.js buffers `message` events.\n//  - Buffering happens when there is a `message` event is emitted but there is no handler.\n//  - As soon as a `message` event handler is set, all buffered `message` events are emitted, emptying the buffer.\n//  - This happens both in the current process and the subprocess.\n//  - See https://github.com/nodejs/node/blob/501546e8f37059cd577041e23941b640d0d4d406/lib/internal/child_process.js#L719\n// This is helpful. Notably, this allows sending messages to a subprocess that's still initializing.\n// However, it has several problems.\n//  - This works with `events.on()` but not `events.once()` since all buffered messages are emitted at once.\n//    For example, users cannot call `await getOneMessage()`/`getEachMessage()` multiple times in a row.\n//  - When a user intentionally starts listening to `message` at a specific point in time, past `message` events are replayed, which might be unexpected.\n//  - Buffering is unlimited, which might lead to an out-of-memory crash.\n//  - This does not work well with multiple consumers.\n//    For example, Execa consumes events with both `result.ipcOutput` and manual IPC calls like `getOneMessage()`.\n//    Since `result.ipcOutput` reads all incoming messages, no buffering happens for manual IPC calls.\n//  - Forgetting to setup a `message` listener, or setting it up too late, is a programming mistake.\n//    The default behavior does not allow users to realize they made that mistake.\n// To solve those problems, instead of buffering messages, we debounce them.\n// The `message` event so it is emitted at most once per macrotask.\nexport const onMessage = async ({anyProcess, channel, isSubprocess, ipcEmitter}, wrappedMessage) => {\n\tif (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) {\n\t\treturn;\n\t}\n\n\tif (!INCOMING_MESSAGES.has(anyProcess)) {\n\t\tINCOMING_MESSAGES.set(anyProcess, []);\n\t}\n\n\tconst incomingMessages = INCOMING_MESSAGES.get(anyProcess);\n\tincomingMessages.push(wrappedMessage);\n\n\tif (incomingMessages.length > 1) {\n\t\treturn;\n\t}\n\n\twhile (incomingMessages.length > 0) {\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait scheduler.yield();\n\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tconst message = await handleStrictRequest({\n\t\t\twrappedMessage: incomingMessages[0],\n\t\t\tanyProcess,\n\t\t\tchannel,\n\t\t\tisSubprocess,\n\t\t\tipcEmitter,\n\t\t});\n\n\t\tincomingMessages.shift();\n\t\tipcEmitter.emit('message', message);\n\t\tipcEmitter.emit('message:done');\n\t}\n};\n\n// If the `message` event is currently debounced, the `disconnect` event must wait for it\nexport const onDisconnect = async ({anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage}) => {\n\tabortOnDisconnect();\n\n\tconst incomingMessages = INCOMING_MESSAGES.get(anyProcess);\n\twhile (incomingMessages?.length > 0) {\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait once(ipcEmitter, 'message:done');\n\t}\n\n\tanyProcess.removeListener('message', boundOnMessage);\n\tredoAddedReferences(channel, isSubprocess);\n\tipcEmitter.connected = false;\n\tipcEmitter.emit('disconnect');\n};\n\nconst INCOMING_MESSAGES = new WeakMap();\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAoBO,MAAM,YAAY,OAAO,EAAC,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,UAAU,EAAC,EAAE;IAChF,IAAI,IAAA,qKAAoB,EAAC,mBAAmB,IAAA,8JAAW,EAAC,iBAAiB;QACxE;IACD;IAEA,IAAI,CAAC,kBAAkB,GAAG,CAAC,aAAa;QACvC,kBAAkB,GAAG,CAAC,YAAY,EAAE;IACrC;IAEA,MAAM,mBAAmB,kBAAkB,GAAG,CAAC;IAC/C,iBAAiB,IAAI,CAAC;IAEtB,IAAI,iBAAiB,MAAM,GAAG,GAAG;QAChC;IACD;IAEA,MAAO,iBAAiB,MAAM,GAAG,EAAG;QACnC,4CAA4C;QAC5C,MAAM,IAAA,0KAAuB,EAAC,YAAY,YAAY;QACtD,4CAA4C;QAC5C,MAAM,0JAAS,CAAC,KAAK;QAErB,4CAA4C;QAC5C,MAAM,UAAU,MAAM,IAAA,oKAAmB,EAAC;YACzC,gBAAgB,gBAAgB,CAAC,EAAE;YACnC;YACA;YACA;YACA;QACD;QAEA,iBAAiB,KAAK;QACtB,WAAW,IAAI,CAAC,WAAW;QAC3B,WAAW,IAAI,CAAC;IACjB;AACD;AAGO,MAAM,eAAe,OAAO,EAAC,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,UAAU,EAAE,cAAc,EAAC;IACjG,IAAA,oKAAiB;IAEjB,MAAM,mBAAmB,kBAAkB,GAAG,CAAC;IAC/C,MAAO,kBAAkB,SAAS,EAAG;QACpC,4CAA4C;QAC5C,MAAM,IAAA,6HAAI,EAAC,YAAY;IACxB;IAEA,WAAW,cAAc,CAAC,WAAW;IACrC,IAAA,uKAAmB,EAAC,SAAS;IAC7B,WAAW,SAAS,GAAG;IACvB,WAAW,IAAI,CAAC;AACjB;AAEA,MAAM,oBAAoB,IAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1421, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/forward.js"],"sourcesContent":["import {EventEmitter} from 'node:events';\nimport {onMessage, onDisconnect} from './incoming.js';\nimport {undoAddedReferences} from './reference.js';\n\n// Forward the `message` and `disconnect` events from the process and subprocess to a proxy emitter.\n// This prevents the `error` event from stopping IPC.\n// This also allows debouncing the `message` event.\nexport const getIpcEmitter = (anyProcess, channel, isSubprocess) => {\n\tif (IPC_EMITTERS.has(anyProcess)) {\n\t\treturn IPC_EMITTERS.get(anyProcess);\n\t}\n\n\t// Use an `EventEmitter`, like the `process` that is being proxied\n\t// eslint-disable-next-line unicorn/prefer-event-target\n\tconst ipcEmitter = new EventEmitter();\n\tipcEmitter.connected = true;\n\tIPC_EMITTERS.set(anyProcess, ipcEmitter);\n\tforwardEvents({\n\t\tipcEmitter,\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t});\n\treturn ipcEmitter;\n};\n\nconst IPC_EMITTERS = new WeakMap();\n\n// The `message` and `disconnect` events are buffered in the subprocess until the first listener is setup.\n// However, unbuffering happens after one tick, so this give enough time for the caller to setup the listener on the proxy emitter first.\n// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L721\nconst forwardEvents = ({ipcEmitter, anyProcess, channel, isSubprocess}) => {\n\tconst boundOnMessage = onMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tipcEmitter,\n\t});\n\tanyProcess.on('message', boundOnMessage);\n\tanyProcess.once('disconnect', onDisconnect.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tipcEmitter,\n\t\tboundOnMessage,\n\t}));\n\tundoAddedReferences(channel, isSubprocess);\n};\n\n// Check whether there might still be some `message` events to receive\nexport const isConnected = anyProcess => {\n\tconst ipcEmitter = IPC_EMITTERS.get(anyProcess);\n\treturn ipcEmitter === undefined\n\t\t? anyProcess.channel !== null\n\t\t: ipcEmitter.connected;\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAKO,MAAM,gBAAgB,CAAC,YAAY,SAAS;IAClD,IAAI,aAAa,GAAG,CAAC,aAAa;QACjC,OAAO,aAAa,GAAG,CAAC;IACzB;IAEA,kEAAkE;IAClE,uDAAuD;IACvD,MAAM,aAAa,IAAI,qIAAY;IACnC,WAAW,SAAS,GAAG;IACvB,aAAa,GAAG,CAAC,YAAY;IAC7B,cAAc;QACb;QACA;QACA;QACA;IACD;IACA,OAAO;AACR;AAEA,MAAM,eAAe,IAAI;AAEzB,0GAA0G;AAC1G,yIAAyI;AACzI,sHAAsH;AACtH,MAAM,gBAAgB,CAAC,EAAC,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,YAAY,EAAC;IACrE,MAAM,iBAAiB,4JAAS,CAAC,IAAI,CAAC,WAAW;QAChD;QACA;QACA;QACA;IACD;IACA,WAAW,EAAE,CAAC,WAAW;IACzB,WAAW,IAAI,CAAC,cAAc,+JAAY,CAAC,IAAI,CAAC,WAAW;QAC1D;QACA;QACA;QACA;QACA;IACD;IACA,IAAA,uKAAmB,EAAC,SAAS;AAC9B;AAGO,MAAM,cAAc,CAAA;IAC1B,MAAM,aAAa,aAAa,GAAG,CAAC;IACpC,OAAO,eAAe,YACnB,WAAW,OAAO,KAAK,OACvB,WAAW,SAAS;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1479, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/strict.js"],"sourcesContent":["import {once} from 'node:events';\nimport {createDeferred} from '../utils/deferred.js';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {sendMessage} from './send.js';\nimport {throwOnMissingStrict, throwOnStrictDisconnect, throwOnStrictDeadlockError} from './validation.js';\nimport {getIpcEmitter} from './forward.js';\nimport {hasMessageListeners} from './outgoing.js';\n\n// When using the `strict` option, wrap the message with metadata during `sendMessage()`\nexport const handleSendStrict = ({anyProcess, channel, isSubprocess, message, strict}) => {\n\tif (!strict) {\n\t\treturn message;\n\t}\n\n\tconst ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);\n\tconst hasListeners = hasMessageListeners(anyProcess, ipcEmitter);\n\treturn {\n\t\tid: count++,\n\t\ttype: REQUEST_TYPE,\n\t\tmessage,\n\t\thasListeners,\n\t};\n};\n\nlet count = 0n;\n\n// Handles when both processes are calling `sendMessage()` with `strict` at the same time.\n// If neither process is listening, this would create a deadlock. We detect it and throw.\nexport const validateStrictDeadlock = (outgoingMessages, wrappedMessage) => {\n\tif (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) {\n\t\treturn;\n\t}\n\n\tfor (const {id} of outgoingMessages) {\n\t\tif (id !== undefined) {\n\t\t\tSTRICT_RESPONSES[id].resolve({isDeadlock: true, hasListeners: false});\n\t\t}\n\t}\n};\n\n// The other process then sends the acknowledgment back as a response\nexport const handleStrictRequest = async ({wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter}) => {\n\tif (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) {\n\t\treturn wrappedMessage;\n\t}\n\n\tconst {id, message} = wrappedMessage;\n\tconst response = {id, type: RESPONSE_TYPE, message: hasMessageListeners(anyProcess, ipcEmitter)};\n\n\ttry {\n\t\tawait sendMessage({\n\t\t\tanyProcess,\n\t\t\tchannel,\n\t\t\tisSubprocess,\n\t\t\tipc: true,\n\t\t}, response);\n\t} catch (error) {\n\t\tipcEmitter.emit('strict:error', error);\n\t}\n\n\treturn message;\n};\n\n// Reception of the acknowledgment response\nexport const handleStrictResponse = wrappedMessage => {\n\tif (wrappedMessage?.type !== RESPONSE_TYPE) {\n\t\treturn false;\n\t}\n\n\tconst {id, message: hasListeners} = wrappedMessage;\n\tSTRICT_RESPONSES[id]?.resolve({isDeadlock: false, hasListeners});\n\treturn true;\n};\n\n// Wait for the other process to receive the message from `sendMessage()`\nexport const waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess) => {\n\tif (wrappedMessage?.type !== REQUEST_TYPE) {\n\t\treturn;\n\t}\n\n\tconst deferred = createDeferred();\n\tSTRICT_RESPONSES[wrappedMessage.id] = deferred;\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tconst {isDeadlock, hasListeners} = await Promise.race([\n\t\t\tdeferred,\n\t\t\tthrowOnDisconnect(anyProcess, isSubprocess, controller),\n\t\t]);\n\n\t\tif (isDeadlock) {\n\t\t\tthrowOnStrictDeadlockError(isSubprocess);\n\t\t}\n\n\t\tif (!hasListeners) {\n\t\t\tthrowOnMissingStrict(isSubprocess);\n\t\t}\n\t} finally {\n\t\tcontroller.abort();\n\t\tdelete STRICT_RESPONSES[wrappedMessage.id];\n\t}\n};\n\nconst STRICT_RESPONSES = {};\n\nconst throwOnDisconnect = async (anyProcess, isSubprocess, {signal}) => {\n\tincrementMaxListeners(anyProcess, 1, signal);\n\tawait once(anyProcess, 'disconnect', {signal});\n\tthrowOnStrictDisconnect(isSubprocess);\n};\n\nconst REQUEST_TYPE = 'execa:ipc:request';\nconst RESPONSE_TYPE = 'execa:ipc:response';\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAGO,MAAM,mBAAmB,CAAC,EAAC,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,OAAO,EAAE,MAAM,EAAC;IACpF,IAAI,CAAC,QAAQ;QACZ,OAAO;IACR;IAEA,MAAM,aAAa,IAAA,+JAAa,EAAC,YAAY,SAAS;IACtD,MAAM,eAAe,IAAA,sKAAmB,EAAC,YAAY;IACrD,OAAO;QACN,IAAI;QACJ,MAAM;QACN;QACA;IACD;AACD;AAEA,IAAI,QAAQ,EAAE;AAIP,MAAM,yBAAyB,CAAC,kBAAkB;IACxD,IAAI,gBAAgB,SAAS,gBAAgB,eAAe,YAAY,EAAE;QACzE;IACD;IAEA,KAAK,MAAM,EAAC,EAAE,EAAC,IAAI,iBAAkB;QACpC,IAAI,OAAO,WAAW;YACrB,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC;gBAAC,YAAY;gBAAM,cAAc;YAAK;QACpE;IACD;AACD;AAGO,MAAM,sBAAsB,OAAO,EAAC,cAAc,EAAE,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,UAAU,EAAC;IACxG,IAAI,gBAAgB,SAAS,gBAAgB,CAAC,WAAW,SAAS,EAAE;QACnE,OAAO;IACR;IAEA,MAAM,EAAC,EAAE,EAAE,OAAO,EAAC,GAAG;IACtB,MAAM,WAAW;QAAC;QAAI,MAAM;QAAe,SAAS,IAAA,sKAAmB,EAAC,YAAY;IAAW;IAE/F,IAAI;QACH,MAAM,IAAA,0JAAW,EAAC;YACjB;YACA;YACA;YACA,KAAK;QACN,GAAG;IACJ,EAAE,OAAO,OAAO;QACf,WAAW,IAAI,CAAC,gBAAgB;IACjC;IAEA,OAAO;AACR;AAGO,MAAM,uBAAuB,CAAA;IACnC,IAAI,gBAAgB,SAAS,eAAe;QAC3C,OAAO;IACR;IAEA,MAAM,EAAC,EAAE,EAAE,SAAS,YAAY,EAAC,GAAG;IACpC,gBAAgB,CAAC,GAAG,EAAE,QAAQ;QAAC,YAAY;QAAO;IAAY;IAC9D,OAAO;AACR;AAGO,MAAM,wBAAwB,OAAO,gBAAgB,YAAY;IACvE,IAAI,gBAAgB,SAAS,cAAc;QAC1C;IACD;IAEA,MAAM,WAAW,IAAA,mKAAc;IAC/B,gBAAgB,CAAC,eAAe,EAAE,CAAC,GAAG;IACtC,MAAM,aAAa,IAAI;IAEvB,IAAI;QACH,MAAM,EAAC,UAAU,EAAE,YAAY,EAAC,GAAG,MAAM,QAAQ,IAAI,CAAC;YACrD;YACA,kBAAkB,YAAY,cAAc;SAC5C;QAED,IAAI,YAAY;YACf,IAAA,+KAA0B,EAAC;QAC5B;QAEA,IAAI,CAAC,cAAc;YAClB,IAAA,yKAAoB,EAAC;QACtB;IACD,SAAU;QACT,WAAW,KAAK;QAChB,OAAO,gBAAgB,CAAC,eAAe,EAAE,CAAC;IAC3C;AACD;AAEA,MAAM,mBAAmB,CAAC;AAE1B,MAAM,oBAAoB,OAAO,YAAY,cAAc,EAAC,MAAM,EAAC;IAClE,IAAA,kLAAqB,EAAC,YAAY,GAAG;IACrC,MAAM,IAAA,6HAAI,EAAC,YAAY,cAAc;QAAC;IAAM;IAC5C,IAAA,4KAAuB,EAAC;AACzB;AAEA,MAAM,eAAe;AACrB,MAAM,gBAAgB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1602, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/outgoing.js"],"sourcesContent":["import {createDeferred} from '../utils/deferred.js';\nimport {getFdSpecificValue} from '../arguments/specific.js';\nimport {SUBPROCESS_OPTIONS} from '../arguments/fd-options.js';\nimport {validateStrictDeadlock} from './strict.js';\n\n// When `sendMessage()` is ongoing, any `message` being received waits before being emitted.\n// This allows calling one or multiple `await sendMessage()` followed by `await getOneMessage()`/`await getEachMessage()`.\n// Without running into a race condition when the other process sends a response too fast, before the current process set up a listener.\nexport const startSendMessage = (anyProcess, wrappedMessage, strict) => {\n\tif (!OUTGOING_MESSAGES.has(anyProcess)) {\n\t\tOUTGOING_MESSAGES.set(anyProcess, new Set());\n\t}\n\n\tconst outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);\n\tconst onMessageSent = createDeferred();\n\tconst id = strict ? wrappedMessage.id : undefined;\n\tconst outgoingMessage = {onMessageSent, id};\n\toutgoingMessages.add(outgoingMessage);\n\treturn {outgoingMessages, outgoingMessage};\n};\n\nexport const endSendMessage = ({outgoingMessages, outgoingMessage}) => {\n\toutgoingMessages.delete(outgoingMessage);\n\toutgoingMessage.onMessageSent.resolve();\n};\n\n// Await while `sendMessage()` is ongoing, unless there is already a `message` listener\nexport const waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage) => {\n\twhile (!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0) {\n\t\tconst outgoingMessages = [...OUTGOING_MESSAGES.get(anyProcess)];\n\t\tvalidateStrictDeadlock(outgoingMessages, wrappedMessage);\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait Promise.all(outgoingMessages.map(({onMessageSent}) => onMessageSent));\n\t}\n};\n\nconst OUTGOING_MESSAGES = new WeakMap();\n\n// Whether any `message` listener is setup\nexport const hasMessageListeners = (anyProcess, ipcEmitter) => ipcEmitter.listenerCount('message') > getMinListenerCount(anyProcess);\n\n// When `buffer` is `false`, we set up a `message` listener that should be ignored.\n// That listener is only meant to intercept `strict` acknowledgement responses.\nconst getMinListenerCount = anyProcess => SUBPROCESS_OPTIONS.has(anyProcess)\n\t&& !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, 'ipc')\n\t? 1\n\t: 0;\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAKO,MAAM,mBAAmB,CAAC,YAAY,gBAAgB;IAC5D,IAAI,CAAC,kBAAkB,GAAG,CAAC,aAAa;QACvC,kBAAkB,GAAG,CAAC,YAAY,IAAI;IACvC;IAEA,MAAM,mBAAmB,kBAAkB,GAAG,CAAC;IAC/C,MAAM,gBAAgB,IAAA,mKAAc;IACpC,MAAM,KAAK,SAAS,eAAe,EAAE,GAAG;IACxC,MAAM,kBAAkB;QAAC;QAAe;IAAE;IAC1C,iBAAiB,GAAG,CAAC;IACrB,OAAO;QAAC;QAAkB;IAAe;AAC1C;AAEO,MAAM,iBAAiB,CAAC,EAAC,gBAAgB,EAAE,eAAe,EAAC;IACjE,iBAAiB,MAAM,CAAC;IACxB,gBAAgB,aAAa,CAAC,OAAO;AACtC;AAGO,MAAM,0BAA0B,OAAO,YAAY,YAAY;IACrE,MAAO,CAAC,oBAAoB,YAAY,eAAe,kBAAkB,GAAG,CAAC,aAAa,OAAO,EAAG;QACnG,MAAM,mBAAmB;eAAI,kBAAkB,GAAG,CAAC;SAAY;QAC/D,IAAA,uKAAsB,EAAC,kBAAkB;QACzC,4CAA4C;QAC5C,MAAM,QAAQ,GAAG,CAAC,iBAAiB,GAAG,CAAC,CAAC,EAAC,aAAa,EAAC,GAAK;IAC7D;AACD;AAEA,MAAM,oBAAoB,IAAI;AAGvB,MAAM,sBAAsB,CAAC,YAAY,aAAe,WAAW,aAAa,CAAC,aAAa,oBAAoB;AAEzH,mFAAmF;AACnF,+EAA+E;AAC/E,MAAM,sBAAsB,CAAA,aAAc,gLAAkB,CAAC,GAAG,CAAC,eAC7D,CAAC,IAAA,2KAAkB,EAAC,gLAAkB,CAAC,GAAG,CAAC,YAAY,OAAO,CAAC,MAAM,EAAE,SACxE,IACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1660, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/send.js"],"sourcesContent":["import {promisify} from 'node:util';\nimport {\n\tvalidateIpcMethod,\n\thandleEpipeError,\n\thandleSerializationError,\n\tdisconnect,\n} from './validation.js';\nimport {startSendMessage, endSendMessage} from './outgoing.js';\nimport {handleSendStrict, waitForStrictResponse} from './strict.js';\n\n// Like `[sub]process.send()` but promise-based.\n// We do not `await subprocess` during `.sendMessage()` nor `.getOneMessage()` since those methods are transient.\n// Users would still need to `await subprocess` after the method is done.\n// Also, this would prevent `unhandledRejection` event from being emitted, making it silent.\nexport const sendMessage = ({anyProcess, channel, isSubprocess, ipc}, message, {strict = false} = {}) => {\n\tconst methodName = 'sendMessage';\n\tvalidateIpcMethod({\n\t\tmethodName,\n\t\tisSubprocess,\n\t\tipc,\n\t\tisConnected: anyProcess.connected,\n\t});\n\n\treturn sendMessageAsync({\n\t\tanyProcess,\n\t\tchannel,\n\t\tmethodName,\n\t\tisSubprocess,\n\t\tmessage,\n\t\tstrict,\n\t});\n};\n\nconst sendMessageAsync = async ({anyProcess, channel, methodName, isSubprocess, message, strict}) => {\n\tconst wrappedMessage = handleSendStrict({\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tmessage,\n\t\tstrict,\n\t});\n\tconst outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict);\n\ttry {\n\t\tawait sendOneMessage({\n\t\t\tanyProcess,\n\t\t\tmethodName,\n\t\t\tisSubprocess,\n\t\t\twrappedMessage,\n\t\t\tmessage,\n\t\t});\n\t} catch (error) {\n\t\tdisconnect(anyProcess);\n\t\tthrow error;\n\t} finally {\n\t\tendSendMessage(outgoingMessagesState);\n\t}\n};\n\n// Used internally by `cancelSignal`\nexport const sendOneMessage = async ({anyProcess, methodName, isSubprocess, wrappedMessage, message}) => {\n\tconst sendMethod = getSendMethod(anyProcess);\n\n\ttry {\n\t\tawait Promise.all([\n\t\t\twaitForStrictResponse(wrappedMessage, anyProcess, isSubprocess),\n\t\t\tsendMethod(wrappedMessage),\n\t\t]);\n\t} catch (error) {\n\t\thandleEpipeError({error, methodName, isSubprocess});\n\t\thandleSerializationError({\n\t\t\terror,\n\t\t\tmethodName,\n\t\t\tisSubprocess,\n\t\t\tmessage,\n\t\t});\n\t\tthrow error;\n\t}\n};\n\n// [sub]process.send() promisified, memoized\nconst getSendMethod = anyProcess => {\n\tif (PROCESS_SEND_METHODS.has(anyProcess)) {\n\t\treturn PROCESS_SEND_METHODS.get(anyProcess);\n\t}\n\n\tconst sendMethod = promisify(anyProcess.send.bind(anyProcess));\n\tPROCESS_SEND_METHODS.set(anyProcess, sendMethod);\n\treturn sendMethod;\n};\n\nconst PROCESS_SEND_METHODS = new WeakMap();\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAMA;AACA;;;;;AAMO,MAAM,cAAc,CAAC,EAAC,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,GAAG,EAAC,EAAE,SAAS,EAAC,SAAS,KAAK,EAAC,GAAG,CAAC,CAAC;IACnG,MAAM,aAAa;IACnB,IAAA,sKAAiB,EAAC;QACjB;QACA;QACA;QACA,aAAa,WAAW,SAAS;IAClC;IAEA,OAAO,iBAAiB;QACvB;QACA;QACA;QACA;QACA;QACA;IACD;AACD;AAEA,MAAM,mBAAmB,OAAO,EAAC,UAAU,EAAE,OAAO,EAAE,UAAU,EAAE,YAAY,EAAE,OAAO,EAAE,MAAM,EAAC;IAC/F,MAAM,iBAAiB,IAAA,iKAAgB,EAAC;QACvC;QACA;QACA;QACA;QACA;IACD;IACA,MAAM,wBAAwB,IAAA,mKAAgB,EAAC,YAAY,gBAAgB;IAC3E,IAAI;QACH,MAAM,eAAe;YACpB;YACA;YACA;YACA;YACA;QACD;IACD,EAAE,OAAO,OAAO;QACf,IAAA,+JAAU,EAAC;QACX,MAAM;IACP,SAAU;QACT,IAAA,iKAAc,EAAC;IAChB;AACD;AAGO,MAAM,iBAAiB,OAAO,EAAC,UAAU,EAAE,UAAU,EAAE,YAAY,EAAE,cAAc,EAAE,OAAO,EAAC;IACnG,MAAM,aAAa,cAAc;IAEjC,IAAI;QACH,MAAM,QAAQ,GAAG,CAAC;YACjB,IAAA,sKAAqB,EAAC,gBAAgB,YAAY;YAClD,WAAW;SACX;IACF,EAAE,OAAO,OAAO;QACf,IAAA,qKAAgB,EAAC;YAAC;YAAO;YAAY;QAAY;QACjD,IAAA,6KAAwB,EAAC;YACxB;YACA;YACA;YACA;QACD;QACA,MAAM;IACP;AACD;AAEA,4CAA4C;AAC5C,MAAM,gBAAgB,CAAA;IACrB,IAAI,qBAAqB,GAAG,CAAC,aAAa;QACzC,OAAO,qBAAqB,GAAG,CAAC;IACjC;IAEA,MAAM,aAAa,IAAA,8HAAS,EAAC,WAAW,IAAI,CAAC,IAAI,CAAC;IAClD,qBAAqB,GAAG,CAAC,YAAY;IACrC,OAAO;AACR;AAEA,MAAM,uBAAuB,IAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1751, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/graceful.js"],"sourcesContent":["import {scheduler} from 'node:timers/promises';\nimport {sendOneMessage} from './send.js';\nimport {getIpcEmitter} from './forward.js';\nimport {validateConnection, getAbortDisconnectError, throwOnMissingParent} from './validation.js';\n\n// Send an IPC message so the subprocess performs a graceful termination\nexport const sendAbort = (subprocess, message) => {\n\tconst methodName = 'cancelSignal';\n\tvalidateConnection(methodName, false, subprocess.connected);\n\treturn sendOneMessage({\n\t\tanyProcess: subprocess,\n\t\tmethodName,\n\t\tisSubprocess: false,\n\t\twrappedMessage: {type: GRACEFUL_CANCEL_TYPE, message},\n\t\tmessage,\n\t});\n};\n\n// When the signal is being used, start listening for incoming messages.\n// Unbuffering messages takes one microtask to complete, so this must be async.\nexport const getCancelSignal = async ({anyProcess, channel, isSubprocess, ipc}) => {\n\tawait startIpc({\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tipc,\n\t});\n\treturn cancelController.signal;\n};\n\nconst startIpc = async ({anyProcess, channel, isSubprocess, ipc}) => {\n\tif (cancelListening) {\n\t\treturn;\n\t}\n\n\tcancelListening = true;\n\n\tif (!ipc) {\n\t\tthrowOnMissingParent();\n\t\treturn;\n\t}\n\n\tif (channel === null) {\n\t\tabortOnDisconnect();\n\t\treturn;\n\t}\n\n\tgetIpcEmitter(anyProcess, channel, isSubprocess);\n\tawait scheduler.yield();\n};\n\nlet cancelListening = false;\n\n// Reception of IPC message to perform a graceful termination\nexport const handleAbort = wrappedMessage => {\n\tif (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) {\n\t\treturn false;\n\t}\n\n\tcancelController.abort(wrappedMessage.message);\n\treturn true;\n};\n\nconst GRACEFUL_CANCEL_TYPE = 'execa:ipc:cancel';\n\n// When the current process disconnects early, the subprocess `cancelSignal` is aborted.\n// Otherwise, the signal would never be able to be aborted later on.\nexport const abortOnDisconnect = () => {\n\tcancelController.abort(getAbortDisconnectError());\n};\n\nconst cancelController = new AbortController();\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAGO,MAAM,YAAY,CAAC,YAAY;IACrC,MAAM,aAAa;IACnB,IAAA,uKAAkB,EAAC,YAAY,OAAO,WAAW,SAAS;IAC1D,OAAO,IAAA,6JAAc,EAAC;QACrB,YAAY;QACZ;QACA,cAAc;QACd,gBAAgB;YAAC,MAAM;YAAsB;QAAO;QACpD;IACD;AACD;AAIO,MAAM,kBAAkB,OAAO,EAAC,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,GAAG,EAAC;IAC7E,MAAM,SAAS;QACd;QACA;QACA;QACA;IACD;IACA,OAAO,iBAAiB,MAAM;AAC/B;AAEA,MAAM,WAAW,OAAO,EAAC,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,GAAG,EAAC;IAC/D,IAAI,iBAAiB;QACpB;IACD;IAEA,kBAAkB;IAElB,IAAI,CAAC,KAAK;QACT,IAAA,yKAAoB;QACpB;IACD;IAEA,IAAI,YAAY,MAAM;QACrB;QACA;IACD;IAEA,IAAA,+JAAa,EAAC,YAAY,SAAS;IACnC,MAAM,0JAAS,CAAC,KAAK;AACtB;AAEA,IAAI,kBAAkB;AAGf,MAAM,cAAc,CAAA;IAC1B,IAAI,gBAAgB,SAAS,sBAAsB;QAClD,OAAO;IACR;IAEA,iBAAiB,KAAK,CAAC,eAAe,OAAO;IAC7C,OAAO;AACR;AAEA,MAAM,uBAAuB;AAItB,MAAM,oBAAoB;IAChC,iBAAiB,KAAK,CAAC,IAAA,4KAAuB;AAC/C;AAEA,MAAM,mBAAmB,IAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1825, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/terminate/graceful.js"],"sourcesContent":["import {onAbortedSignal} from '../utils/abort-signal.js';\nimport {sendAbort} from '../ipc/graceful.js';\nimport {killOnTimeout} from './kill.js';\n\n// Validate the `gracefulCancel` option\nexport const validateGracefulCancel = ({gracefulCancel, cancelSignal, ipc, serialization}) => {\n\tif (!gracefulCancel) {\n\t\treturn;\n\t}\n\n\tif (cancelSignal === undefined) {\n\t\tthrow new Error('The `cancelSignal` option must be defined when setting the `gracefulCancel` option.');\n\t}\n\n\tif (!ipc) {\n\t\tthrow new Error('The `ipc` option cannot be false when setting the `gracefulCancel` option.');\n\t}\n\n\tif (serialization === 'json') {\n\t\tthrow new Error('The `serialization` option cannot be \\'json\\' when setting the `gracefulCancel` option.');\n\t}\n};\n\n// Send abort reason to the subprocess when aborting the `cancelSignal` option and `gracefulCancel` is `true`\nexport const throwOnGracefulCancel = ({\n\tsubprocess,\n\tcancelSignal,\n\tgracefulCancel,\n\tforceKillAfterDelay,\n\tcontext,\n\tcontroller,\n}) => gracefulCancel\n\t? [sendOnAbort({\n\t\tsubprocess,\n\t\tcancelSignal,\n\t\tforceKillAfterDelay,\n\t\tcontext,\n\t\tcontroller,\n\t})]\n\t: [];\n\nconst sendOnAbort = async ({subprocess, cancelSignal, forceKillAfterDelay, context, controller: {signal}}) => {\n\tawait onAbortedSignal(cancelSignal, signal);\n\tconst reason = getReason(cancelSignal);\n\tawait sendAbort(subprocess, reason);\n\tkillOnTimeout({\n\t\tkill: subprocess.kill,\n\t\tforceKillAfterDelay,\n\t\tcontext,\n\t\tcontrollerSignal: signal,\n\t});\n\tcontext.terminationReason ??= 'gracefulCancel';\n\tthrow cancelSignal.reason;\n};\n\n// The default `reason` is a DOMException, which is not serializable with V8\n// See https://github.com/nodejs/node/issues/53225\nconst getReason = ({reason}) => {\n\tif (!(reason instanceof DOMException)) {\n\t\treturn reason;\n\t}\n\n\tconst error = new Error(reason.message);\n\tObject.defineProperty(error, 'stack', {\n\t\tvalue: reason.stack,\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t\twritable: true,\n\t});\n\treturn error;\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAGO,MAAM,yBAAyB,CAAC,EAAC,cAAc,EAAE,YAAY,EAAE,GAAG,EAAE,aAAa,EAAC;IACxF,IAAI,CAAC,gBAAgB;QACpB;IACD;IAEA,IAAI,iBAAiB,WAAW;QAC/B,MAAM,IAAI,MAAM;IACjB;IAEA,IAAI,CAAC,KAAK;QACT,MAAM,IAAI,MAAM;IACjB;IAEA,IAAI,kBAAkB,QAAQ;QAC7B,MAAM,IAAI,MAAM;IACjB;AACD;AAGO,MAAM,wBAAwB,CAAC,EACrC,UAAU,EACV,YAAY,EACZ,cAAc,EACd,mBAAmB,EACnB,OAAO,EACP,UAAU,EACV,GAAK,iBACH;QAAC,YAAY;YACd;YACA;YACA;YACA;YACA;QACD;KAAG,GACD,EAAE;AAEL,MAAM,cAAc,OAAO,EAAC,UAAU,EAAE,YAAY,EAAE,mBAAmB,EAAE,OAAO,EAAE,YAAY,EAAC,MAAM,EAAC,EAAC;IACxG,MAAM,IAAA,2KAAe,EAAC,cAAc;IACpC,MAAM,SAAS,UAAU;IACzB,MAAM,IAAA,4JAAS,EAAC,YAAY;IAC5B,IAAA,kKAAa,EAAC;QACb,MAAM,WAAW,IAAI;QACrB;QACA;QACA,kBAAkB;IACnB;IACA,QAAQ,iBAAiB,KAAK;IAC9B,MAAM,aAAa,MAAM;AAC1B;AAEA,4EAA4E;AAC5E,kDAAkD;AAClD,MAAM,YAAY,CAAC,EAAC,MAAM,EAAC;IAC1B,IAAI,CAAC,CAAC,kBAAkB,YAAY,GAAG;QACtC,OAAO;IACR;IAEA,MAAM,QAAQ,IAAI,MAAM,OAAO,OAAO;IACtC,OAAO,cAAc,CAAC,OAAO,SAAS;QACrC,OAAO,OAAO,KAAK;QACnB,YAAY;QACZ,cAAc;QACd,UAAU;IACX;IACA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1892, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/terminate/timeout.js"],"sourcesContent":["import {setTimeout} from 'node:timers/promises';\nimport {DiscardedError} from '../return/final-error.js';\n\n// Validate `timeout` option\nexport const validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// Fails when the `timeout` option is exceeded\nexport const throwOnTimeout = (subprocess, timeout, context, controller) => timeout === 0 || timeout === undefined\n\t? []\n\t: [killAfterTimeout(subprocess, timeout, context, controller)];\n\nconst killAfterTimeout = async (subprocess, timeout, context, {signal}) => {\n\tawait setTimeout(timeout, undefined, {signal});\n\tcontext.terminationReason ??= 'timeout';\n\tsubprocess.kill();\n\tthrow new DiscardedError();\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAGO,MAAM,kBAAkB,CAAC,EAAC,OAAO,EAAC;IACxC,IAAI,YAAY,aAAa,CAAC,CAAC,OAAO,QAAQ,CAAC,YAAY,UAAU,CAAC,GAAG;QACxE,MAAM,IAAI,UAAU,CAAC,oEAAoE,EAAE,QAAQ,IAAI,EAAE,OAAO,QAAQ,CAAC,CAAC;IAC3H;AACD;AAGO,MAAM,iBAAiB,CAAC,YAAY,SAAS,SAAS,aAAe,YAAY,KAAK,YAAY,YACtG,EAAE,GACF;QAAC,iBAAiB,YAAY,SAAS,SAAS;KAAY;AAE/D,MAAM,mBAAmB,OAAO,YAAY,SAAS,SAAS,EAAC,MAAM,EAAC;IACrE,MAAM,IAAA,2JAAU,EAAC,SAAS,WAAW;QAAC;IAAM;IAC5C,QAAQ,iBAAiB,KAAK;IAC9B,WAAW,IAAI;IACf,MAAM,IAAI,0KAAc;AACzB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1922, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/methods/node.js"],"sourcesContent":["import {execPath, execArgv} from 'node:process';\nimport path from 'node:path';\nimport {safeNormalizeFileUrl} from '../arguments/file-url.js';\n\n// `execaNode()` is a shortcut for `execa(..., {node: true})`\nexport const mapNode = ({options}) => {\n\tif (options.node === false) {\n\t\tthrow new TypeError('The \"node\" option cannot be false with `execaNode()`.');\n\t}\n\n\treturn {options: {...options, node: true}};\n};\n\n// Applies the `node: true` option, and the related `nodePath`/`nodeOptions` options.\n// Modifies the file commands/arguments to ensure the same Node binary and flags are re-used.\n// Also adds `ipc: true` and `shell: false`.\nexport const handleNodeOption = (file, commandArguments, {\n\tnode: shouldHandleNode = false,\n\tnodePath = execPath,\n\tnodeOptions = execArgv.filter(nodeOption => !nodeOption.startsWith('--inspect')),\n\tcwd,\n\texecPath: formerNodePath,\n\t...options\n}) => {\n\tif (formerNodePath !== undefined) {\n\t\tthrow new TypeError('The \"execPath\" option has been removed. Please use the \"nodePath\" option instead.');\n\t}\n\n\tconst normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The \"nodePath\" option');\n\tconst resolvedNodePath = path.resolve(cwd, normalizedNodePath);\n\tconst newOptions = {\n\t\t...options,\n\t\tnodePath: resolvedNodePath,\n\t\tnode: shouldHandleNode,\n\t\tcwd,\n\t};\n\n\tif (!shouldHandleNode) {\n\t\treturn [file, commandArguments, newOptions];\n\t}\n\n\tif (path.basename(file, '.exe') === 'node') {\n\t\tthrow new TypeError('When the \"node\" option is true, the first argument does not need to be \"node\".');\n\t}\n\n\treturn [\n\t\tresolvedNodePath,\n\t\t[...nodeOptions, file, ...commandArguments],\n\t\t{ipc: true, ...newOptions, shell: false},\n\t];\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAGO,MAAM,UAAU,CAAC,EAAC,OAAO,EAAC;IAChC,IAAI,QAAQ,IAAI,KAAK,OAAO;QAC3B,MAAM,IAAI,UAAU;IACrB;IAEA,OAAO;QAAC,SAAS;YAAC,GAAG,OAAO;YAAE,MAAM;QAAI;IAAC;AAC1C;AAKO,MAAM,mBAAmB,CAAC,MAAM,kBAAkB,EACxD,MAAM,mBAAmB,KAAK,EAC9B,WAAW,mIAAQ,EACnB,cAAc,mIAAQ,CAAC,MAAM,CAAC,CAAA,aAAc,CAAC,WAAW,UAAU,CAAC,aAAa,EAChF,GAAG,EACH,UAAU,cAAc,EACxB,GAAG,SACH;IACA,IAAI,mBAAmB,WAAW;QACjC,MAAM,IAAI,UAAU;IACrB;IAEA,MAAM,qBAAqB,IAAA,gLAAoB,EAAC,UAAU;IAC1D,MAAM,mBAAmB,4HAAI,CAAC,OAAO,CAAC,KAAK;IAC3C,MAAM,aAAa;QAClB,GAAG,OAAO;QACV,UAAU;QACV,MAAM;QACN;IACD;IAEA,IAAI,CAAC,kBAAkB;QACtB,OAAO;YAAC;YAAM;YAAkB;SAAW;IAC5C;IAEA,IAAI,4HAAI,CAAC,QAAQ,CAAC,MAAM,YAAY,QAAQ;QAC3C,MAAM,IAAI,UAAU;IACrB;IAEA,OAAO;QACN;QACA;eAAI;YAAa;eAAS;SAAiB;QAC3C;YAAC,KAAK;YAAM,GAAG,UAAU;YAAE,OAAO;QAAK;KACvC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1985, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/ipc-input.js"],"sourcesContent":["import {serialize} from 'node:v8';\n\n// Validate the `ipcInput` option\nexport const validateIpcInputOption = ({ipcInput, ipc, serialization}) => {\n\tif (ipcInput === undefined) {\n\t\treturn;\n\t}\n\n\tif (!ipc) {\n\t\tthrow new Error('The `ipcInput` option cannot be set unless the `ipc` option is `true`.');\n\t}\n\n\tvalidateIpcInput[serialization](ipcInput);\n};\n\nconst validateAdvancedInput = ipcInput => {\n\ttry {\n\t\tserialize(ipcInput);\n\t} catch (error) {\n\t\tthrow new Error('The `ipcInput` option is not serializable with a structured clone.', {cause: error});\n\t}\n};\n\nconst validateJsonInput = ipcInput => {\n\ttry {\n\t\tJSON.stringify(ipcInput);\n\t} catch (error) {\n\t\tthrow new Error('The `ipcInput` option is not serializable with JSON.', {cause: error});\n\t}\n};\n\nconst validateIpcInput = {\n\tadvanced: validateAdvancedInput,\n\tjson: validateJsonInput,\n};\n\n// When the `ipcInput` option is set, it is sent as an initial IPC message to the subprocess\nexport const sendIpcInput = async (subprocess, ipcInput) => {\n\tif (ipcInput === undefined) {\n\t\treturn;\n\t}\n\n\tawait subprocess.sendMessage(ipcInput);\n};\n"],"names":[],"mappings":";;;;;;AAAA;;AAGO,MAAM,yBAAyB,CAAC,EAAC,QAAQ,EAAE,GAAG,EAAE,aAAa,EAAC;IACpE,IAAI,aAAa,WAAW;QAC3B;IACD;IAEA,IAAI,CAAC,KAAK;QACT,MAAM,IAAI,MAAM;IACjB;IAEA,gBAAgB,CAAC,cAAc,CAAC;AACjC;AAEA,MAAM,wBAAwB,CAAA;IAC7B,IAAI;QACH,IAAA,0HAAS,EAAC;IACX,EAAE,OAAO,OAAO;QACf,MAAM,IAAI,MAAM,sEAAsE;YAAC,OAAO;QAAK;IACpG;AACD;AAEA,MAAM,oBAAoB,CAAA;IACzB,IAAI;QACH,KAAK,SAAS,CAAC;IAChB,EAAE,OAAO,OAAO;QACf,MAAM,IAAI,MAAM,wDAAwD;YAAC,OAAO;QAAK;IACtF;AACD;AAEA,MAAM,mBAAmB;IACxB,UAAU;IACV,MAAM;AACP;AAGO,MAAM,eAAe,OAAO,YAAY;IAC9C,IAAI,aAAa,WAAW;QAC3B;IACD;IAEA,MAAM,WAAW,WAAW,CAAC;AAC9B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2034, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/arguments/encoding-option.js"],"sourcesContent":["// Validate `encoding` option\nexport const validateEncoding = ({encoding}) => {\n\tif (ENCODINGS.has(encoding)) {\n\t\treturn;\n\t}\n\n\tconst correctEncoding = getCorrectEncoding(encoding);\n\tif (correctEncoding !== undefined) {\n\t\tthrow new TypeError(`Invalid option \\`encoding: ${serializeEncoding(encoding)}\\`.\nPlease rename it to ${serializeEncoding(correctEncoding)}.`);\n\t}\n\n\tconst correctEncodings = [...ENCODINGS].map(correctEncoding => serializeEncoding(correctEncoding)).join(', ');\n\tthrow new TypeError(`Invalid option \\`encoding: ${serializeEncoding(encoding)}\\`.\nPlease rename it to one of: ${correctEncodings}.`);\n};\n\nconst TEXT_ENCODINGS = new Set(['utf8', 'utf16le']);\nexport const BINARY_ENCODINGS = new Set(['buffer', 'hex', 'base64', 'base64url', 'latin1', 'ascii']);\nconst ENCODINGS = new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);\n\nconst getCorrectEncoding = encoding => {\n\tif (encoding === null) {\n\t\treturn 'buffer';\n\t}\n\n\tif (typeof encoding !== 'string') {\n\t\treturn;\n\t}\n\n\tconst lowerEncoding = encoding.toLowerCase();\n\tif (lowerEncoding in ENCODING_ALIASES) {\n\t\treturn ENCODING_ALIASES[lowerEncoding];\n\t}\n\n\tif (ENCODINGS.has(lowerEncoding)) {\n\t\treturn lowerEncoding;\n\t}\n};\n\nconst ENCODING_ALIASES = {\n\t// eslint-disable-next-line unicorn/text-encoding-identifier-case\n\t'utf-8': 'utf8',\n\t'utf-16le': 'utf16le',\n\t'ucs-2': 'utf16le',\n\tucs2: 'utf16le',\n\tbinary: 'latin1',\n};\n\nconst serializeEncoding = encoding => typeof encoding === 'string' ? `\"${encoding}\"` : String(encoding);\n"],"names":[],"mappings":"AAAA,6BAA6B;;;;;;;AACtB,MAAM,mBAAmB,CAAC,EAAC,QAAQ,EAAC;IAC1C,IAAI,UAAU,GAAG,CAAC,WAAW;QAC5B;IACD;IAEA,MAAM,kBAAkB,mBAAmB;IAC3C,IAAI,oBAAoB,WAAW;QAClC,MAAM,IAAI,UAAU,CAAC,2BAA2B,EAAE,kBAAkB,UAAU;oBAC5D,EAAE,kBAAkB,iBAAiB,CAAC,CAAC;IAC1D;IAEA,MAAM,mBAAmB;WAAI;KAAU,CAAC,GAAG,CAAC,CAAA,kBAAmB,kBAAkB,kBAAkB,IAAI,CAAC;IACxG,MAAM,IAAI,UAAU,CAAC,2BAA2B,EAAE,kBAAkB,UAAU;4BACnD,EAAE,iBAAiB,CAAC,CAAC;AACjD;AAEA,MAAM,iBAAiB,IAAI,IAAI;IAAC;IAAQ;CAAU;AAC3C,MAAM,mBAAmB,IAAI,IAAI;IAAC;IAAU;IAAO;IAAU;IAAa;IAAU;CAAQ;AACnG,MAAM,YAAY,IAAI,IAAI;OAAI;OAAmB;CAAiB;AAElE,MAAM,qBAAqB,CAAA;IAC1B,IAAI,aAAa,MAAM;QACtB,OAAO;IACR;IAEA,IAAI,OAAO,aAAa,UAAU;QACjC;IACD;IAEA,MAAM,gBAAgB,SAAS,WAAW;IAC1C,IAAI,iBAAiB,kBAAkB;QACtC,OAAO,gBAAgB,CAAC,cAAc;IACvC;IAEA,IAAI,UAAU,GAAG,CAAC,gBAAgB;QACjC,OAAO;IACR;AACD;AAEA,MAAM,mBAAmB;IACxB,iEAAiE;IACjE,SAAS;IACT,YAAY;IACZ,SAAS;IACT,MAAM;IACN,QAAQ;AACT;AAEA,MAAM,oBAAoB,CAAA,WAAY,OAAO,aAAa,WAAW,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,GAAG,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2100, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/arguments/cwd.js"],"sourcesContent":["import {statSync} from 'node:fs';\nimport path from 'node:path';\nimport process from 'node:process';\nimport {safeNormalizeFileUrl} from './file-url.js';\n\n// Normalize `cwd` option\nexport const normalizeCwd = (cwd = getDefaultCwd()) => {\n\tconst cwdString = safeNormalizeFileUrl(cwd, 'The \"cwd\" option');\n\treturn path.resolve(cwdString);\n};\n\nconst getDefaultCwd = () => {\n\ttry {\n\t\treturn process.cwd();\n\t} catch (error) {\n\t\terror.message = `The current directory does not exist.\\n${error.message}`;\n\t\tthrow error;\n\t}\n};\n\n// When `cwd` option has an invalid value, provide with a better error message\nexport const fixCwdError = (originalMessage, cwd) => {\n\tif (cwd === getDefaultCwd()) {\n\t\treturn originalMessage;\n\t}\n\n\tlet cwdStat;\n\ttry {\n\t\tcwdStat = statSync(cwd);\n\t} catch (error) {\n\t\treturn `The \"cwd\" option is invalid: ${cwd}.\\n${error.message}\\n${originalMessage}`;\n\t}\n\n\tif (!cwdStat.isDirectory()) {\n\t\treturn `The \"cwd\" option is not a directory: ${cwd}.\\n${originalMessage}`;\n\t}\n\n\treturn originalMessage;\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAGO,MAAM,eAAe,CAAC,MAAM,eAAe;IACjD,MAAM,YAAY,IAAA,gLAAoB,EAAC,KAAK;IAC5C,OAAO,4HAAI,CAAC,OAAO,CAAC;AACrB;AAEA,MAAM,gBAAgB;IACrB,IAAI;QACH,OAAO,kIAAO,CAAC,GAAG;IACnB,EAAE,OAAO,OAAO;QACf,MAAM,OAAO,GAAG,CAAC,uCAAuC,EAAE,MAAM,OAAO,EAAE;QACzE,MAAM;IACP;AACD;AAGO,MAAM,cAAc,CAAC,iBAAiB;IAC5C,IAAI,QAAQ,iBAAiB;QAC5B,OAAO;IACR;IAEA,IAAI;IACJ,IAAI;QACH,UAAU,IAAA,yHAAQ,EAAC;IACpB,EAAE,OAAO,OAAO;QACf,OAAO,CAAC,6BAA6B,EAAE,IAAI,GAAG,EAAE,MAAM,OAAO,CAAC,EAAE,EAAE,iBAAiB;IACpF;IAEA,IAAI,CAAC,QAAQ,WAAW,IAAI;QAC3B,OAAO,CAAC,qCAAqC,EAAE,IAAI,GAAG,EAAE,iBAAiB;IAC1E;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2145, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/arguments/options.js"],"sourcesContent":["import path from 'node:path';\nimport process from 'node:process';\nimport crossSpawn from 'cross-spawn';\nimport {npmRunPathEnv} from 'npm-run-path';\nimport {normalizeForceKillAfterDelay} from '../terminate/kill.js';\nimport {normalizeKillSignal} from '../terminate/signal.js';\nimport {validateCancelSignal} from '../terminate/cancel.js';\nimport {validateGracefulCancel} from '../terminate/graceful.js';\nimport {validateTimeout} from '../terminate/timeout.js';\nimport {handleNodeOption} from '../methods/node.js';\nimport {validateIpcInputOption} from '../ipc/ipc-input.js';\nimport {validateEncoding, BINARY_ENCODINGS} from './encoding-option.js';\nimport {normalizeCwd} from './cwd.js';\nimport {normalizeFileUrl} from './file-url.js';\nimport {normalizeFdSpecificOptions} from './specific.js';\n\n// Normalize the options object, and sometimes also the file paths and arguments.\n// Applies default values, validate allowed options, normalize them.\nexport const normalizeOptions = (filePath, rawArguments, rawOptions) => {\n\trawOptions.cwd = normalizeCwd(rawOptions.cwd);\n\tconst [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);\n\n\tconst {command: file, args: commandArguments, options: initialOptions} = crossSpawn._parse(processedFile, processedArguments, processedOptions);\n\n\tconst fdOptions = normalizeFdSpecificOptions(initialOptions);\n\tconst options = addDefaultOptions(fdOptions);\n\tvalidateTimeout(options);\n\tvalidateEncoding(options);\n\tvalidateIpcInputOption(options);\n\tvalidateCancelSignal(options);\n\tvalidateGracefulCancel(options);\n\toptions.shell = normalizeFileUrl(options.shell);\n\toptions.env = getEnv(options);\n\toptions.killSignal = normalizeKillSignal(options.killSignal);\n\toptions.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);\n\toptions.lines = options.lines.map((lines, fdNumber) => lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);\n\n\tif (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n\t\t// #116\n\t\tcommandArguments.unshift('/q');\n\t}\n\n\treturn {file, commandArguments, options};\n};\n\nconst addDefaultOptions = ({\n\textendEnv = true,\n\tpreferLocal = false,\n\tcwd,\n\tlocalDir: localDirectory = cwd,\n\tencoding = 'utf8',\n\treject = true,\n\tcleanup = true,\n\tall = false,\n\twindowsHide = true,\n\tkillSignal = 'SIGTERM',\n\tforceKillAfterDelay = true,\n\tgracefulCancel = false,\n\tipcInput,\n\tipc = ipcInput !== undefined || gracefulCancel,\n\tserialization = 'advanced',\n\t...options\n}) => ({\n\t...options,\n\textendEnv,\n\tpreferLocal,\n\tcwd,\n\tlocalDirectory,\n\tencoding,\n\treject,\n\tcleanup,\n\tall,\n\twindowsHide,\n\tkillSignal,\n\tforceKillAfterDelay,\n\tgracefulCancel,\n\tipcInput,\n\tipc,\n\tserialization,\n});\n\nconst getEnv = ({env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath}) => {\n\tconst env = extendEnv ? {...process.env, ...envOption} : envOption;\n\n\tif (preferLocal || node) {\n\t\treturn npmRunPathEnv({\n\t\t\tenv,\n\t\t\tcwd: localDirectory,\n\t\t\texecPath: nodePath,\n\t\t\tpreferLocal,\n\t\t\taddExecPath: node,\n\t\t});\n\t}\n\n\treturn env;\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAIO,MAAM,mBAAmB,CAAC,UAAU,cAAc;IACxD,WAAW,GAAG,GAAG,IAAA,gKAAY,EAAC,WAAW,GAAG;IAC5C,MAAM,CAAC,eAAe,oBAAoB,iBAAiB,GAAG,IAAA,mKAAgB,EAAC,UAAU,cAAc;IAEvG,MAAM,EAAC,SAAS,IAAI,EAAE,MAAM,gBAAgB,EAAE,SAAS,cAAc,EAAC,GAAG,kJAAU,CAAC,MAAM,CAAC,eAAe,oBAAoB;IAE9H,MAAM,YAAY,IAAA,mLAA0B,EAAC;IAC7C,MAAM,UAAU,kBAAkB;IAClC,IAAA,uKAAe,EAAC;IAChB,IAAA,mLAAgB,EAAC;IACjB,IAAA,6KAAsB,EAAC;IACvB,IAAA,2KAAoB,EAAC;IACrB,IAAA,+KAAsB,EAAC;IACvB,QAAQ,KAAK,GAAG,IAAA,4KAAgB,EAAC,QAAQ,KAAK;IAC9C,QAAQ,GAAG,GAAG,OAAO;IACrB,QAAQ,UAAU,GAAG,IAAA,0KAAmB,EAAC,QAAQ,UAAU;IAC3D,QAAQ,mBAAmB,GAAG,IAAA,iLAA4B,EAAC,QAAQ,mBAAmB;IACtF,QAAQ,KAAK,GAAG,QAAQ,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,WAAa,SAAS,CAAC,mLAAgB,CAAC,GAAG,CAAC,QAAQ,QAAQ,KAAK,QAAQ,MAAM,CAAC,SAAS;IAEnI,IAAI,kIAAO,CAAC,QAAQ,KAAK,WAAW,4HAAI,CAAC,QAAQ,CAAC,MAAM,YAAY,OAAO;QAC1E,OAAO;QACP,iBAAiB,OAAO,CAAC;IAC1B;IAEA,OAAO;QAAC;QAAM;QAAkB;IAAO;AACxC;AAEA,MAAM,oBAAoB,CAAC,EAC1B,YAAY,IAAI,EAChB,cAAc,KAAK,EACnB,GAAG,EACH,UAAU,iBAAiB,GAAG,EAC9B,WAAW,MAAM,EACjB,SAAS,IAAI,EACb,UAAU,IAAI,EACd,MAAM,KAAK,EACX,cAAc,IAAI,EAClB,aAAa,SAAS,EACtB,sBAAsB,IAAI,EAC1B,iBAAiB,KAAK,EACtB,QAAQ,EACR,MAAM,aAAa,aAAa,cAAc,EAC9C,gBAAgB,UAAU,EAC1B,GAAG,SACH,GAAK,CAAC;QACN,GAAG,OAAO;QACV;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACD,CAAC;AAED,MAAM,SAAS,CAAC,EAAC,KAAK,SAAS,EAAE,SAAS,EAAE,WAAW,EAAE,IAAI,EAAE,cAAc,EAAE,QAAQ,EAAC;IACvF,MAAM,MAAM,YAAY;QAAC,GAAG,kIAAO,CAAC,GAAG;QAAE,GAAG,SAAS;IAAA,IAAI;IAEzD,IAAI,eAAe,MAAM;QACxB,OAAO,IAAA,4JAAa,EAAC;YACpB;YACA,KAAK;YACL,UAAU;YACV;YACA,aAAa;QACd;IACD;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2243, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/arguments/shell.js"],"sourcesContent":["// When the `shell` option is set, any command argument is concatenated as a single string by Node.js:\n// https://github.com/nodejs/node/blob/e38ce27f3ca0a65f68a31cedd984cddb927d4002/lib/child_process.js#L614-L624\n// However, since Node 24, it also prints a deprecation warning.\n// To avoid this warning, we perform that same operation before calling `node:child_process`.\n// Shells only understand strings, which is why Node.js performs that concatenation.\n// However, we rely on users splitting command arguments as an array.\n// For example, this allows us to easily detect which arguments are passed.\n// So we do want users to pass array of arguments even with `shell: true`, but we also want to avoid any warning.\nexport const concatenateShell = (file, commandArguments, options) => options.shell && commandArguments.length > 0\n\t? [[file, ...commandArguments].join(' '), [], options]\n\t: [file, commandArguments, options];\n"],"names":[],"mappings":"AAAA,sGAAsG;AACtG,8GAA8G;AAC9G,gEAAgE;AAChE,6FAA6F;AAC7F,oFAAoF;AACpF,qEAAqE;AACrE,2EAA2E;AAC3E,iHAAiH;;;;;AAC1G,MAAM,mBAAmB,CAAC,MAAM,kBAAkB,UAAY,QAAQ,KAAK,IAAI,iBAAiB,MAAM,GAAG,IAC7G;QAAC;YAAC;eAAS;SAAiB,CAAC,IAAI,CAAC;QAAM,EAAE;QAAE;KAAQ,GACpD;QAAC;QAAM;QAAkB;KAAQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2271, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/io/max-buffer.js"],"sourcesContent":["import {MaxBufferError} from 'get-stream';\nimport {getStreamName} from '../utils/standard-stream.js';\nimport {getFdSpecificValue} from '../arguments/specific.js';\n\n// When the `maxBuffer` option is hit, a MaxBufferError is thrown.\n// The stream is aborted, then specific information is kept for the error message.\nexport const handleMaxBuffer = ({error, stream, readableObjectMode, lines, encoding, fdNumber}) => {\n\tif (!(error instanceof MaxBufferError)) {\n\t\tthrow error;\n\t}\n\n\tif (fdNumber === 'all') {\n\t\treturn error;\n\t}\n\n\tconst unit = getMaxBufferUnit(readableObjectMode, lines, encoding);\n\terror.maxBufferInfo = {fdNumber, unit};\n\tstream.destroy();\n\tthrow error;\n};\n\nconst getMaxBufferUnit = (readableObjectMode, lines, encoding) => {\n\tif (readableObjectMode) {\n\t\treturn 'objects';\n\t}\n\n\tif (lines) {\n\t\treturn 'lines';\n\t}\n\n\tif (encoding === 'buffer') {\n\t\treturn 'bytes';\n\t}\n\n\treturn 'characters';\n};\n\n// Check the `maxBuffer` option with `result.ipcOutput`\nexport const checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer) => {\n\tif (ipcOutput.length !== maxBuffer) {\n\t\treturn;\n\t}\n\n\tconst error = new MaxBufferError();\n\terror.maxBufferInfo = {fdNumber: 'ipc'};\n\tthrow error;\n};\n\n// Error message when `maxBuffer` is hit\nexport const getMaxBufferMessage = (error, maxBuffer) => {\n\tconst {streamName, threshold, unit} = getMaxBufferInfo(error, maxBuffer);\n\treturn `Command's ${streamName} was larger than ${threshold} ${unit}`;\n};\n\nconst getMaxBufferInfo = (error, maxBuffer) => {\n\tif (error?.maxBufferInfo === undefined) {\n\t\treturn {streamName: 'output', threshold: maxBuffer[1], unit: 'bytes'};\n\t}\n\n\tconst {maxBufferInfo: {fdNumber, unit}} = error;\n\tdelete error.maxBufferInfo;\n\n\tconst threshold = getFdSpecificValue(maxBuffer, fdNumber);\n\tif (fdNumber === 'ipc') {\n\t\treturn {streamName: 'IPC output', threshold, unit: 'messages'};\n\t}\n\n\treturn {streamName: getStreamName(fdNumber), threshold, unit};\n};\n\n// The only way to apply `maxBuffer` with `spawnSync()` is to use the native `maxBuffer` option Node.js provides.\n// However, this has multiple limitations, and cannot behave the exact same way as the async behavior.\n// When the `maxBuffer` is hit, a `ENOBUFS` error is thrown.\nexport const isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === 'ENOBUFS'\n\t&& output !== null\n\t&& output.some(result => result !== null && result.length > getMaxBufferSync(maxBuffer));\n\n// When `maxBuffer` is hit, ensure the result is truncated\nexport const truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {\n\tif (!isMaxBuffer) {\n\t\treturn result;\n\t}\n\n\tconst maxBufferValue = getMaxBufferSync(maxBuffer);\n\treturn result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;\n};\n\n// `spawnSync()` does not allow differentiating `maxBuffer` per file descriptor, so we always use `stdout`\nexport const getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;;;;AAIO,MAAM,kBAAkB,CAAC,EAAC,KAAK,EAAE,MAAM,EAAE,kBAAkB,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAC;IAC7F,IAAI,CAAC,CAAC,iBAAiB,qKAAc,GAAG;QACvC,MAAM;IACP;IAEA,IAAI,aAAa,OAAO;QACvB,OAAO;IACR;IAEA,MAAM,OAAO,iBAAiB,oBAAoB,OAAO;IACzD,MAAM,aAAa,GAAG;QAAC;QAAU;IAAI;IACrC,OAAO,OAAO;IACd,MAAM;AACP;AAEA,MAAM,mBAAmB,CAAC,oBAAoB,OAAO;IACpD,IAAI,oBAAoB;QACvB,OAAO;IACR;IAEA,IAAI,OAAO;QACV,OAAO;IACR;IAEA,IAAI,aAAa,UAAU;QAC1B,OAAO;IACR;IAEA,OAAO;AACR;AAGO,MAAM,oBAAoB,CAAC,YAAY,WAAW;IACxD,IAAI,UAAU,MAAM,KAAK,WAAW;QACnC;IACD;IAEA,MAAM,QAAQ,IAAI,qKAAc;IAChC,MAAM,aAAa,GAAG;QAAC,UAAU;IAAK;IACtC,MAAM;AACP;AAGO,MAAM,sBAAsB,CAAC,OAAO;IAC1C,MAAM,EAAC,UAAU,EAAE,SAAS,EAAE,IAAI,EAAC,GAAG,iBAAiB,OAAO;IAC9D,OAAO,CAAC,UAAU,EAAE,WAAW,iBAAiB,EAAE,UAAU,CAAC,EAAE,MAAM;AACtE;AAEA,MAAM,mBAAmB,CAAC,OAAO;IAChC,IAAI,OAAO,kBAAkB,WAAW;QACvC,OAAO;YAAC,YAAY;YAAU,WAAW,SAAS,CAAC,EAAE;YAAE,MAAM;QAAO;IACrE;IAEA,MAAM,EAAC,eAAe,EAAC,QAAQ,EAAE,IAAI,EAAC,EAAC,GAAG;IAC1C,OAAO,MAAM,aAAa;IAE1B,MAAM,YAAY,IAAA,2KAAkB,EAAC,WAAW;IAChD,IAAI,aAAa,OAAO;QACvB,OAAO;YAAC,YAAY;YAAc;YAAW,MAAM;QAAU;IAC9D;IAEA,OAAO;QAAC,YAAY,IAAA,4KAAa,EAAC;QAAW;QAAW;IAAI;AAC7D;AAKO,MAAM,kBAAkB,CAAC,aAAa,QAAQ,YAAc,aAAa,SAAS,aACrF,WAAW,QACX,OAAO,IAAI,CAAC,CAAA,SAAU,WAAW,QAAQ,OAAO,MAAM,GAAG,iBAAiB;AAGvE,MAAM,wBAAwB,CAAC,QAAQ,aAAa;IAC1D,IAAI,CAAC,aAAa;QACjB,OAAO;IACR;IAEA,MAAM,iBAAiB,iBAAiB;IACxC,OAAO,OAAO,MAAM,GAAG,iBAAiB,OAAO,KAAK,CAAC,GAAG,kBAAkB;AAC3E;AAGO,MAAM,mBAAmB,CAAC,GAAG,gBAAgB,GAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2369, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/return/message.js"],"sourcesContent":["import {inspect} from 'node:util';\nimport stripFinalNewline from 'strip-final-newline';\nimport {isUint8Array, uint8ArrayToString} from '../utils/uint-array.js';\nimport {fixCwdError} from '../arguments/cwd.js';\nimport {escapeLines} from '../arguments/escape.js';\nimport {getMaxBufferMessage} from '../io/max-buffer.js';\nimport {getSignalDescription} from '../terminate/signal.js';\nimport {DiscardedError, isExecaError} from './final-error.js';\n\n// Computes `error.message`, `error.shortMessage` and `error.originalMessage`\nexport const createMessages = ({\n\tstdio,\n\tall,\n\tipcOutput,\n\toriginalError,\n\tsignal,\n\tsignalDescription,\n\texitCode,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\tforceKillAfterDelay,\n\tkillSignal,\n\tmaxBuffer,\n\ttimeout,\n\tcwd,\n}) => {\n\tconst errorCode = originalError?.code;\n\tconst prefix = getErrorPrefix({\n\t\toriginalError,\n\t\ttimedOut,\n\t\ttimeout,\n\t\tisMaxBuffer,\n\t\tmaxBuffer,\n\t\terrorCode,\n\t\tsignal,\n\t\tsignalDescription,\n\t\texitCode,\n\t\tisCanceled,\n\t\tisGracefullyCanceled,\n\t\tisForcefullyTerminated,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t});\n\tconst originalMessage = getOriginalMessage(originalError, cwd);\n\tconst suffix = originalMessage === undefined ? '' : `\\n${originalMessage}`;\n\tconst shortMessage = `${prefix}: ${escapedCommand}${suffix}`;\n\tconst messageStdio = all === undefined ? [stdio[2], stdio[1]] : [all];\n\tconst message = [\n\t\tshortMessage,\n\t\t...messageStdio,\n\t\t...stdio.slice(3),\n\t\tipcOutput.map(ipcMessage => serializeIpcMessage(ipcMessage)).join('\\n'),\n\t]\n\t\t.map(messagePart => escapeLines(stripFinalNewline(serializeMessagePart(messagePart))))\n\t\t.filter(Boolean)\n\t\t.join('\\n\\n');\n\treturn {originalMessage, shortMessage, message};\n};\n\nconst getErrorPrefix = ({\n\toriginalError,\n\ttimedOut,\n\ttimeout,\n\tisMaxBuffer,\n\tmaxBuffer,\n\terrorCode,\n\tsignal,\n\tsignalDescription,\n\texitCode,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisForcefullyTerminated,\n\tforceKillAfterDelay,\n\tkillSignal,\n}) => {\n\tconst forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);\n\n\tif (timedOut) {\n\t\treturn `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;\n\t}\n\n\tif (isGracefullyCanceled) {\n\t\tif (signal === undefined) {\n\t\t\treturn `Command was gracefully canceled with exit code ${exitCode}`;\n\t\t}\n\n\t\treturn isForcefullyTerminated\n\t\t\t? `Command was gracefully canceled${forcefulSuffix}`\n\t\t\t: `Command was gracefully canceled with ${signal} (${signalDescription})`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn `Command was canceled${forcefulSuffix}`;\n\t}\n\n\tif (isMaxBuffer) {\n\t\treturn `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `Command failed with ${errorCode}${forcefulSuffix}`;\n\t}\n\n\tif (isForcefullyTerminated) {\n\t\treturn `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `Command was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `Command failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'Command failed';\n};\n\nconst getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay) => isForcefullyTerminated\n\t? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds`\n\t: '';\n\nconst getOriginalMessage = (originalError, cwd) => {\n\tif (originalError instanceof DiscardedError) {\n\t\treturn;\n\t}\n\n\tconst originalMessage = isExecaError(originalError)\n\t\t? originalError.originalMessage\n\t\t: String(originalError?.message ?? originalError);\n\tconst escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd));\n\treturn escapedOriginalMessage === '' ? undefined : escapedOriginalMessage;\n};\n\nconst serializeIpcMessage = ipcMessage => typeof ipcMessage === 'string'\n\t? ipcMessage\n\t: inspect(ipcMessage);\n\nconst serializeMessagePart = messagePart => Array.isArray(messagePart)\n\t? messagePart.map(messageItem => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join('\\n')\n\t: serializeMessageItem(messagePart);\n\nconst serializeMessageItem = messageItem => {\n\tif (typeof messageItem === 'string') {\n\t\treturn messageItem;\n\t}\n\n\tif (isUint8Array(messageItem)) {\n\t\treturn uint8ArrayToString(messageItem);\n\t}\n\n\treturn '';\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2483, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/return/result.js"],"sourcesContent":["import {getSignalDescription} from '../terminate/signal.js';\nimport {getDurationMs} from './duration.js';\nimport {getFinalError} from './final-error.js';\nimport {createMessages} from './message.js';\n\n// Object returned on subprocess success\nexport const makeSuccessResult = ({\n\tcommand,\n\tescapedCommand,\n\tstdio,\n\tall,\n\tipcOutput,\n\toptions: {cwd},\n\tstartTime,\n}) => omitUndefinedProperties({\n\tcommand,\n\tescapedCommand,\n\tcwd,\n\tdurationMs: getDurationMs(startTime),\n\tfailed: false,\n\ttimedOut: false,\n\tisCanceled: false,\n\tisGracefullyCanceled: false,\n\tisTerminated: false,\n\tisMaxBuffer: false,\n\tisForcefullyTerminated: false,\n\texitCode: 0,\n\tstdout: stdio[1],\n\tstderr: stdio[2],\n\tall,\n\tstdio,\n\tipcOutput,\n\tpipedFrom: [],\n});\n\n// Object returned on subprocess failure before spawning\nexport const makeEarlyError = ({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tfileDescriptors,\n\toptions,\n\tstartTime,\n\tisSync,\n}) => makeError({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut: false,\n\tisCanceled: false,\n\tisGracefullyCanceled: false,\n\tisMaxBuffer: false,\n\tisForcefullyTerminated: false,\n\tstdio: Array.from({length: fileDescriptors.length}),\n\tipcOutput: [],\n\toptions,\n\tisSync,\n});\n\n// Object returned on subprocess failure\nexport const makeError = ({\n\terror: originalError,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\texitCode: rawExitCode,\n\tsignal: rawSignal,\n\tstdio,\n\tall,\n\tipcOutput,\n\toptions: {\n\t\ttimeoutDuration,\n\t\ttimeout = timeoutDuration,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t\tcwd,\n\t\tmaxBuffer,\n\t},\n\tisSync,\n}) => {\n\tconst {exitCode, signal, signalDescription} = normalizeExitPayload(rawExitCode, rawSignal);\n\tconst {originalMessage, shortMessage, message} = createMessages({\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\toriginalError,\n\t\tsignal,\n\t\tsignalDescription,\n\t\texitCode,\n\t\tescapedCommand,\n\t\ttimedOut,\n\t\tisCanceled,\n\t\tisGracefullyCanceled,\n\t\tisMaxBuffer,\n\t\tisForcefullyTerminated,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t\tmaxBuffer,\n\t\ttimeout,\n\t\tcwd,\n\t});\n\tconst error = getFinalError(originalError, message, isSync);\n\tObject.assign(error, getErrorProperties({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\ttimedOut,\n\t\tisCanceled,\n\t\tisGracefullyCanceled,\n\t\tisMaxBuffer,\n\t\tisForcefullyTerminated,\n\t\texitCode,\n\t\tsignal,\n\t\tsignalDescription,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\tcwd,\n\t\toriginalMessage,\n\t\tshortMessage,\n\t}));\n\treturn error;\n};\n\nconst getErrorProperties = ({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\texitCode,\n\tsignal,\n\tsignalDescription,\n\tstdio,\n\tall,\n\tipcOutput,\n\tcwd,\n\toriginalMessage,\n\tshortMessage,\n}) => omitUndefinedProperties({\n\tshortMessage,\n\toriginalMessage,\n\tcommand,\n\tescapedCommand,\n\tcwd,\n\tdurationMs: getDurationMs(startTime),\n\tfailed: true,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisTerminated: signal !== undefined,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\texitCode,\n\tsignal,\n\tsignalDescription,\n\tcode: error.cause?.code,\n\tstdout: stdio[1],\n\tstderr: stdio[2],\n\tall,\n\tstdio,\n\tipcOutput,\n\tpipedFrom: [],\n});\n\nconst omitUndefinedProperties = result => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== undefined));\n\n// `signal` and `exitCode` emitted on `subprocess.on('exit')` event can be `null`.\n// We normalize them to `undefined`\nconst normalizeExitPayload = (rawExitCode, rawSignal) => {\n\tconst exitCode = rawExitCode === null ? undefined : rawExitCode;\n\tconst signal = rawSignal === null ? undefined : rawSignal;\n\tconst signalDescription = signal === undefined ? undefined : getSignalDescription(rawSignal);\n\treturn {exitCode, signal, signalDescription};\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2623, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/verbose/error.js"],"sourcesContent":["import {verboseLog} from './log.js';\n\n// When `verbose` is `short|full|custom`, print each command's error when it fails\nexport const logError = (result, verboseInfo) => {\n\tif (result.failed) {\n\t\tverboseLog({\n\t\t\ttype: 'error',\n\t\t\tverboseMessage: result.shortMessage,\n\t\t\tverboseInfo,\n\t\t\tresult,\n\t\t});\n\t}\n};\n"],"names":[],"mappings":";;;;AAAA;;AAGO,MAAM,WAAW,CAAC,QAAQ;IAChC,IAAI,OAAO,MAAM,EAAE;QAClB,IAAA,4JAAU,EAAC;YACV,MAAM;YACN,gBAAgB,OAAO,YAAY;YACnC;YACA;QACD;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2643, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/verbose/complete.js"],"sourcesContent":["import prettyMs from 'pretty-ms';\nimport {isVerbose} from './values.js';\nimport {verboseLog} from './log.js';\nimport {logError} from './error.js';\n\n// When `verbose` is `short|full|custom`, print each command's completion, duration and error\nexport const logResult = (result, verboseInfo) => {\n\tif (!isVerbose(verboseInfo)) {\n\t\treturn;\n\t}\n\n\tlogError(result, verboseInfo);\n\tlogDuration(result, verboseInfo);\n};\n\nconst logDuration = (result, verboseInfo) => {\n\tconst verboseMessage = `(done in ${prettyMs(result.durationMs)})`;\n\tverboseLog({\n\t\ttype: 'duration',\n\t\tverboseMessage,\n\t\tverboseInfo,\n\t\tresult,\n\t});\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAGO,MAAM,YAAY,CAAC,QAAQ;IACjC,IAAI,CAAC,IAAA,8JAAS,EAAC,cAAc;QAC5B;IACD;IAEA,IAAA,4JAAQ,EAAC,QAAQ;IACjB,YAAY,QAAQ;AACrB;AAEA,MAAM,cAAc,CAAC,QAAQ;IAC5B,MAAM,iBAAiB,CAAC,SAAS,EAAE,IAAA,gJAAQ,EAAC,OAAO,UAAU,EAAE,CAAC,CAAC;IACjE,IAAA,4JAAU,EAAC;QACV,MAAM;QACN;QACA;QACA;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2675, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/return/reject.js"],"sourcesContent":["import {logResult} from '../verbose/complete.js';\n\n// Applies the `reject` option.\n// Also print the final log line with `verbose`.\nexport const handleResult = (result, verboseInfo, {reject}) => {\n\tlogResult(result, verboseInfo);\n\n\tif (result.failed && reject) {\n\t\tthrow result;\n\t}\n\n\treturn result;\n};\n"],"names":[],"mappings":";;;;AAAA;;AAIO,MAAM,eAAe,CAAC,QAAQ,aAAa,EAAC,MAAM,EAAC;IACzD,IAAA,gKAAS,EAAC,QAAQ;IAElB,IAAI,OAAO,MAAM,IAAI,QAAQ;QAC5B,MAAM;IACP;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2692, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/stdio/type.js"],"sourcesContent":["import {isStream as isNodeStream, isDuplexStream} from 'is-stream';\nimport isPlainObj from 'is-plain-obj';\nimport {isUint8Array} from '../utils/uint-array.js';\n\n// The `stdin`/`stdout`/`stderr` option can be of many types. This detects it.\nexport const getStdioItemType = (value, optionName) => {\n\tif (isAsyncGenerator(value)) {\n\t\treturn 'asyncGenerator';\n\t}\n\n\tif (isSyncGenerator(value)) {\n\t\treturn 'generator';\n\t}\n\n\tif (isUrl(value)) {\n\t\treturn 'fileUrl';\n\t}\n\n\tif (isFilePathObject(value)) {\n\t\treturn 'filePath';\n\t}\n\n\tif (isWebStream(value)) {\n\t\treturn 'webStream';\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\treturn 'native';\n\t}\n\n\tif (isUint8Array(value)) {\n\t\treturn 'uint8Array';\n\t}\n\n\tif (isAsyncIterableObject(value)) {\n\t\treturn 'asyncIterable';\n\t}\n\n\tif (isIterableObject(value)) {\n\t\treturn 'iterable';\n\t}\n\n\tif (isTransformStream(value)) {\n\t\treturn getTransformStreamType({transform: value}, optionName);\n\t}\n\n\tif (isTransformOptions(value)) {\n\t\treturn getTransformObjectType(value, optionName);\n\t}\n\n\treturn 'native';\n};\n\nconst getTransformObjectType = (value, optionName) => {\n\tif (isDuplexStream(value.transform, {checkOpen: false})) {\n\t\treturn getDuplexType(value, optionName);\n\t}\n\n\tif (isTransformStream(value.transform)) {\n\t\treturn getTransformStreamType(value, optionName);\n\t}\n\n\treturn getGeneratorObjectType(value, optionName);\n};\n\nconst getDuplexType = (value, optionName) => {\n\tvalidateNonGeneratorType(value, optionName, 'Duplex stream');\n\treturn 'duplex';\n};\n\nconst getTransformStreamType = (value, optionName) => {\n\tvalidateNonGeneratorType(value, optionName, 'web TransformStream');\n\treturn 'webTransform';\n};\n\nconst validateNonGeneratorType = ({final, binary, objectMode}, optionName, typeName) => {\n\tcheckUndefinedOption(final, `${optionName}.final`, typeName);\n\tcheckUndefinedOption(binary, `${optionName}.binary`, typeName);\n\tcheckBooleanOption(objectMode, `${optionName}.objectMode`);\n};\n\nconst checkUndefinedOption = (value, optionName, typeName) => {\n\tif (value !== undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option can only be defined when using a generator, not a ${typeName}.`);\n\t}\n};\n\nconst getGeneratorObjectType = ({transform, final, binary, objectMode}, optionName) => {\n\tif (transform !== undefined && !isGenerator(transform)) {\n\t\tthrow new TypeError(`The \\`${optionName}.transform\\` option must be a generator, a Duplex stream or a web TransformStream.`);\n\t}\n\n\tif (isDuplexStream(final, {checkOpen: false})) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must not be a Duplex stream.`);\n\t}\n\n\tif (isTransformStream(final)) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must not be a web TransformStream.`);\n\t}\n\n\tif (final !== undefined && !isGenerator(final)) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must be a generator.`);\n\t}\n\n\tcheckBooleanOption(binary, `${optionName}.binary`);\n\tcheckBooleanOption(objectMode, `${optionName}.objectMode`);\n\n\treturn isAsyncGenerator(transform) || isAsyncGenerator(final) ? 'asyncGenerator' : 'generator';\n};\n\nconst checkBooleanOption = (value, optionName) => {\n\tif (value !== undefined && typeof value !== 'boolean') {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must use a boolean.`);\n\t}\n};\n\nconst isGenerator = value => isAsyncGenerator(value) || isSyncGenerator(value);\nexport const isAsyncGenerator = value => Object.prototype.toString.call(value) === '[object AsyncGeneratorFunction]';\nconst isSyncGenerator = value => Object.prototype.toString.call(value) === '[object GeneratorFunction]';\nconst isTransformOptions = value => isPlainObj(value)\n\t&& (value.transform !== undefined || value.final !== undefined);\n\nexport const isUrl = value => Object.prototype.toString.call(value) === '[object URL]';\nexport const isRegularUrl = value => isUrl(value) && value.protocol !== 'file:';\n\nconst isFilePathObject = value => isPlainObj(value)\n\t&& Object.keys(value).length > 0\n\t&& Object.keys(value).every(key => FILE_PATH_KEYS.has(key))\n\t&& isFilePathString(value.file);\nconst FILE_PATH_KEYS = new Set(['file', 'append']);\nexport const isFilePathString = file => typeof file === 'string';\n\nexport const isUnknownStdioString = (type, value) => type === 'native'\n\t&& typeof value === 'string'\n\t&& !KNOWN_STDIO_STRINGS.has(value);\nconst KNOWN_STDIO_STRINGS = new Set(['ipc', 'ignore', 'inherit', 'overlapped', 'pipe']);\n\nconst isReadableStream = value => Object.prototype.toString.call(value) === '[object ReadableStream]';\nexport const isWritableStream = value => Object.prototype.toString.call(value) === '[object WritableStream]';\nconst isWebStream = value => isReadableStream(value) || isWritableStream(value);\nconst isTransformStream = value => isReadableStream(value?.readable) && isWritableStream(value?.writable);\n\nconst isAsyncIterableObject = value => isObject(value) && typeof value[Symbol.asyncIterator] === 'function';\nconst isIterableObject = value => isObject(value) && typeof value[Symbol.iterator] === 'function';\nconst isObject = value => typeof value === 'object' && value !== null;\n\n// Types which modify `subprocess.std*`\nexport const TRANSFORM_TYPES = new Set(['generator', 'asyncGenerator', 'duplex', 'webTransform']);\n// Types which write to a file or a file descriptor\nexport const FILE_TYPES = new Set(['fileUrl', 'filePath', 'fileNumber']);\n// When two file descriptors of this type share the same target, we need to do some special logic\nexport const SPECIAL_DUPLICATE_TYPES_SYNC = new Set(['fileUrl', 'filePath']);\nexport const SPECIAL_DUPLICATE_TYPES = new Set([...SPECIAL_DUPLICATE_TYPES_SYNC, 'webStream', 'nodeStream']);\n// Do not allow two file descriptors of this type sharing the same target\nexport const FORBID_DUPLICATE_TYPES = new Set(['webTransform', 'duplex']);\n\n// Convert types to human-friendly strings for error messages\nexport const TYPE_TO_MESSAGE = {\n\tgenerator: 'a generator',\n\tasyncGenerator: 'an async generator',\n\tfileUrl: 'a file URL',\n\tfilePath: 'a file path string',\n\tfileNumber: 'a file descriptor number',\n\twebStream: 'a web stream',\n\tnodeStream: 'a Node.js stream',\n\twebTransform: 'a web TransformStream',\n\tduplex: 'a Duplex stream',\n\tnative: 'any value',\n\titerable: 'an iterable',\n\tasyncIterable: 'an async iterable',\n\tstring: 'a string',\n\tuint8Array: 'a Uint8Array',\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2890, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/transform/object-mode.js"],"sourcesContent":["import {TRANSFORM_TYPES} from '../stdio/type.js';\n\n/*\nRetrieve the `objectMode`s of a single transform.\n`objectMode` determines the return value's type, i.e. the `readableObjectMode`.\nThe chunk argument's type is based on the previous generator's return value, i.e. the `writableObjectMode` is based on the previous `readableObjectMode`.\nThe last input's generator is read by `subprocess.stdin` which:\n- should not be in `objectMode` for performance reasons.\n- can only be strings, Buffers and Uint8Arrays.\nTherefore its `readableObjectMode` must be `false`.\nThe same applies to the first output's generator's `writableObjectMode`.\n*/\nexport const getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === 'output'\n\t? getOutputObjectModes(objectMode, index, newTransforms)\n\t: getInputObjectModes(objectMode, index, newTransforms);\n\nconst getOutputObjectModes = (objectMode, index, newTransforms) => {\n\tconst writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;\n\tconst readableObjectMode = objectMode ?? writableObjectMode;\n\treturn {writableObjectMode, readableObjectMode};\n};\n\nconst getInputObjectModes = (objectMode, index, newTransforms) => {\n\tconst writableObjectMode = index === 0\n\t\t? objectMode === true\n\t\t: newTransforms[index - 1].value.readableObjectMode;\n\tconst readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);\n\treturn {writableObjectMode, readableObjectMode};\n};\n\n// Retrieve the `objectMode` of a file descriptor, e.g. `stdout` or `stderr`\nexport const getFdObjectMode = (stdioItems, direction) => {\n\tconst lastTransform = stdioItems.findLast(({type}) => TRANSFORM_TYPES.has(type));\n\tif (lastTransform === undefined) {\n\t\treturn false;\n\t}\n\n\treturn direction === 'input'\n\t\t? lastTransform.value.writableObjectMode\n\t\t: lastTransform.value.readableObjectMode;\n};\n"],"names":[],"mappings":";;;;;;AAAA;;AAYO,MAAM,0BAA0B,CAAC,YAAY,OAAO,eAAe,YAAc,cAAc,WACnG,qBAAqB,YAAY,OAAO,iBACxC,oBAAoB,YAAY,OAAO;AAE1C,MAAM,uBAAuB,CAAC,YAAY,OAAO;IAChD,MAAM,qBAAqB,UAAU,KAAK,aAAa,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,kBAAkB;IAC3F,MAAM,qBAAqB,cAAc;IACzC,OAAO;QAAC;QAAoB;IAAkB;AAC/C;AAEA,MAAM,sBAAsB,CAAC,YAAY,OAAO;IAC/C,MAAM,qBAAqB,UAAU,IAClC,eAAe,OACf,aAAa,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,kBAAkB;IACpD,MAAM,qBAAqB,UAAU,cAAc,MAAM,GAAG,KAAK,CAAC,cAAc,kBAAkB;IAClG,OAAO;QAAC;QAAoB;IAAkB;AAC/C;AAGO,MAAM,kBAAkB,CAAC,YAAY;IAC3C,MAAM,gBAAgB,WAAW,QAAQ,CAAC,CAAC,EAAC,IAAI,EAAC,GAAK,gKAAe,CAAC,GAAG,CAAC;IAC1E,IAAI,kBAAkB,WAAW;QAChC,OAAO;IACR;IAEA,OAAO,cAAc,UAClB,cAAc,KAAK,CAAC,kBAAkB,GACtC,cAAc,KAAK,CAAC,kBAAkB;AAC1C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2926, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/transform/normalize.js"],"sourcesContent":["import isPlainObj from 'is-plain-obj';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {getTransformObjectModes} from './object-mode.js';\n\n// Transforms generators/duplex/TransformStream can have multiple shapes.\n// This normalizes it and applies default values.\nexport const normalizeTransforms = (stdioItems, optionName, direction, options) => [\n\t...stdioItems.filter(({type}) => !TRANSFORM_TYPES.has(type)),\n\t...getTransforms(stdioItems, optionName, direction, options),\n];\n\nconst getTransforms = (stdioItems, optionName, direction, {encoding}) => {\n\tconst transforms = stdioItems.filter(({type}) => TRANSFORM_TYPES.has(type));\n\tconst newTransforms = Array.from({length: transforms.length});\n\n\tfor (const [index, stdioItem] of Object.entries(transforms)) {\n\t\tnewTransforms[index] = normalizeTransform({\n\t\t\tstdioItem,\n\t\t\tindex: Number(index),\n\t\t\tnewTransforms,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t\tencoding,\n\t\t});\n\t}\n\n\treturn sortTransforms(newTransforms, direction);\n};\n\nconst normalizeTransform = ({stdioItem, stdioItem: {type}, index, newTransforms, optionName, direction, encoding}) => {\n\tif (type === 'duplex') {\n\t\treturn normalizeDuplex({stdioItem, optionName});\n\t}\n\n\tif (type === 'webTransform') {\n\t\treturn normalizeTransformStream({\n\t\t\tstdioItem,\n\t\t\tindex,\n\t\t\tnewTransforms,\n\t\t\tdirection,\n\t\t});\n\t}\n\n\treturn normalizeGenerator({\n\t\tstdioItem,\n\t\tindex,\n\t\tnewTransforms,\n\t\tdirection,\n\t\tencoding,\n\t});\n};\n\nconst normalizeDuplex = ({\n\tstdioItem,\n\tstdioItem: {\n\t\tvalue: {\n\t\t\ttransform,\n\t\t\ttransform: {writableObjectMode, readableObjectMode},\n\t\t\tobjectMode = readableObjectMode,\n\t\t},\n\t},\n\toptionName,\n}) => {\n\tif (objectMode && !readableObjectMode) {\n\t\tthrow new TypeError(`The \\`${optionName}.objectMode\\` option can only be \\`true\\` if \\`new Duplex({objectMode: true})\\` is used.`);\n\t}\n\n\tif (!objectMode && readableObjectMode) {\n\t\tthrow new TypeError(`The \\`${optionName}.objectMode\\` option cannot be \\`false\\` if \\`new Duplex({objectMode: true})\\` is used.`);\n\t}\n\n\treturn {\n\t\t...stdioItem,\n\t\tvalue: {transform, writableObjectMode, readableObjectMode},\n\t};\n};\n\nconst normalizeTransformStream = ({stdioItem, stdioItem: {value}, index, newTransforms, direction}) => {\n\tconst {transform, objectMode} = isPlainObj(value) ? value : {transform: value};\n\tconst {writableObjectMode, readableObjectMode} = getTransformObjectModes(objectMode, index, newTransforms, direction);\n\treturn ({\n\t\t...stdioItem,\n\t\tvalue: {transform, writableObjectMode, readableObjectMode},\n\t});\n};\n\nconst normalizeGenerator = ({stdioItem, stdioItem: {value}, index, newTransforms, direction, encoding}) => {\n\tconst {\n\t\ttransform,\n\t\tfinal,\n\t\tbinary: binaryOption = false,\n\t\tpreserveNewlines = false,\n\t\tobjectMode,\n\t} = isPlainObj(value) ? value : {transform: value};\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {writableObjectMode, readableObjectMode} = getTransformObjectModes(objectMode, index, newTransforms, direction);\n\treturn {\n\t\t...stdioItem,\n\t\tvalue: {\n\t\t\ttransform,\n\t\t\tfinal,\n\t\t\tbinary,\n\t\t\tpreserveNewlines,\n\t\t\twritableObjectMode,\n\t\t\treadableObjectMode,\n\t\t},\n\t};\n};\n\nconst sortTransforms = (newTransforms, direction) => direction === 'input' ? newTransforms.reverse() : newTransforms;\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAIO,MAAM,sBAAsB,CAAC,YAAY,YAAY,WAAW,UAAY;WAC/E,WAAW,MAAM,CAAC,CAAC,EAAC,IAAI,EAAC,GAAK,CAAC,gKAAe,CAAC,GAAG,CAAC;WACnD,cAAc,YAAY,YAAY,WAAW;KACpD;AAED,MAAM,gBAAgB,CAAC,YAAY,YAAY,WAAW,EAAC,QAAQ,EAAC;IACnE,MAAM,aAAa,WAAW,MAAM,CAAC,CAAC,EAAC,IAAI,EAAC,GAAK,gKAAe,CAAC,GAAG,CAAC;IACrE,MAAM,gBAAgB,MAAM,IAAI,CAAC;QAAC,QAAQ,WAAW,MAAM;IAAA;IAE3D,KAAK,MAAM,CAAC,OAAO,UAAU,IAAI,OAAO,OAAO,CAAC,YAAa;QAC5D,aAAa,CAAC,MAAM,GAAG,mBAAmB;YACzC;YACA,OAAO,OAAO;YACd;YACA;YACA;YACA;QACD;IACD;IAEA,OAAO,eAAe,eAAe;AACtC;AAEA,MAAM,qBAAqB,CAAC,EAAC,SAAS,EAAE,WAAW,EAAC,IAAI,EAAC,EAAE,KAAK,EAAE,aAAa,EAAE,UAAU,EAAE,SAAS,EAAE,QAAQ,EAAC;IAChH,IAAI,SAAS,UAAU;QACtB,OAAO,gBAAgB;YAAC;YAAW;QAAU;IAC9C;IAEA,IAAI,SAAS,gBAAgB;QAC5B,OAAO,yBAAyB;YAC/B;YACA;YACA;YACA;QACD;IACD;IAEA,OAAO,mBAAmB;QACzB;QACA;QACA;QACA;QACA;IACD;AACD;AAEA,MAAM,kBAAkB,CAAC,EACxB,SAAS,EACT,WAAW,EACV,OAAO,EACN,SAAS,EACT,WAAW,EAAC,kBAAkB,EAAE,kBAAkB,EAAC,EACnD,aAAa,kBAAkB,EAC/B,EACD,EACD,UAAU,EACV;IACA,IAAI,cAAc,CAAC,oBAAoB;QACtC,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,wFAAwF,CAAC;IAClI;IAEA,IAAI,CAAC,cAAc,oBAAoB;QACtC,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,uFAAuF,CAAC;IACjI;IAEA,OAAO;QACN,GAAG,SAAS;QACZ,OAAO;YAAC;YAAW;YAAoB;QAAkB;IAC1D;AACD;AAEA,MAAM,2BAA2B,CAAC,EAAC,SAAS,EAAE,WAAW,EAAC,KAAK,EAAC,EAAE,KAAK,EAAE,aAAa,EAAE,SAAS,EAAC;IACjG,MAAM,EAAC,SAAS,EAAE,UAAU,EAAC,GAAG,IAAA,sJAAU,EAAC,SAAS,QAAQ;QAAC,WAAW;IAAK;IAC7E,MAAM,EAAC,kBAAkB,EAAE,kBAAkB,EAAC,GAAG,IAAA,sLAAuB,EAAC,YAAY,OAAO,eAAe;IAC3G,OAAQ;QACP,GAAG,SAAS;QACZ,OAAO;YAAC;YAAW;YAAoB;QAAkB;IAC1D;AACD;AAEA,MAAM,qBAAqB,CAAC,EAAC,SAAS,EAAE,WAAW,EAAC,KAAK,EAAC,EAAE,KAAK,EAAE,aAAa,EAAE,SAAS,EAAE,QAAQ,EAAC;IACrG,MAAM,EACL,SAAS,EACT,KAAK,EACL,QAAQ,eAAe,KAAK,EAC5B,mBAAmB,KAAK,EACxB,UAAU,EACV,GAAG,IAAA,sJAAU,EAAC,SAAS,QAAQ;QAAC,WAAW;IAAK;IACjD,MAAM,SAAS,gBAAgB,mLAAgB,CAAC,GAAG,CAAC;IACpD,MAAM,EAAC,kBAAkB,EAAE,kBAAkB,EAAC,GAAG,IAAA,sLAAuB,EAAC,YAAY,OAAO,eAAe;IAC3G,OAAO;QACN,GAAG,SAAS;QACZ,OAAO;YACN;YACA;YACA;YACA;YACA;YACA;QACD;IACD;AACD;AAEA,MAAM,iBAAiB,CAAC,eAAe,YAAc,cAAc,UAAU,cAAc,OAAO,KAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3035, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/stdio/direction.js"],"sourcesContent":["import process from 'node:process';\nimport {\n\tisStream as isNodeStream,\n\tisReadableStream as isNodeReadableStream,\n\tisWritableStream as isNodeWritableStream,\n} from 'is-stream';\nimport {isWritableStream} from './type.js';\n\n// For `stdio[fdNumber]` beyond stdin/stdout/stderr, we need to guess whether the value passed is intended for inputs or outputs.\n// This allows us to know whether to pipe _into_ or _from_ the stream.\n// When `stdio[fdNumber]` is a single value, this guess is fairly straightforward.\n// However, when it is an array instead, we also need to make sure the different values are not incompatible with each other.\nexport const getStreamDirection = (stdioItems, fdNumber, optionName) => {\n\tconst directions = stdioItems.map(stdioItem => getStdioItemDirection(stdioItem, fdNumber));\n\n\tif (directions.includes('input') && directions.includes('output')) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must not be an array of both readable and writable values.`);\n\t}\n\n\treturn directions.find(Boolean) ?? DEFAULT_DIRECTION;\n};\n\nconst getStdioItemDirection = ({type, value}, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);\n\n// `stdin`/`stdout`/`stderr` have a known direction\nconst KNOWN_DIRECTIONS = ['input', 'output', 'output'];\n\nconst anyDirection = () => undefined;\nconst alwaysInput = () => 'input';\n\n// `string` can only be added through the `input` option, i.e. does not need to be handled here\nconst guessStreamDirection = {\n\tgenerator: anyDirection,\n\tasyncGenerator: anyDirection,\n\tfileUrl: anyDirection,\n\tfilePath: anyDirection,\n\titerable: alwaysInput,\n\tasyncIterable: alwaysInput,\n\tuint8Array: alwaysInput,\n\twebStream: value => isWritableStream(value) ? 'output' : 'input',\n\tnodeStream(value) {\n\t\tif (!isNodeReadableStream(value, {checkOpen: false})) {\n\t\t\treturn 'output';\n\t\t}\n\n\t\treturn isNodeWritableStream(value, {checkOpen: false}) ? undefined : 'input';\n\t},\n\twebTransform: anyDirection,\n\tduplex: anyDirection,\n\tnative(value) {\n\t\tconst standardStreamDirection = getStandardStreamDirection(value);\n\t\tif (standardStreamDirection !== undefined) {\n\t\t\treturn standardStreamDirection;\n\t\t}\n\n\t\tif (isNodeStream(value, {checkOpen: false})) {\n\t\t\treturn guessStreamDirection.nodeStream(value);\n\t\t}\n\t},\n};\n\nconst getStandardStreamDirection = value => {\n\tif ([0, process.stdin].includes(value)) {\n\t\treturn 'input';\n\t}\n\n\tif ([1, 2, process.stdout, process.stderr].includes(value)) {\n\t\treturn 'output';\n\t}\n};\n\n// When ambiguous, we initially keep the direction as `undefined`.\n// This allows arrays of `stdio` values to resolve the ambiguity.\n// For example, `stdio[3]: DuplexStream` is ambiguous, but `stdio[3]: [DuplexStream, WritableStream]` is not.\n// When the ambiguity remains, we default to `output` since it is the most common use case for additional file descriptors.\nconst DEFAULT_DIRECTION = 'output';\n"],"names":[],"mappings":";;;;AAAA;AACA;AAKA;;;;AAMO,MAAM,qBAAqB,CAAC,YAAY,UAAU;IACxD,MAAM,aAAa,WAAW,GAAG,CAAC,CAAA,YAAa,sBAAsB,WAAW;IAEhF,IAAI,WAAW,QAAQ,CAAC,YAAY,WAAW,QAAQ,CAAC,WAAW;QAClE,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,oEAAoE,CAAC;IAC9G;IAEA,OAAO,WAAW,IAAI,CAAC,YAAY;AACpC;AAEA,MAAM,wBAAwB,CAAC,EAAC,IAAI,EAAE,KAAK,EAAC,EAAE,WAAa,gBAAgB,CAAC,SAAS,IAAI,oBAAoB,CAAC,KAAK,CAAC;AAEpH,mDAAmD;AACnD,MAAM,mBAAmB;IAAC;IAAS;IAAU;CAAS;AAEtD,MAAM,eAAe,IAAM;AAC3B,MAAM,cAAc,IAAM;AAE1B,+FAA+F;AAC/F,MAAM,uBAAuB;IAC5B,WAAW;IACX,gBAAgB;IAChB,SAAS;IACT,UAAU;IACV,UAAU;IACV,eAAe;IACf,YAAY;IACZ,WAAW,CAAA,QAAS,IAAA,iKAAgB,EAAC,SAAS,WAAW;IACzD,YAAW,KAAK;QACf,IAAI,CAAC,IAAA,yJAAoB,EAAC,OAAO;YAAC,WAAW;QAAK,IAAI;YACrD,OAAO;QACR;QAEA,OAAO,IAAA,yJAAoB,EAAC,OAAO;YAAC,WAAW;QAAK,KAAK,YAAY;IACtE;IACA,cAAc;IACd,QAAQ;IACR,QAAO,KAAK;QACX,MAAM,0BAA0B,2BAA2B;QAC3D,IAAI,4BAA4B,WAAW;YAC1C,OAAO;QACR;QAEA,IAAI,IAAA,iJAAY,EAAC,OAAO;YAAC,WAAW;QAAK,IAAI;YAC5C,OAAO,qBAAqB,UAAU,CAAC;QACxC;IACD;AACD;AAEA,MAAM,6BAA6B,CAAA;IAClC,IAAI;QAAC;QAAG,kIAAO,CAAC,KAAK;KAAC,CAAC,QAAQ,CAAC,QAAQ;QACvC,OAAO;IACR;IAEA,IAAI;QAAC;QAAG;QAAG,kIAAO,CAAC,MAAM;QAAE,kIAAO,CAAC,MAAM;KAAC,CAAC,QAAQ,CAAC,QAAQ;QAC3D,OAAO;IACR;AACD;AAEA,kEAAkE;AAClE,iEAAiE;AACjE,6GAA6G;AAC7G,2HAA2H;AAC3H,MAAM,oBAAoB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3120, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/array.js"],"sourcesContent":["// The `ipc` option adds an `ipc` item to the `stdio` option\nexport const normalizeIpcStdioArray = (stdioArray, ipc) => ipc && !stdioArray.includes('ipc')\n\t? [...stdioArray, 'ipc']\n\t: stdioArray;\n"],"names":[],"mappings":"AAAA,4DAA4D;;;;;AACrD,MAAM,yBAAyB,CAAC,YAAY,MAAQ,OAAO,CAAC,WAAW,QAAQ,CAAC,SACpF;WAAI;QAAY;KAAM,GACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3133, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/stdio/stdio-option.js"],"sourcesContent":["import {STANDARD_STREAMS_ALIASES} from '../utils/standard-stream.js';\nimport {normalizeIpcStdioArray} from '../ipc/array.js';\nimport {isFullVerbose} from '../verbose/values.js';\n\n// Add support for `stdin`/`stdout`/`stderr` as an alias for `stdio`.\n// Also normalize the `stdio` option.\nexport const normalizeStdioOption = ({stdio, ipc, buffer, ...options}, verboseInfo, isSync) => {\n\tconst stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue(stdioOption, fdNumber));\n\treturn isSync\n\t\t? normalizeStdioSync(stdioArray, buffer, verboseInfo)\n\t\t: normalizeIpcStdioArray(stdioArray, ipc);\n};\n\nconst getStdioArray = (stdio, options) => {\n\tif (stdio === undefined) {\n\t\treturn STANDARD_STREAMS_ALIASES.map(alias => options[alias]);\n\t}\n\n\tif (hasAlias(options)) {\n\t\tthrow new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${STANDARD_STREAMS_ALIASES.map(alias => `\\`${alias}\\``).join(', ')}`);\n\t}\n\n\tif (typeof stdio === 'string') {\n\t\treturn [stdio, stdio, stdio];\n\t}\n\n\tif (!Array.isArray(stdio)) {\n\t\tthrow new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n\t}\n\n\tconst length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);\n\treturn Array.from({length}, (_, fdNumber) => stdio[fdNumber]);\n};\n\nconst hasAlias = options => STANDARD_STREAMS_ALIASES.some(alias => options[alias] !== undefined);\n\nconst addDefaultValue = (stdioOption, fdNumber) => {\n\tif (Array.isArray(stdioOption)) {\n\t\treturn stdioOption.map(item => addDefaultValue(item, fdNumber));\n\t}\n\n\tif (stdioOption === null || stdioOption === undefined) {\n\t\treturn fdNumber >= STANDARD_STREAMS_ALIASES.length ? 'ignore' : 'pipe';\n\t}\n\n\treturn stdioOption;\n};\n\n// Using `buffer: false` with synchronous methods implies `stdout`/`stderr`: `ignore`.\n// Unless the output is needed, e.g. due to `verbose: 'full'` or to redirecting to a file.\nconst normalizeStdioSync = (stdioArray, buffer, verboseInfo) => stdioArray.map((stdioOption, fdNumber) =>\n\t!buffer[fdNumber]\n\t&& fdNumber !== 0\n\t&& !isFullVerbose(verboseInfo, fdNumber)\n\t&& isOutputPipeOnly(stdioOption)\n\t\t? 'ignore'\n\t\t: stdioOption);\n\nconst isOutputPipeOnly = stdioOption => stdioOption === 'pipe'\n\t|| (Array.isArray(stdioOption) && stdioOption.every(item => item === 'pipe'));\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAIO,MAAM,uBAAuB,CAAC,EAAC,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,SAAQ,EAAE,aAAa;IACnF,MAAM,aAAa,cAAc,OAAO,SAAS,GAAG,CAAC,CAAC,aAAa,WAAa,gBAAgB,aAAa;IAC7G,OAAO,SACJ,mBAAmB,YAAY,QAAQ,eACvC,IAAA,sKAAsB,EAAC,YAAY;AACvC;AAEA,MAAM,gBAAgB,CAAC,OAAO;IAC7B,IAAI,UAAU,WAAW;QACxB,OAAO,uLAAwB,CAAC,GAAG,CAAC,CAAA,QAAS,OAAO,CAAC,MAAM;IAC5D;IAEA,IAAI,SAAS,UAAU;QACtB,MAAM,IAAI,MAAM,CAAC,kEAAkE,EAAE,uLAAwB,CAAC,GAAG,CAAC,CAAA,QAAS,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,EAAE,IAAI,CAAC,OAAO;IACxJ;IAEA,IAAI,OAAO,UAAU,UAAU;QAC9B,OAAO;YAAC;YAAO;YAAO;SAAM;IAC7B;IAEA,IAAI,CAAC,MAAM,OAAO,CAAC,QAAQ;QAC1B,MAAM,IAAI,UAAU,CAAC,gEAAgE,EAAE,OAAO,MAAM,EAAE,CAAC;IACxG;IAEA,MAAM,SAAS,KAAK,GAAG,CAAC,MAAM,MAAM,EAAE,uLAAwB,CAAC,MAAM;IACrE,OAAO,MAAM,IAAI,CAAC;QAAC;IAAM,GAAG,CAAC,GAAG,WAAa,KAAK,CAAC,SAAS;AAC7D;AAEA,MAAM,WAAW,CAAA,UAAW,uLAAwB,CAAC,IAAI,CAAC,CAAA,QAAS,OAAO,CAAC,MAAM,KAAK;AAEtF,MAAM,kBAAkB,CAAC,aAAa;IACrC,IAAI,MAAM,OAAO,CAAC,cAAc;QAC/B,OAAO,YAAY,GAAG,CAAC,CAAA,OAAQ,gBAAgB,MAAM;IACtD;IAEA,IAAI,gBAAgB,QAAQ,gBAAgB,WAAW;QACtD,OAAO,YAAY,uLAAwB,CAAC,MAAM,GAAG,WAAW;IACjE;IAEA,OAAO;AACR;AAEA,sFAAsF;AACtF,0FAA0F;AAC1F,MAAM,qBAAqB,CAAC,YAAY,QAAQ,cAAgB,WAAW,GAAG,CAAC,CAAC,aAAa,WAC5F,CAAC,MAAM,CAAC,SAAS,IACd,aAAa,KACb,CAAC,IAAA,kKAAa,EAAC,aAAa,aAC5B,iBAAiB,eACjB,WACA;AAEJ,MAAM,mBAAmB,CAAA,cAAe,gBAAgB,UACnD,MAAM,OAAO,CAAC,gBAAgB,YAAY,KAAK,CAAC,CAAA,OAAQ,SAAS","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3187, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/stdio/native.js"],"sourcesContent":["import {readFileSync} from 'node:fs';\nimport tty from 'node:tty';\nimport {isStream as isNodeStream} from 'is-stream';\nimport {STANDARD_STREAMS} from '../utils/standard-stream.js';\nimport {bufferToUint8Array} from '../utils/uint-array.js';\nimport {serializeOptionValue} from '../arguments/fd-options.js';\n\n// When we use multiple `stdio` values for the same streams, we pass 'pipe' to `child_process.spawn()`.\n// We then emulate the piping done by core Node.js.\n// To do so, we transform the following values:\n//  - Node.js streams are marked as `type: nodeStream`\n//  - 'inherit' becomes `process.stdin|stdout|stderr`\n//  - any file descriptor integer becomes `process.stdio[fdNumber]`\n// All of the above transformations tell Execa to perform manual piping.\nexport const handleNativeStream = ({stdioItem, stdioItem: {type}, isStdioArray, fdNumber, direction, isSync}) => {\n\tif (!isStdioArray || type !== 'native') {\n\t\treturn stdioItem;\n\t}\n\n\treturn isSync\n\t\t? handleNativeStreamSync({stdioItem, fdNumber, direction})\n\t\t: handleNativeStreamAsync({stdioItem, fdNumber});\n};\n\n// Synchronous methods use a different logic.\n// 'inherit', file descriptors and process.std* are handled by readFileSync()/writeFileSync().\nconst handleNativeStreamSync = ({stdioItem, stdioItem: {value, optionName}, fdNumber, direction}) => {\n\tconst targetFd = getTargetFd({\n\t\tvalue,\n\t\toptionName,\n\t\tfdNumber,\n\t\tdirection,\n\t});\n\tif (targetFd !== undefined) {\n\t\treturn targetFd;\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\tthrow new TypeError(`The \\`${optionName}: Stream\\` option cannot both be an array and include a stream with synchronous methods.`);\n\t}\n\n\treturn stdioItem;\n};\n\nconst getTargetFd = ({value, optionName, fdNumber, direction}) => {\n\tconst targetFdNumber = getTargetFdNumber(value, fdNumber);\n\tif (targetFdNumber === undefined) {\n\t\treturn;\n\t}\n\n\tif (direction === 'output') {\n\t\treturn {type: 'fileNumber', value: targetFdNumber, optionName};\n\t}\n\n\tif (tty.isatty(targetFdNumber)) {\n\t\tthrow new TypeError(`The \\`${optionName}: ${serializeOptionValue(value)}\\` option is invalid: it cannot be a TTY with synchronous methods.`);\n\t}\n\n\treturn {type: 'uint8Array', value: bufferToUint8Array(readFileSync(targetFdNumber)), optionName};\n};\n\nconst getTargetFdNumber = (value, fdNumber) => {\n\tif (value === 'inherit') {\n\t\treturn fdNumber;\n\t}\n\n\tif (typeof value === 'number') {\n\t\treturn value;\n\t}\n\n\tconst standardStreamIndex = STANDARD_STREAMS.indexOf(value);\n\tif (standardStreamIndex !== -1) {\n\t\treturn standardStreamIndex;\n\t}\n};\n\nconst handleNativeStreamAsync = ({stdioItem, stdioItem: {value, optionName}, fdNumber}) => {\n\tif (value === 'inherit') {\n\t\treturn {type: 'nodeStream', value: getStandardStream(fdNumber, value, optionName), optionName};\n\t}\n\n\tif (typeof value === 'number') {\n\t\treturn {type: 'nodeStream', value: getStandardStream(value, value, optionName), optionName};\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\treturn {type: 'nodeStream', value, optionName};\n\t}\n\n\treturn stdioItem;\n};\n\n// Node.js does not allow to easily retrieve file descriptors beyond stdin/stdout/stderr as streams.\n//  - `fs.createReadStream()`/`fs.createWriteStream()` with the `fd` option do not work with character devices that use blocking reads/writes (such as interactive TTYs).\n//  - Using a TCP `Socket` would work but be rather complex to implement.\n// Since this is an edge case, we simply throw an error message.\n// See https://github.com/sindresorhus/execa/pull/643#discussion_r1435905707\nconst getStandardStream = (fdNumber, value, optionName) => {\n\tconst standardStream = STANDARD_STREAMS[fdNumber];\n\n\tif (standardStream === undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}: ${value}\\` option is invalid: no such standard stream.`);\n\t}\n\n\treturn standardStream;\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AASO,MAAM,qBAAqB,CAAC,EAAC,SAAS,EAAE,WAAW,EAAC,IAAI,EAAC,EAAE,YAAY,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAC;IAC3G,IAAI,CAAC,gBAAgB,SAAS,UAAU;QACvC,OAAO;IACR;IAEA,OAAO,SACJ,uBAAuB;QAAC;QAAW;QAAU;IAAS,KACtD,wBAAwB;QAAC;QAAW;IAAQ;AAChD;AAEA,6CAA6C;AAC7C,8FAA8F;AAC9F,MAAM,yBAAyB,CAAC,EAAC,SAAS,EAAE,WAAW,EAAC,KAAK,EAAE,UAAU,EAAC,EAAE,QAAQ,EAAE,SAAS,EAAC;IAC/F,MAAM,WAAW,YAAY;QAC5B;QACA;QACA;QACA;IACD;IACA,IAAI,aAAa,WAAW;QAC3B,OAAO;IACR;IAEA,IAAI,IAAA,iJAAY,EAAC,OAAO;QAAC,WAAW;IAAK,IAAI;QAC5C,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,wFAAwF,CAAC;IAClI;IAEA,OAAO;AACR;AAEA,MAAM,cAAc,CAAC,EAAC,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,SAAS,EAAC;IAC5D,MAAM,iBAAiB,kBAAkB,OAAO;IAChD,IAAI,mBAAmB,WAAW;QACjC;IACD;IAEA,IAAI,cAAc,UAAU;QAC3B,OAAO;YAAC,MAAM;YAAc,OAAO;YAAgB;QAAU;IAC9D;IAEA,IAAI,0HAAG,CAAC,MAAM,CAAC,iBAAiB;QAC/B,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,EAAE,EAAE,IAAA,kLAAoB,EAAC,OAAO,kEAAkE,CAAC;IAC5I;IAEA,OAAO;QAAC,MAAM;QAAc,OAAO,IAAA,4KAAkB,EAAC,IAAA,6HAAY,EAAC;QAAkB;IAAU;AAChG;AAEA,MAAM,oBAAoB,CAAC,OAAO;IACjC,IAAI,UAAU,WAAW;QACxB,OAAO;IACR;IAEA,IAAI,OAAO,UAAU,UAAU;QAC9B,OAAO;IACR;IAEA,MAAM,sBAAsB,+KAAgB,CAAC,OAAO,CAAC;IACrD,IAAI,wBAAwB,CAAC,GAAG;QAC/B,OAAO;IACR;AACD;AAEA,MAAM,0BAA0B,CAAC,EAAC,SAAS,EAAE,WAAW,EAAC,KAAK,EAAE,UAAU,EAAC,EAAE,QAAQ,EAAC;IACrF,IAAI,UAAU,WAAW;QACxB,OAAO;YAAC,MAAM;YAAc,OAAO,kBAAkB,UAAU,OAAO;YAAa;QAAU;IAC9F;IAEA,IAAI,OAAO,UAAU,UAAU;QAC9B,OAAO;YAAC,MAAM;YAAc,OAAO,kBAAkB,OAAO,OAAO;YAAa;QAAU;IAC3F;IAEA,IAAI,IAAA,iJAAY,EAAC,OAAO;QAAC,WAAW;IAAK,IAAI;QAC5C,OAAO;YAAC,MAAM;YAAc;YAAO;QAAU;IAC9C;IAEA,OAAO;AACR;AAEA,oGAAoG;AACpG,yKAAyK;AACzK,yEAAyE;AACzE,gEAAgE;AAChE,4EAA4E;AAC5E,MAAM,oBAAoB,CAAC,UAAU,OAAO;IAC3C,MAAM,iBAAiB,+KAAgB,CAAC,SAAS;IAEjD,IAAI,mBAAmB,WAAW;QACjC,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,EAAE,EAAE,MAAM,8CAA8C,CAAC;IAClG;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3310, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/stdio/input-option.js"],"sourcesContent":["import {isReadableStream} from 'is-stream';\nimport {isUint8Array} from '../utils/uint-array.js';\nimport {isUrl, isFilePathString} from './type.js';\n\n// Append the `stdin` option with the `input` and `inputFile` options\nexport const handleInputOptions = ({input, inputFile}, fdNumber) => fdNumber === 0\n\t? [\n\t\t...handleInputOption(input),\n\t\t...handleInputFileOption(inputFile),\n\t]\n\t: [];\n\nconst handleInputOption = input => input === undefined ? [] : [{\n\ttype: getInputType(input),\n\tvalue: input,\n\toptionName: 'input',\n}];\n\nconst getInputType = input => {\n\tif (isReadableStream(input, {checkOpen: false})) {\n\t\treturn 'nodeStream';\n\t}\n\n\tif (typeof input === 'string') {\n\t\treturn 'string';\n\t}\n\n\tif (isUint8Array(input)) {\n\t\treturn 'uint8Array';\n\t}\n\n\tthrow new Error('The `input` option must be a string, a Uint8Array or a Node.js Readable stream.');\n};\n\nconst handleInputFileOption = inputFile => inputFile === undefined ? [] : [{\n\t...getInputFileType(inputFile),\n\toptionName: 'inputFile',\n}];\n\nconst getInputFileType = inputFile => {\n\tif (isUrl(inputFile)) {\n\t\treturn {type: 'fileUrl', value: inputFile};\n\t}\n\n\tif (isFilePathString(inputFile)) {\n\t\treturn {type: 'filePath', value: {file: inputFile}};\n\t}\n\n\tthrow new Error('The `inputFile` option must be a file path string or a file URL.');\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAGO,MAAM,qBAAqB,CAAC,EAAC,KAAK,EAAE,SAAS,EAAC,EAAE,WAAa,aAAa,IAC9E;WACE,kBAAkB;WAClB,sBAAsB;KACzB,GACC,EAAE;AAEL,MAAM,oBAAoB,CAAA,QAAS,UAAU,YAAY,EAAE,GAAG;QAAC;YAC9D,MAAM,aAAa;YACnB,OAAO;YACP,YAAY;QACb;KAAE;AAEF,MAAM,eAAe,CAAA;IACpB,IAAI,IAAA,yJAAgB,EAAC,OAAO;QAAC,WAAW;IAAK,IAAI;QAChD,OAAO;IACR;IAEA,IAAI,OAAO,UAAU,UAAU;QAC9B,OAAO;IACR;IAEA,IAAI,IAAA,sKAAY,EAAC,QAAQ;QACxB,OAAO;IACR;IAEA,MAAM,IAAI,MAAM;AACjB;AAEA,MAAM,wBAAwB,CAAA,YAAa,cAAc,YAAY,EAAE,GAAG;QAAC;YAC1E,GAAG,iBAAiB,UAAU;YAC9B,YAAY;QACb;KAAE;AAEF,MAAM,mBAAmB,CAAA;IACxB,IAAI,IAAA,sJAAK,EAAC,YAAY;QACrB,OAAO;YAAC,MAAM;YAAW,OAAO;QAAS;IAC1C;IAEA,IAAI,IAAA,iKAAgB,EAAC,YAAY;QAChC,OAAO;YAAC,MAAM;YAAY,OAAO;gBAAC,MAAM;YAAS;QAAC;IACnD;IAEA,MAAM,IAAI,MAAM;AACjB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3372, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/stdio/duplicate.js"],"sourcesContent":["import {\n\tSPECIAL_DUPLICATE_TYPES_SYNC,\n\tSPECIAL_DUPLICATE_TYPES,\n\tFORBID_DUPLICATE_TYPES,\n\tTYPE_TO_MESSAGE,\n} from './type.js';\n\n// Duplicates in the same file descriptor is most likely an error.\n// However, this can be useful with generators.\nexport const filterDuplicates = stdioItems => stdioItems.filter((stdioItemOne, indexOne) =>\n\tstdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value\n\t\t|| indexOne >= indexTwo\n\t\t|| stdioItemOne.type === 'generator'\n\t\t|| stdioItemOne.type === 'asyncGenerator'));\n\n// Check if two file descriptors are sharing the same target.\n// For example `{stdout: {file: './output.txt'}, stderr: {file: './output.txt'}}`.\nexport const getDuplicateStream = ({stdioItem: {type, value, optionName}, direction, fileDescriptors, isSync}) => {\n\tconst otherStdioItems = getOtherStdioItems(fileDescriptors, type);\n\tif (otherStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tif (isSync) {\n\t\tvalidateDuplicateStreamSync({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t\treturn;\n\t}\n\n\tif (SPECIAL_DUPLICATE_TYPES.has(type)) {\n\t\treturn getDuplicateStreamInstance({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t}\n\n\tif (FORBID_DUPLICATE_TYPES.has(type)) {\n\t\tvalidateDuplicateTransform({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t});\n\t}\n};\n\n// Values shared by multiple file descriptors\nconst getOtherStdioItems = (fileDescriptors, type) => fileDescriptors\n\t.flatMap(({direction, stdioItems}) => stdioItems\n\t\t.filter(stdioItem => stdioItem.type === type)\n\t\t.map((stdioItem => ({...stdioItem, direction}))));\n\n// With `execaSync()`, do not allow setting a file path both in input and output\nconst validateDuplicateStreamSync = ({otherStdioItems, type, value, optionName, direction}) => {\n\tif (SPECIAL_DUPLICATE_TYPES_SYNC.has(type)) {\n\t\tgetDuplicateStreamInstance({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t}\n};\n\n// When two file descriptors share the file or stream, we need to re-use the same underlying stream.\n// Otherwise, the stream would be closed twice when piping ends.\n// This is only an issue with output file descriptors.\n// This is not a problem with generator functions since those create a new instance for each file descriptor.\n// We also forbid input and output file descriptors sharing the same file or stream, since that does not make sense.\nconst getDuplicateStreamInstance = ({otherStdioItems, type, value, optionName, direction}) => {\n\tconst duplicateStdioItems = otherStdioItems.filter(stdioItem => hasSameValue(stdioItem, value));\n\tif (duplicateStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tconst differentStdioItem = duplicateStdioItems.find(stdioItem => stdioItem.direction !== direction);\n\tthrowOnDuplicateStream(differentStdioItem, optionName, type);\n\n\treturn direction === 'output' ? duplicateStdioItems[0].stream : undefined;\n};\n\nconst hasSameValue = ({type, value}, secondValue) => {\n\tif (type === 'filePath') {\n\t\treturn value.file === secondValue.file;\n\t}\n\n\tif (type === 'fileUrl') {\n\t\treturn value.href === secondValue.href;\n\t}\n\n\treturn value === secondValue;\n};\n\n// We do not allow two file descriptors to share the same Duplex or TransformStream.\n// This is because those are set directly to `subprocess.std*`.\n// For example, this could result in `subprocess.stdout` and `subprocess.stderr` being the same value.\n// This means reading from either would get data from both stdout and stderr.\nconst validateDuplicateTransform = ({otherStdioItems, type, value, optionName}) => {\n\tconst duplicateStdioItem = otherStdioItems.find(({value: {transform}}) => transform === value.transform);\n\tthrowOnDuplicateStream(duplicateStdioItem, optionName, type);\n};\n\nconst throwOnDuplicateStream = (stdioItem, optionName, type) => {\n\tif (stdioItem !== undefined) {\n\t\tthrow new TypeError(`The \\`${stdioItem.optionName}\\` and \\`${optionName}\\` options must not target ${TYPE_TO_MESSAGE[type]} that is the same.`);\n\t}\n};\n"],"names":[],"mappings":";;;;;;AAAA;;AASO,MAAM,mBAAmB,CAAA,aAAc,WAAW,MAAM,CAAC,CAAC,cAAc,WAC9E,WAAW,KAAK,CAAC,CAAC,cAAc,WAAa,aAAa,KAAK,KAAK,aAAa,KAAK,IAClF,YAAY,YACZ,aAAa,IAAI,KAAK,eACtB,aAAa,IAAI,KAAK;AAIpB,MAAM,qBAAqB,CAAC,EAAC,WAAW,EAAC,IAAI,EAAE,KAAK,EAAE,UAAU,EAAC,EAAE,SAAS,EAAE,eAAe,EAAE,MAAM,EAAC;IAC5G,MAAM,kBAAkB,mBAAmB,iBAAiB;IAC5D,IAAI,gBAAgB,MAAM,KAAK,GAAG;QACjC;IACD;IAEA,IAAI,QAAQ;QACX,4BAA4B;YAC3B;YACA;YACA;YACA;YACA;QACD;QACA;IACD;IAEA,IAAI,wKAAuB,CAAC,GAAG,CAAC,OAAO;QACtC,OAAO,2BAA2B;YACjC;YACA;YACA;YACA;YACA;QACD;IACD;IAEA,IAAI,uKAAsB,CAAC,GAAG,CAAC,OAAO;QACrC,2BAA2B;YAC1B;YACA;YACA;YACA;QACD;IACD;AACD;AAEA,6CAA6C;AAC7C,MAAM,qBAAqB,CAAC,iBAAiB,OAAS,gBACpD,OAAO,CAAC,CAAC,EAAC,SAAS,EAAE,UAAU,EAAC,GAAK,WACpC,MAAM,CAAC,CAAA,YAAa,UAAU,IAAI,KAAK,MACvC,GAAG,CAAE,CAAA,YAAa,CAAC;gBAAC,GAAG,SAAS;gBAAE;YAAS,CAAC;AAE/C,gFAAgF;AAChF,MAAM,8BAA8B,CAAC,EAAC,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,SAAS,EAAC;IACzF,IAAI,6KAA4B,CAAC,GAAG,CAAC,OAAO;QAC3C,2BAA2B;YAC1B;YACA;YACA;YACA;YACA;QACD;IACD;AACD;AAEA,oGAAoG;AACpG,gEAAgE;AAChE,sDAAsD;AACtD,6GAA6G;AAC7G,oHAAoH;AACpH,MAAM,6BAA6B,CAAC,EAAC,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,SAAS,EAAC;IACxF,MAAM,sBAAsB,gBAAgB,MAAM,CAAC,CAAA,YAAa,aAAa,WAAW;IACxF,IAAI,oBAAoB,MAAM,KAAK,GAAG;QACrC;IACD;IAEA,MAAM,qBAAqB,oBAAoB,IAAI,CAAC,CAAA,YAAa,UAAU,SAAS,KAAK;IACzF,uBAAuB,oBAAoB,YAAY;IAEvD,OAAO,cAAc,WAAW,mBAAmB,CAAC,EAAE,CAAC,MAAM,GAAG;AACjE;AAEA,MAAM,eAAe,CAAC,EAAC,IAAI,EAAE,KAAK,EAAC,EAAE;IACpC,IAAI,SAAS,YAAY;QACxB,OAAO,MAAM,IAAI,KAAK,YAAY,IAAI;IACvC;IAEA,IAAI,SAAS,WAAW;QACvB,OAAO,MAAM,IAAI,KAAK,YAAY,IAAI;IACvC;IAEA,OAAO,UAAU;AAClB;AAEA,oFAAoF;AACpF,+DAA+D;AAC/D,sGAAsG;AACtG,6EAA6E;AAC7E,MAAM,6BAA6B,CAAC,EAAC,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAC;IAC7E,MAAM,qBAAqB,gBAAgB,IAAI,CAAC,CAAC,EAAC,OAAO,EAAC,SAAS,EAAC,EAAC,GAAK,cAAc,MAAM,SAAS;IACvG,uBAAuB,oBAAoB,YAAY;AACxD;AAEA,MAAM,yBAAyB,CAAC,WAAW,YAAY;IACtD,IAAI,cAAc,WAAW;QAC5B,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,UAAU,UAAU,CAAC,SAAS,EAAE,WAAW,2BAA2B,EAAE,gKAAe,CAAC,KAAK,CAAC,kBAAkB,CAAC;IAC/I;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3471, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/stdio/handle.js"],"sourcesContent":["import {getStreamName, isStandardStream} from '../utils/standard-stream.js';\nimport {normalizeTransforms} from '../transform/normalize.js';\nimport {getFdObjectMode} from '../transform/object-mode.js';\nimport {\n\tgetStdioItemType,\n\tisRegularUrl,\n\tisUnknownStdioString,\n\tFILE_TYPES,\n} from './type.js';\nimport {getStreamDirection} from './direction.js';\nimport {normalizeStdioOption} from './stdio-option.js';\nimport {handleNativeStream} from './native.js';\nimport {handleInputOptions} from './input-option.js';\nimport {filterDuplicates, getDuplicateStream} from './duplicate.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async/sync mode\n// They are converted into an array of `fileDescriptors`.\n// Each `fileDescriptor` is normalized, validated and contains all information necessary for further handling.\nexport const handleStdio = (addProperties, options, verboseInfo, isSync) => {\n\tconst stdio = normalizeStdioOption(options, verboseInfo, isSync);\n\tconst initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({\n\t\tstdioOption,\n\t\tfdNumber,\n\t\toptions,\n\t\tisSync,\n\t}));\n\tconst fileDescriptors = getFinalFileDescriptors({\n\t\tinitialFileDescriptors,\n\t\taddProperties,\n\t\toptions,\n\t\tisSync,\n\t});\n\toptions.stdio = fileDescriptors.map(({stdioItems}) => forwardStdio(stdioItems));\n\treturn fileDescriptors;\n};\n\nconst getFileDescriptor = ({stdioOption, fdNumber, options, isSync}) => {\n\tconst optionName = getStreamName(fdNumber);\n\tconst {stdioItems: initialStdioItems, isStdioArray} = initializeStdioItems({\n\t\tstdioOption,\n\t\tfdNumber,\n\t\toptions,\n\t\toptionName,\n\t});\n\tconst direction = getStreamDirection(initialStdioItems, fdNumber, optionName);\n\tconst stdioItems = initialStdioItems.map(stdioItem => handleNativeStream({\n\t\tstdioItem,\n\t\tisStdioArray,\n\t\tfdNumber,\n\t\tdirection,\n\t\tisSync,\n\t}));\n\tconst normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);\n\tconst objectMode = getFdObjectMode(normalizedStdioItems, direction);\n\tvalidateFileObjectMode(normalizedStdioItems, objectMode);\n\treturn {direction, objectMode, stdioItems: normalizedStdioItems};\n};\n\n// We make sure passing an array with a single item behaves the same as passing that item without an array.\n// This is what users would expect.\n// For example, `stdout: ['ignore']` behaves the same as `stdout: 'ignore'`.\nconst initializeStdioItems = ({stdioOption, fdNumber, options, optionName}) => {\n\tconst values = Array.isArray(stdioOption) ? stdioOption : [stdioOption];\n\tconst initialStdioItems = [\n\t\t...values.map(value => initializeStdioItem(value, optionName)),\n\t\t...handleInputOptions(options, fdNumber),\n\t];\n\n\tconst stdioItems = filterDuplicates(initialStdioItems);\n\tconst isStdioArray = stdioItems.length > 1;\n\tvalidateStdioArray(stdioItems, isStdioArray, optionName);\n\tvalidateStreams(stdioItems);\n\treturn {stdioItems, isStdioArray};\n};\n\nconst initializeStdioItem = (value, optionName) => ({\n\ttype: getStdioItemType(value, optionName),\n\tvalue,\n\toptionName,\n});\n\nconst validateStdioArray = (stdioItems, isStdioArray, optionName) => {\n\tif (stdioItems.length === 0) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must not be an empty array.`);\n\t}\n\n\tif (!isStdioArray) {\n\t\treturn;\n\t}\n\n\tfor (const {value, optionName} of stdioItems) {\n\t\tif (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {\n\t\t\tthrow new Error(`The \\`${optionName}\\` option must not include \\`${value}\\`.`);\n\t\t}\n\t}\n};\n\n// Using those `stdio` values together with others for the same stream does not make sense, so we make it fail.\n// However, we do allow it if the array has a single item.\nconst INVALID_STDIO_ARRAY_OPTIONS = new Set(['ignore', 'ipc']);\n\nconst validateStreams = stdioItems => {\n\tfor (const stdioItem of stdioItems) {\n\t\tvalidateFileStdio(stdioItem);\n\t}\n};\n\nconst validateFileStdio = ({type, value, optionName}) => {\n\tif (isRegularUrl(value)) {\n\t\tthrow new TypeError(`The \\`${optionName}: URL\\` option must use the \\`file:\\` scheme.\nFor example, you can use the \\`pathToFileURL()\\` method of the \\`url\\` core module.`);\n\t}\n\n\tif (isUnknownStdioString(type, value)) {\n\t\tthrow new TypeError(`The \\`${optionName}: { file: '...' }\\` option must be used instead of \\`${optionName}: '...'\\`.`);\n\t}\n};\n\nconst validateFileObjectMode = (stdioItems, objectMode) => {\n\tif (!objectMode) {\n\t\treturn;\n\t}\n\n\tconst fileStdioItem = stdioItems.find(({type}) => FILE_TYPES.has(type));\n\tif (fileStdioItem !== undefined) {\n\t\tthrow new TypeError(`The \\`${fileStdioItem.optionName}\\` option cannot use both files and transforms in objectMode.`);\n\t}\n};\n\n// Some `stdio` values require Execa to create streams.\n// For example, file paths create file read/write streams.\n// Those transformations are specified in `addProperties`, which is both direction-specific and type-specific.\nconst getFinalFileDescriptors = ({initialFileDescriptors, addProperties, options, isSync}) => {\n\tconst fileDescriptors = [];\n\n\ttry {\n\t\tfor (const fileDescriptor of initialFileDescriptors) {\n\t\t\tfileDescriptors.push(getFinalFileDescriptor({\n\t\t\t\tfileDescriptor,\n\t\t\t\tfileDescriptors,\n\t\t\t\taddProperties,\n\t\t\t\toptions,\n\t\t\t\tisSync,\n\t\t\t}));\n\t\t}\n\n\t\treturn fileDescriptors;\n\t} catch (error) {\n\t\tcleanupCustomStreams(fileDescriptors);\n\t\tthrow error;\n\t}\n};\n\nconst getFinalFileDescriptor = ({\n\tfileDescriptor: {direction, objectMode, stdioItems},\n\tfileDescriptors,\n\taddProperties,\n\toptions,\n\tisSync,\n}) => {\n\tconst finalStdioItems = stdioItems.map(stdioItem => addStreamProperties({\n\t\tstdioItem,\n\t\taddProperties,\n\t\tdirection,\n\t\toptions,\n\t\tfileDescriptors,\n\t\tisSync,\n\t}));\n\treturn {direction, objectMode, stdioItems: finalStdioItems};\n};\n\nconst addStreamProperties = ({stdioItem, addProperties, direction, options, fileDescriptors, isSync}) => {\n\tconst duplicateStream = getDuplicateStream({\n\t\tstdioItem,\n\t\tdirection,\n\t\tfileDescriptors,\n\t\tisSync,\n\t});\n\n\tif (duplicateStream !== undefined) {\n\t\treturn {...stdioItem, stream: duplicateStream};\n\t}\n\n\treturn {\n\t\t...stdioItem,\n\t\t...addProperties[direction][stdioItem.type](stdioItem, options),\n\t};\n};\n\n// The stream error handling is performed by the piping logic above, which cannot be performed before subprocess spawning.\n// If the subprocess spawning fails (e.g. due to an invalid command), the streams need to be manually destroyed.\n// We need to create those streams before subprocess spawning, in case their creation fails, e.g. when passing an invalid generator as argument.\n// Like this, an exception would be thrown, which would prevent spawning a subprocess.\nexport const cleanupCustomStreams = fileDescriptors => {\n\tfor (const {stdioItems} of fileDescriptors) {\n\t\tfor (const {stream} of stdioItems) {\n\t\t\tif (stream !== undefined && !isStandardStream(stream)) {\n\t\t\t\tstream.destroy();\n\t\t\t}\n\t\t}\n\t}\n};\n\n// When the `std*: Iterable | WebStream | URL | filePath`, `input` or `inputFile` option is used, we pipe to `subprocess.std*`.\n// When the `std*: Array` option is used, we emulate some of the native values ('inherit', Node.js stream and file descriptor integer). To do so, we also need to pipe to `subprocess.std*`.\n// Therefore the `std*` options must be either `pipe` or `overlapped`. Other values do not set `subprocess.std*`.\nconst forwardStdio = stdioItems => {\n\tif (stdioItems.length > 1) {\n\t\treturn stdioItems.some(({value}) => value === 'overlapped') ? 'overlapped' : 'pipe';\n\t}\n\n\tconst [{type, value}] = stdioItems;\n\treturn type === 'native' ? value : 'pipe';\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3681, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/stdio/handle-sync.js"],"sourcesContent":["import {readFileSync} from 'node:fs';\nimport {bufferToUint8Array} from '../utils/uint-array.js';\nimport {handleStdio} from './handle.js';\nimport {TYPE_TO_MESSAGE} from './type.js';\n\n// Normalize `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in sync mode\nexport const handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true);\n\nconst forbiddenIfSync = ({type, optionName}) => {\n\tthrowInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type]);\n};\n\nconst forbiddenNativeIfSync = ({optionName, value}) => {\n\tif (value === 'ipc' || value === 'overlapped') {\n\t\tthrowInvalidSyncValue(optionName, `\"${value}\"`);\n\t}\n\n\treturn {};\n};\n\nconst throwInvalidSyncValue = (optionName, value) => {\n\tthrow new TypeError(`The \\`${optionName}\\` option cannot be ${value} with synchronous methods.`);\n};\n\n// Create streams used internally for redirecting when using specific values for the `std*` options, in sync mode.\n// For example, `stdin: {file}` reads the file synchronously, then passes it as the `input` option.\nconst addProperties = {\n\tgenerator() {},\n\tasyncGenerator: forbiddenIfSync,\n\twebStream: forbiddenIfSync,\n\tnodeStream: forbiddenIfSync,\n\twebTransform: forbiddenIfSync,\n\tduplex: forbiddenIfSync,\n\tasyncIterable: forbiddenIfSync,\n\tnative: forbiddenNativeIfSync,\n};\n\nconst addPropertiesSync = {\n\tinput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({contents: [bufferToUint8Array(readFileSync(value))]}),\n\t\tfilePath: ({value: {file}}) => ({contents: [bufferToUint8Array(readFileSync(file))]}),\n\t\tfileNumber: forbiddenIfSync,\n\t\titerable: ({value}) => ({contents: [...value]}),\n\t\tstring: ({value}) => ({contents: [value]}),\n\t\tuint8Array: ({value}) => ({contents: [value]}),\n\t},\n\toutput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({path: value}),\n\t\tfilePath: ({value: {file, append}}) => ({path: file, append}),\n\t\tfileNumber: ({value}) => ({path: value}),\n\t\titerable: forbiddenIfSync,\n\t\tstring: forbiddenIfSync,\n\t\tuint8Array: forbiddenIfSync,\n\t},\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAGO,MAAM,kBAAkB,CAAC,SAAS,cAAgB,IAAA,8JAAW,EAAC,mBAAmB,SAAS,aAAa;AAE9G,MAAM,kBAAkB,CAAC,EAAC,IAAI,EAAE,UAAU,EAAC;IAC1C,sBAAsB,YAAY,gKAAe,CAAC,KAAK;AACxD;AAEA,MAAM,wBAAwB,CAAC,EAAC,UAAU,EAAE,KAAK,EAAC;IACjD,IAAI,UAAU,SAAS,UAAU,cAAc;QAC9C,sBAAsB,YAAY,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;IAC/C;IAEA,OAAO,CAAC;AACT;AAEA,MAAM,wBAAwB,CAAC,YAAY;IAC1C,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,oBAAoB,EAAE,MAAM,0BAA0B,CAAC;AAChG;AAEA,kHAAkH;AAClH,mGAAmG;AACnG,MAAM,gBAAgB;IACrB,cAAa;IACb,gBAAgB;IAChB,WAAW;IACX,YAAY;IACZ,cAAc;IACd,QAAQ;IACR,eAAe;IACf,QAAQ;AACT;AAEA,MAAM,oBAAoB;IACzB,OAAO;QACN,GAAG,aAAa;QAChB,SAAS,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,UAAU;oBAAC,IAAA,4KAAkB,EAAC,IAAA,6HAAY,EAAC;iBAAQ;YAAA,CAAC;QAC5E,UAAU,CAAC,EAAC,OAAO,EAAC,IAAI,EAAC,EAAC,GAAK,CAAC;gBAAC,UAAU;oBAAC,IAAA,4KAAkB,EAAC,IAAA,6HAAY,EAAC;iBAAO;YAAA,CAAC;QACpF,YAAY;QACZ,UAAU,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,UAAU;uBAAI;iBAAM;YAAA,CAAC;QAC9C,QAAQ,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,UAAU;oBAAC;iBAAM;YAAA,CAAC;QACzC,YAAY,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,UAAU;oBAAC;iBAAM;YAAA,CAAC;IAC9C;IACA,QAAQ;QACP,GAAG,aAAa;QAChB,SAAS,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,MAAM;YAAK,CAAC;QACpC,UAAU,CAAC,EAAC,OAAO,EAAC,IAAI,EAAE,MAAM,EAAC,EAAC,GAAK,CAAC;gBAAC,MAAM;gBAAM;YAAM,CAAC;QAC5D,YAAY,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,MAAM;YAAK,CAAC;QACvC,UAAU;QACV,QAAQ;QACR,YAAY;IACb;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3769, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/io/strip-newline.js"],"sourcesContent":["import stripFinalNewlineFunction from 'strip-final-newline';\n\n// Apply `stripFinalNewline` option, which applies to `result.stdout|stderr|all|stdio[*]`.\n// If the `lines` option is used, it is applied on each line, but using a different function.\nexport const stripNewline = (value, {stripFinalNewline}, fdNumber) => getStripFinalNewline(stripFinalNewline, fdNumber) && value !== undefined && !Array.isArray(value)\n\t? stripFinalNewlineFunction(value)\n\t: value;\n\n// Retrieve `stripFinalNewline` option value, including with `subprocess.all`\nexport const getStripFinalNewline = (stripFinalNewline, fdNumber) => fdNumber === 'all'\n\t? stripFinalNewline[1] || stripFinalNewline[2]\n\t: stripFinalNewline[fdNumber];\n"],"names":[],"mappings":";;;;;;AAAA;;AAIO,MAAM,eAAe,CAAC,OAAO,EAAC,iBAAiB,EAAC,EAAE,WAAa,qBAAqB,mBAAmB,aAAa,UAAU,aAAa,CAAC,MAAM,OAAO,CAAC,SAC9J,IAAA,6JAAyB,EAAC,SAC1B;AAGI,MAAM,uBAAuB,CAAC,mBAAmB,WAAa,aAAa,QAC/E,iBAAiB,CAAC,EAAE,IAAI,iBAAiB,CAAC,EAAE,GAC5C,iBAAiB,CAAC,SAAS","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3783, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/transform/split.js"],"sourcesContent":["// Split chunks line-wise for generators passed to the `std*` options\nexport const getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped\n\t? undefined\n\t: initializeSplitLines(preserveNewlines, state);\n\n// Same but for synchronous methods\nexport const splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode\n\t? chunk.flatMap(item => splitLinesItemSync(item, preserveNewlines))\n\t: splitLinesItemSync(chunk, preserveNewlines);\n\nconst splitLinesItemSync = (chunk, preserveNewlines) => {\n\tconst {transform, final} = initializeSplitLines(preserveNewlines, {});\n\treturn [...transform(chunk), ...final()];\n};\n\nconst initializeSplitLines = (preserveNewlines, state) => {\n\tstate.previousChunks = '';\n\treturn {\n\t\ttransform: splitGenerator.bind(undefined, state, preserveNewlines),\n\t\tfinal: linesFinal.bind(undefined, state),\n\t};\n};\n\n// This imperative logic is much faster than using `String.split()` and uses very low memory.\nconst splitGenerator = function * (state, preserveNewlines, chunk) {\n\tif (typeof chunk !== 'string') {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tlet {previousChunks} = state;\n\tlet start = -1;\n\n\tfor (let end = 0; end < chunk.length; end += 1) {\n\t\tif (chunk[end] === '\\n') {\n\t\t\tconst newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);\n\t\t\tlet line = chunk.slice(start + 1, end + 1 - newlineLength);\n\n\t\t\tif (previousChunks.length > 0) {\n\t\t\t\tline = concatString(previousChunks, line);\n\t\t\t\tpreviousChunks = '';\n\t\t\t}\n\n\t\t\tyield line;\n\t\t\tstart = end;\n\t\t}\n\t}\n\n\tif (start !== chunk.length - 1) {\n\t\tpreviousChunks = concatString(previousChunks, chunk.slice(start + 1));\n\t}\n\n\tstate.previousChunks = previousChunks;\n};\n\nconst getNewlineLength = (chunk, end, preserveNewlines, state) => {\n\tif (preserveNewlines) {\n\t\treturn 0;\n\t}\n\n\tstate.isWindowsNewline = end !== 0 && chunk[end - 1] === '\\r';\n\treturn state.isWindowsNewline ? 2 : 1;\n};\n\nconst linesFinal = function * ({previousChunks}) {\n\tif (previousChunks.length > 0) {\n\t\tyield previousChunks;\n\t}\n};\n\n// Unless `preserveNewlines: true` is used, we strip the newline of each line.\n// This re-adds them after the user `transform` code has run.\nexport const getAppendNewlineGenerator = ({binary, preserveNewlines, readableObjectMode, state}) => binary || preserveNewlines || readableObjectMode\n\t? undefined\n\t: {transform: appendNewlineGenerator.bind(undefined, state)};\n\nconst appendNewlineGenerator = function * ({isWindowsNewline = false}, chunk) {\n\tconst {unixNewline, windowsNewline, LF, concatBytes} = typeof chunk === 'string' ? linesStringInfo : linesUint8ArrayInfo;\n\n\tif (chunk.at(-1) === LF) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst newline = isWindowsNewline ? windowsNewline : unixNewline;\n\tyield concatBytes(chunk, newline);\n};\n\nconst concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;\n\nconst linesStringInfo = {\n\twindowsNewline: '\\r\\n',\n\tunixNewline: '\\n',\n\tLF: '\\n',\n\tconcatBytes: concatString,\n};\n\nconst concatUint8Array = (firstChunk, secondChunk) => {\n\tconst chunk = new Uint8Array(firstChunk.length + secondChunk.length);\n\tchunk.set(firstChunk, 0);\n\tchunk.set(secondChunk, firstChunk.length);\n\treturn chunk;\n};\n\nconst linesUint8ArrayInfo = {\n\twindowsNewline: new Uint8Array([0x0D, 0x0A]),\n\tunixNewline: new Uint8Array([0x0A]),\n\tLF: 0x0A,\n\tconcatBytes: concatUint8Array,\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3885, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/transform/validate.js"],"sourcesContent":["import {Buffer} from 'node:buffer';\nimport {isUint8Array} from '../utils/uint-array.js';\n\n// Validate the type of chunk argument passed to transform generators\nexport const getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode\n\t? undefined\n\t: validateStringTransformInput.bind(undefined, optionName);\n\nconst validateStringTransformInput = function * (optionName, chunk) {\n\tif (typeof chunk !== 'string' && !isUint8Array(chunk) && !Buffer.isBuffer(chunk)) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's transform must use \"objectMode: true\" to receive as input: ${typeof chunk}.`);\n\t}\n\n\tyield chunk;\n};\n\n// Validate the type of the value returned by transform generators\nexport const getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode\n\t? validateObjectTransformReturn.bind(undefined, optionName)\n\t: validateStringTransformReturn.bind(undefined, optionName);\n\nconst validateObjectTransformReturn = function * (optionName, chunk) {\n\tvalidateEmptyReturn(optionName, chunk);\n\tyield chunk;\n};\n\nconst validateStringTransformReturn = function * (optionName, chunk) {\n\tvalidateEmptyReturn(optionName, chunk);\n\n\tif (typeof chunk !== 'string' && !isUint8Array(chunk)) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);\n\t}\n\n\tyield chunk;\n};\n\nconst validateEmptyReturn = (optionName, chunk) => {\n\tif (chunk === null || chunk === undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's function must not call \\`yield ${chunk}\\`.\nInstead, \\`yield\\` should either be called with a value, or not be called at all. For example:\n  if (condition) { yield value; }`);\n\t}\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAGO,MAAM,4BAA4B,CAAC,oBAAoB,aAAe,qBAC1E,YACA,6BAA6B,IAAI,CAAC,WAAW;AAEhD,MAAM,+BAA+B,UAAY,UAAU,EAAE,KAAK;IACjE,IAAI,OAAO,UAAU,YAAY,CAAC,IAAA,sKAAY,EAAC,UAAU,CAAC,+HAAM,CAAC,QAAQ,CAAC,QAAQ;QACjF,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,uEAAuE,EAAE,OAAO,MAAM,CAAC,CAAC;IACjI;IAEA,MAAM;AACP;AAGO,MAAM,6BAA6B,CAAC,oBAAoB,aAAe,qBAC3E,8BAA8B,IAAI,CAAC,WAAW,cAC9C,8BAA8B,IAAI,CAAC,WAAW;AAEjD,MAAM,gCAAgC,UAAY,UAAU,EAAE,KAAK;IAClE,oBAAoB,YAAY;IAChC,MAAM;AACP;AAEA,MAAM,gCAAgC,UAAY,UAAU,EAAE,KAAK;IAClE,oBAAoB,YAAY;IAEhC,IAAI,OAAO,UAAU,YAAY,CAAC,IAAA,sKAAY,EAAC,QAAQ;QACtD,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,+DAA+D,EAAE,OAAO,MAAM,CAAC,CAAC;IACzH;IAEA,MAAM;AACP;AAEA,MAAM,sBAAsB,CAAC,YAAY;IACxC,IAAI,UAAU,QAAQ,UAAU,WAAW;QAC1C,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,2CAA2C,EAAE,MAAM;;iCAE5D,CAAC;IACjC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3925, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/transform/encoding-transform.js"],"sourcesContent":["import {Buffer} from 'node:buffer';\nimport {StringDecoder} from 'node:string_decoder';\nimport {isUint8Array, bufferToUint8Array} from '../utils/uint-array.js';\n\n/*\nWhen using binary encodings, add an internal generator that converts chunks from `Buffer` to `string` or `Uint8Array`.\nChunks might be Buffer, Uint8Array or strings since:\n- `subprocess.stdout|stderr` emits Buffers\n- `subprocess.stdin.write()` accepts Buffer, Uint8Array or string\n- Previous generators might return Uint8Array or string\n\nHowever, those are converted to Buffer:\n- on writes: `Duplex.writable` `decodeStrings: true` default option\n- on reads: `Duplex.readable` `readableEncoding: null` default option\n*/\nexport const getEncodingTransformGenerator = (binary, encoding, skipped) => {\n\tif (skipped) {\n\t\treturn;\n\t}\n\n\tif (binary) {\n\t\treturn {transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder())};\n\t}\n\n\tconst stringDecoder = new StringDecoder(encoding);\n\treturn {\n\t\ttransform: encodingStringGenerator.bind(undefined, stringDecoder),\n\t\tfinal: encodingStringFinal.bind(undefined, stringDecoder),\n\t};\n};\n\nconst encodingUint8ArrayGenerator = function * (textEncoder, chunk) {\n\tif (Buffer.isBuffer(chunk)) {\n\t\tyield bufferToUint8Array(chunk);\n\t} else if (typeof chunk === 'string') {\n\t\tyield textEncoder.encode(chunk);\n\t} else {\n\t\tyield chunk;\n\t}\n};\n\nconst encodingStringGenerator = function * (stringDecoder, chunk) {\n\tyield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;\n};\n\nconst encodingStringFinal = function * (stringDecoder) {\n\tconst lastChunk = stringDecoder.end();\n\tif (lastChunk !== '') {\n\t\tyield lastChunk;\n\t}\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAaO,MAAM,gCAAgC,CAAC,QAAQ,UAAU;IAC/D,IAAI,SAAS;QACZ;IACD;IAEA,IAAI,QAAQ;QACX,OAAO;YAAC,WAAW,4BAA4B,IAAI,CAAC,WAAW,IAAI;QAAc;IAClF;IAEA,MAAM,gBAAgB,IAAI,sJAAa,CAAC;IACxC,OAAO;QACN,WAAW,wBAAwB,IAAI,CAAC,WAAW;QACnD,OAAO,oBAAoB,IAAI,CAAC,WAAW;IAC5C;AACD;AAEA,MAAM,8BAA8B,UAAY,WAAW,EAAE,KAAK;IACjE,IAAI,+HAAM,CAAC,QAAQ,CAAC,QAAQ;QAC3B,MAAM,IAAA,4KAAkB,EAAC;IAC1B,OAAO,IAAI,OAAO,UAAU,UAAU;QACrC,MAAM,YAAY,MAAM,CAAC;IAC1B,OAAO;QACN,MAAM;IACP;AACD;AAEA,MAAM,0BAA0B,UAAY,aAAa,EAAE,KAAK;IAC/D,MAAM,IAAA,sKAAY,EAAC,SAAS,cAAc,KAAK,CAAC,SAAS;AAC1D;AAEA,MAAM,sBAAsB,UAAY,aAAa;IACpD,MAAM,YAAY,cAAc,GAAG;IACnC,IAAI,cAAc,IAAI;QACrB,MAAM;IACP;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3972, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/transform/run-async.js"],"sourcesContent":["import {callbackify} from 'node:util';\n\n// Applies a series of generator functions asynchronously\nexport const pushChunks = callbackify(async (getChunks, state, getChunksArguments, transformStream) => {\n\tstate.currentIterable = getChunks(...getChunksArguments);\n\n\ttry {\n\t\tfor await (const chunk of state.currentIterable) {\n\t\t\ttransformStream.push(chunk);\n\t\t}\n\t} finally {\n\t\tdelete state.currentIterable;\n\t}\n});\n\n// For each new chunk, apply each `transform()` method\nexport const transformChunk = async function * (chunk, generators, index) {\n\tif (index === generators.length) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst {transform = identityGenerator} = generators[index];\n\tfor await (const transformedChunk of transform(chunk)) {\n\t\tyield * transformChunk(transformedChunk, generators, index + 1);\n\t}\n};\n\n// At the end, apply each `final()` method, followed by the `transform()` method of the next transforms\nexport const finalChunks = async function * (generators) {\n\tfor (const [index, {final}] of Object.entries(generators)) {\n\t\tyield * generatorFinalChunks(final, Number(index), generators);\n\t}\n};\n\nconst generatorFinalChunks = async function * (final, index, generators) {\n\tif (final === undefined) {\n\t\treturn;\n\t}\n\n\tfor await (const finalChunk of final()) {\n\t\tyield * transformChunk(finalChunk, generators, index + 1);\n\t}\n};\n\n// Cancel any ongoing async generator when the Transform is destroyed, e.g. when the subprocess errors\nexport const destroyTransform = callbackify(async ({currentIterable}, error) => {\n\tif (currentIterable !== undefined) {\n\t\tawait (error ? currentIterable.throw(error) : currentIterable.return());\n\t\treturn;\n\t}\n\n\tif (error) {\n\t\tthrow error;\n\t}\n});\n\nconst identityGenerator = function * (chunk) {\n\tyield chunk;\n};\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAGO,MAAM,aAAa,IAAA,gIAAW,EAAC,OAAO,WAAW,OAAO,oBAAoB;IAClF,MAAM,eAAe,GAAG,aAAa;IAErC,IAAI;QACH,WAAW,MAAM,SAAS,MAAM,eAAe,CAAE;YAChD,gBAAgB,IAAI,CAAC;QACtB;IACD,SAAU;QACT,OAAO,MAAM,eAAe;IAC7B;AACD;AAGO,MAAM,iBAAiB,gBAAkB,KAAK,EAAE,UAAU,EAAE,KAAK;IACvE,IAAI,UAAU,WAAW,MAAM,EAAE;QAChC,MAAM;QACN;IACD;IAEA,MAAM,EAAC,YAAY,iBAAiB,EAAC,GAAG,UAAU,CAAC,MAAM;IACzD,WAAW,MAAM,oBAAoB,UAAU,OAAQ;QACtD,OAAQ,eAAe,kBAAkB,YAAY,QAAQ;IAC9D;AACD;AAGO,MAAM,cAAc,gBAAkB,UAAU;IACtD,KAAK,MAAM,CAAC,OAAO,EAAC,KAAK,EAAC,CAAC,IAAI,OAAO,OAAO,CAAC,YAAa;QAC1D,OAAQ,qBAAqB,OAAO,OAAO,QAAQ;IACpD;AACD;AAEA,MAAM,uBAAuB,gBAAkB,KAAK,EAAE,KAAK,EAAE,UAAU;IACtE,IAAI,UAAU,WAAW;QACxB;IACD;IAEA,WAAW,MAAM,cAAc,QAAS;QACvC,OAAQ,eAAe,YAAY,YAAY,QAAQ;IACxD;AACD;AAGO,MAAM,mBAAmB,IAAA,gIAAW,EAAC,OAAO,EAAC,eAAe,EAAC,EAAE;IACrE,IAAI,oBAAoB,WAAW;QAClC,MAAM,CAAC,QAAQ,gBAAgB,KAAK,CAAC,SAAS,gBAAgB,MAAM,EAAE;QACtE;IACD;IAEA,IAAI,OAAO;QACV,MAAM;IACP;AACD;AAEA,MAAM,oBAAoB,UAAY,KAAK;IAC1C,MAAM;AACP","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4033, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/transform/run-sync.js"],"sourcesContent":["// Duplicate the code from `run-async.js` but as synchronous functions\nexport const pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {\n\ttry {\n\t\tfor (const chunk of getChunksSync(...getChunksArguments)) {\n\t\t\ttransformStream.push(chunk);\n\t\t}\n\n\t\tdone();\n\t} catch (error) {\n\t\tdone(error);\n\t}\n};\n\n// Run synchronous generators with `execaSync()`\nexport const runTransformSync = (generators, chunks) => [\n\t...chunks.flatMap(chunk => [...transformChunkSync(chunk, generators, 0)]),\n\t...finalChunksSync(generators),\n];\n\nexport const transformChunkSync = function * (chunk, generators, index) {\n\tif (index === generators.length) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst {transform = identityGenerator} = generators[index];\n\tfor (const transformedChunk of transform(chunk)) {\n\t\tyield * transformChunkSync(transformedChunk, generators, index + 1);\n\t}\n};\n\nexport const finalChunksSync = function * (generators) {\n\tfor (const [index, {final}] of Object.entries(generators)) {\n\t\tyield * generatorFinalChunksSync(final, Number(index), generators);\n\t}\n};\n\nconst generatorFinalChunksSync = function * (final, index, generators) {\n\tif (final === undefined) {\n\t\treturn;\n\t}\n\n\tfor (const finalChunk of final()) {\n\t\tyield * transformChunkSync(finalChunk, generators, index + 1);\n\t}\n};\n\nconst identityGenerator = function * (chunk) {\n\tyield chunk;\n};\n"],"names":[],"mappings":"AAAA,sEAAsE;;;;;;;;;;;AAC/D,MAAM,iBAAiB,CAAC,eAAe,oBAAoB,iBAAiB;IAClF,IAAI;QACH,KAAK,MAAM,SAAS,iBAAiB,oBAAqB;YACzD,gBAAgB,IAAI,CAAC;QACtB;QAEA;IACD,EAAE,OAAO,OAAO;QACf,KAAK;IACN;AACD;AAGO,MAAM,mBAAmB,CAAC,YAAY,SAAW;WACpD,OAAO,OAAO,CAAC,CAAA,QAAS;mBAAI,mBAAmB,OAAO,YAAY;aAAG;WACrE,gBAAgB;KACnB;AAEM,MAAM,qBAAqB,UAAY,KAAK,EAAE,UAAU,EAAE,KAAK;IACrE,IAAI,UAAU,WAAW,MAAM,EAAE;QAChC,MAAM;QACN;IACD;IAEA,MAAM,EAAC,YAAY,iBAAiB,EAAC,GAAG,UAAU,CAAC,MAAM;IACzD,KAAK,MAAM,oBAAoB,UAAU,OAAQ;QAChD,OAAQ,mBAAmB,kBAAkB,YAAY,QAAQ;IAClE;AACD;AAEO,MAAM,kBAAkB,UAAY,UAAU;IACpD,KAAK,MAAM,CAAC,OAAO,EAAC,KAAK,EAAC,CAAC,IAAI,OAAO,OAAO,CAAC,YAAa;QAC1D,OAAQ,yBAAyB,OAAO,OAAO,QAAQ;IACxD;AACD;AAEA,MAAM,2BAA2B,UAAY,KAAK,EAAE,KAAK,EAAE,UAAU;IACpE,IAAI,UAAU,WAAW;QACxB;IACD;IAEA,KAAK,MAAM,cAAc,QAAS;QACjC,OAAQ,mBAAmB,YAAY,YAAY,QAAQ;IAC5D;AACD;AAEA,MAAM,oBAAoB,UAAY,KAAK;IAC1C,MAAM;AACP","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4090, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/transform/generator.js"],"sourcesContent":["import {Transform, getDefaultHighWaterMark} from 'node:stream';\nimport {isAsyncGenerator} from '../stdio/type.js';\nimport {getSplitLinesGenerator, getAppendNewlineGenerator} from './split.js';\nimport {getValidateTransformInput, getValidateTransformReturn} from './validate.js';\nimport {getEncodingTransformGenerator} from './encoding-transform.js';\nimport {\n\tpushChunks,\n\ttransformChunk,\n\tfinalChunks,\n\tdestroyTransform,\n} from './run-async.js';\nimport {\n\tpushChunksSync,\n\ttransformChunkSync,\n\tfinalChunksSync,\n\trunTransformSync,\n} from './run-sync.js';\n\n/*\nGenerators can be used to transform/filter standard streams.\n\nGenerators have a simple syntax, yet allows all of the following:\n- Sharing `state` between chunks\n- Flushing logic, by using a `final` function\n- Asynchronous logic\n- Emitting multiple chunks from a single source chunk, even if spaced in time, by using multiple `yield`\n- Filtering, by using no `yield`\n\nTherefore, there is no need to allow Node.js or web transform streams.\n\nThe `highWaterMark` is kept as the default value, since this is what `subprocess.std*` uses.\n\nChunks are currently processed serially. We could add a `concurrency` option to parallelize in the future.\n\nTransform an array of generator functions into a `Transform` stream.\n`Duplex.from(generator)` cannot be used because it does not allow setting the `objectMode` and `highWaterMark`.\n*/\nexport const generatorToStream = ({\n\tvalue,\n\tvalue: {transform, final, writableObjectMode, readableObjectMode},\n\toptionName,\n}, {encoding}) => {\n\tconst state = {};\n\tconst generators = addInternalGenerators(value, encoding, optionName);\n\n\tconst transformAsync = isAsyncGenerator(transform);\n\tconst finalAsync = isAsyncGenerator(final);\n\tconst transformMethod = transformAsync\n\t\t? pushChunks.bind(undefined, transformChunk, state)\n\t\t: pushChunksSync.bind(undefined, transformChunkSync);\n\tconst finalMethod = transformAsync || finalAsync\n\t\t? pushChunks.bind(undefined, finalChunks, state)\n\t\t: pushChunksSync.bind(undefined, finalChunksSync);\n\tconst destroyMethod = transformAsync || finalAsync\n\t\t? destroyTransform.bind(undefined, state)\n\t\t: undefined;\n\n\tconst stream = new Transform({\n\t\twritableObjectMode,\n\t\twritableHighWaterMark: getDefaultHighWaterMark(writableObjectMode),\n\t\treadableObjectMode,\n\t\treadableHighWaterMark: getDefaultHighWaterMark(readableObjectMode),\n\t\ttransform(chunk, encoding, done) {\n\t\t\ttransformMethod([chunk, generators, 0], this, done);\n\t\t},\n\t\tflush(done) {\n\t\t\tfinalMethod([generators], this, done);\n\t\t},\n\t\tdestroy: destroyMethod,\n\t});\n\treturn {stream};\n};\n\n// Applies transform generators in sync mode\nexport const runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {\n\tconst generators = stdioItems.filter(({type}) => type === 'generator');\n\tconst reversedGenerators = isInput ? generators.reverse() : generators;\n\n\tfor (const {value, optionName} of reversedGenerators) {\n\t\tconst generators = addInternalGenerators(value, encoding, optionName);\n\t\tchunks = runTransformSync(generators, chunks);\n\t}\n\n\treturn chunks;\n};\n\n// Generators used internally to convert the chunk type, validate it, and split into lines\nconst addInternalGenerators = (\n\t{transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines},\n\tencoding,\n\toptionName,\n) => {\n\tconst state = {};\n\treturn [\n\t\t{transform: getValidateTransformInput(writableObjectMode, optionName)},\n\t\tgetEncodingTransformGenerator(binary, encoding, writableObjectMode),\n\t\tgetSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),\n\t\t{transform, final},\n\t\t{transform: getValidateTransformReturn(readableObjectMode, optionName)},\n\t\tgetAppendNewlineGenerator({\n\t\t\tbinary,\n\t\t\tpreserveNewlines,\n\t\t\treadableObjectMode,\n\t\t\tstate,\n\t\t}),\n\t].filter(Boolean);\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAMA;;;;;;;;AA0BO,MAAM,oBAAoB,CAAC,EACjC,KAAK,EACL,OAAO,EAAC,SAAS,EAAE,KAAK,EAAE,kBAAkB,EAAE,kBAAkB,EAAC,EACjE,UAAU,EACV,EAAE,EAAC,QAAQ,EAAC;IACZ,MAAM,QAAQ,CAAC;IACf,MAAM,aAAa,sBAAsB,OAAO,UAAU;IAE1D,MAAM,iBAAiB,IAAA,iKAAgB,EAAC;IACxC,MAAM,aAAa,IAAA,iKAAgB,EAAC;IACpC,MAAM,kBAAkB,iBACrB,uKAAU,CAAC,IAAI,CAAC,WAAW,2KAAc,EAAE,SAC3C,0KAAc,CAAC,IAAI,CAAC,WAAW,8KAAkB;IACpD,MAAM,cAAc,kBAAkB,aACnC,uKAAU,CAAC,IAAI,CAAC,WAAW,wKAAW,EAAE,SACxC,0KAAc,CAAC,IAAI,CAAC,WAAW,2KAAe;IACjD,MAAM,gBAAgB,kBAAkB,aACrC,6KAAgB,CAAC,IAAI,CAAC,WAAW,SACjC;IAEH,MAAM,SAAS,IAAI,kIAAS,CAAC;QAC5B;QACA,uBAAuB,IAAA,gJAAuB,EAAC;QAC/C;QACA,uBAAuB,IAAA,gJAAuB,EAAC;QAC/C,WAAU,KAAK,EAAE,QAAQ,EAAE,IAAI;YAC9B,gBAAgB;gBAAC;gBAAO;gBAAY;aAAE,EAAE,IAAI,EAAE;QAC/C;QACA,OAAM,IAAI;YACT,YAAY;gBAAC;aAAW,EAAE,IAAI,EAAE;QACjC;QACA,SAAS;IACV;IACA,OAAO;QAAC;IAAM;AACf;AAGO,MAAM,oBAAoB,CAAC,QAAQ,YAAY,UAAU;IAC/D,MAAM,aAAa,WAAW,MAAM,CAAC,CAAC,EAAC,IAAI,EAAC,GAAK,SAAS;IAC1D,MAAM,qBAAqB,UAAU,WAAW,OAAO,KAAK;IAE5D,KAAK,MAAM,EAAC,KAAK,EAAE,UAAU,EAAC,IAAI,mBAAoB;QACrD,MAAM,aAAa,sBAAsB,OAAO,UAAU;QAC1D,SAAS,IAAA,4KAAgB,EAAC,YAAY;IACvC;IAEA,OAAO;AACR;AAEA,0FAA0F;AAC1F,MAAM,wBAAwB,CAC7B,EAAC,SAAS,EAAE,KAAK,EAAE,MAAM,EAAE,kBAAkB,EAAE,kBAAkB,EAAE,gBAAgB,EAAC,EACpF,UACA;IAEA,MAAM,QAAQ,CAAC;IACf,OAAO;QACN;YAAC,WAAW,IAAA,kLAAyB,EAAC,oBAAoB;QAAW;QACrE,IAAA,mMAA6B,EAAC,QAAQ,UAAU;QAChD,IAAA,4KAAsB,EAAC,QAAQ,kBAAkB,oBAAoB;QACrE;YAAC;YAAW;QAAK;QACjB;YAAC,WAAW,IAAA,mLAA0B,EAAC,oBAAoB;QAAW;QACtE,IAAA,+KAAyB,EAAC;YACzB;YACA;YACA;YACA;QACD;KACA,CAAC,MAAM,CAAC;AACV","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4178, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/io/input-sync.js"],"sourcesContent":["import {runGeneratorsSync} from '../transform/generator.js';\nimport {joinToUint8Array, isUint8Array} from '../utils/uint-array.js';\nimport {TYPE_TO_MESSAGE} from '../stdio/type.js';\n\n// Apply `stdin`/`input`/`inputFile` options, before spawning, in sync mode, by converting it to the `input` option\nexport const addInputOptionsSync = (fileDescriptors, options) => {\n\tfor (const fdNumber of getInputFdNumbers(fileDescriptors)) {\n\t\taddInputOptionSync(fileDescriptors, fdNumber, options);\n\t}\n};\n\nconst getInputFdNumbers = fileDescriptors => new Set(Object.entries(fileDescriptors)\n\t.filter(([, {direction}]) => direction === 'input')\n\t.map(([fdNumber]) => Number(fdNumber)));\n\nconst addInputOptionSync = (fileDescriptors, fdNumber, options) => {\n\tconst {stdioItems} = fileDescriptors[fdNumber];\n\tconst allStdioItems = stdioItems.filter(({contents}) => contents !== undefined);\n\tif (allStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tif (fdNumber !== 0) {\n\t\tconst [{type, optionName}] = allStdioItems;\n\t\tthrow new TypeError(`Only the \\`stdin\\` option, not \\`${optionName}\\`, can be ${TYPE_TO_MESSAGE[type]} with synchronous methods.`);\n\t}\n\n\tconst allContents = allStdioItems.map(({contents}) => contents);\n\tconst transformedContents = allContents.map(contents => applySingleInputGeneratorsSync(contents, stdioItems));\n\toptions.input = joinToUint8Array(transformedContents);\n};\n\nconst applySingleInputGeneratorsSync = (contents, stdioItems) => {\n\tconst newContents = runGeneratorsSync(contents, stdioItems, 'utf8', true);\n\tvalidateSerializable(newContents);\n\treturn joinToUint8Array(newContents);\n};\n\nconst validateSerializable = newContents => {\n\tconst invalidItem = newContents.find(item => typeof item !== 'string' && !isUint8Array(item));\n\tif (invalidItem !== undefined) {\n\t\tthrow new TypeError(`The \\`stdin\\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);\n\t}\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAGO,MAAM,sBAAsB,CAAC,iBAAiB;IACpD,KAAK,MAAM,YAAY,kBAAkB,iBAAkB;QAC1D,mBAAmB,iBAAiB,UAAU;IAC/C;AACD;AAEA,MAAM,oBAAoB,CAAA,kBAAmB,IAAI,IAAI,OAAO,OAAO,CAAC,iBAClE,MAAM,CAAC,CAAC,GAAG,EAAC,SAAS,EAAC,CAAC,GAAK,cAAc,SAC1C,GAAG,CAAC,CAAC,CAAC,SAAS,GAAK,OAAO;AAE7B,MAAM,qBAAqB,CAAC,iBAAiB,UAAU;IACtD,MAAM,EAAC,UAAU,EAAC,GAAG,eAAe,CAAC,SAAS;IAC9C,MAAM,gBAAgB,WAAW,MAAM,CAAC,CAAC,EAAC,QAAQ,EAAC,GAAK,aAAa;IACrE,IAAI,cAAc,MAAM,KAAK,GAAG;QAC/B;IACD;IAEA,IAAI,aAAa,GAAG;QACnB,MAAM,CAAC,EAAC,IAAI,EAAE,UAAU,EAAC,CAAC,GAAG;QAC7B,MAAM,IAAI,UAAU,CAAC,iCAAiC,EAAE,WAAW,WAAW,EAAE,gKAAe,CAAC,KAAK,CAAC,0BAA0B,CAAC;IAClI;IAEA,MAAM,cAAc,cAAc,GAAG,CAAC,CAAC,EAAC,QAAQ,EAAC,GAAK;IACtD,MAAM,sBAAsB,YAAY,GAAG,CAAC,CAAA,WAAY,+BAA+B,UAAU;IACjG,QAAQ,KAAK,GAAG,IAAA,0KAAgB,EAAC;AAClC;AAEA,MAAM,iCAAiC,CAAC,UAAU;IACjD,MAAM,cAAc,IAAA,2KAAiB,EAAC,UAAU,YAAY,QAAQ;IACpE,qBAAqB;IACrB,OAAO,IAAA,0KAAgB,EAAC;AACzB;AAEA,MAAM,uBAAuB,CAAA;IAC5B,MAAM,cAAc,YAAY,IAAI,CAAC,CAAA,OAAQ,OAAO,SAAS,YAAY,CAAC,IAAA,sKAAY,EAAC;IACvF,IAAI,gBAAgB,WAAW;QAC9B,MAAM,IAAI,UAAU,CAAC,sIAAsI,EAAE,YAAY,CAAC,CAAC;IAC5K;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4223, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/verbose/output.js"],"sourcesContent":["import {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {verboseLog, serializeVerboseMessage} from './log.js';\nimport {isFullVerbose} from './values.js';\n\n// `ignore` opts-out of `verbose` for a specific stream.\n// `ipc` cannot use piping.\n// `inherit` would result in double printing.\n// They can also lead to double printing when passing file descriptor integers or `process.std*`.\n// This only leaves with `pipe` and `overlapped`.\nexport const shouldLogOutput = ({stdioItems, encoding, verboseInfo, fdNumber}) => fdNumber !== 'all'\n\t&& isFullVerbose(verboseInfo, fdNumber)\n\t&& !BINARY_ENCODINGS.has(encoding)\n\t&& fdUsesVerbose(fdNumber)\n\t&& (stdioItems.some(({type, value}) => type === 'native' && PIPED_STDIO_VALUES.has(value))\n\t|| stdioItems.every(({type}) => TRANSFORM_TYPES.has(type)));\n\n// Printing input streams would be confusing.\n// Files and streams can produce big outputs, which we don't want to print.\n// We could print `stdio[3+]` but it often is redirected to files and streams, with the same issue.\n// So we only print stdout and stderr.\nconst fdUsesVerbose = fdNumber => fdNumber === 1 || fdNumber === 2;\n\nconst PIPED_STDIO_VALUES = new Set(['pipe', 'overlapped']);\n\n// `verbose: 'full'` printing logic with async methods\nexport const logLines = async (linesIterable, stream, fdNumber, verboseInfo) => {\n\tfor await (const line of linesIterable) {\n\t\tif (!isPipingStream(stream)) {\n\t\t\tlogLine(line, fdNumber, verboseInfo);\n\t\t}\n\t}\n};\n\n// `verbose: 'full'` printing logic with sync methods\nexport const logLinesSync = (linesArray, fdNumber, verboseInfo) => {\n\tfor (const line of linesArray) {\n\t\tlogLine(line, fdNumber, verboseInfo);\n\t}\n};\n\n// When `subprocess.stdout|stderr.pipe()` is called, `verbose` becomes a noop.\n// This prevents the following problems:\n//  - `.pipe()` achieves the same result as using `stdout: 'inherit'`, `stdout: stream`, etc. which also make `verbose` a noop.\n//    For example, `subprocess.stdout.pipe(process.stdin)` would print each line twice.\n//  - When chaining subprocesses with `subprocess.pipe(otherSubprocess)`, only the last one should print its output.\n// Detecting whether `.pipe()` is impossible without monkey-patching it, so we use the following undocumented property.\n// This is not a critical behavior since changes of the following property would only make `verbose` more verbose.\nconst isPipingStream = stream => stream._readableState.pipes.length > 0;\n\n// When `verbose` is `full`, print stdout|stderr\nconst logLine = (line, fdNumber, verboseInfo) => {\n\tconst verboseMessage = serializeVerboseMessage(line);\n\tverboseLog({\n\t\ttype: 'output',\n\t\tverboseMessage,\n\t\tfdNumber,\n\t\tverboseInfo,\n\t});\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAOO,MAAM,kBAAkB,CAAC,EAAC,UAAU,EAAE,QAAQ,EAAE,WAAW,EAAE,QAAQ,EAAC,GAAK,aAAa,SAC3F,IAAA,kKAAa,EAAC,aAAa,aAC3B,CAAC,mLAAgB,CAAC,GAAG,CAAC,aACtB,cAAc,aACd,CAAC,WAAW,IAAI,CAAC,CAAC,EAAC,IAAI,EAAE,KAAK,EAAC,GAAK,SAAS,YAAY,mBAAmB,GAAG,CAAC,WAChF,WAAW,KAAK,CAAC,CAAC,EAAC,IAAI,EAAC,GAAK,gKAAe,CAAC,GAAG,CAAC,MAAM;AAE3D,6CAA6C;AAC7C,2EAA2E;AAC3E,mGAAmG;AACnG,sCAAsC;AACtC,MAAM,gBAAgB,CAAA,WAAY,aAAa,KAAK,aAAa;AAEjE,MAAM,qBAAqB,IAAI,IAAI;IAAC;IAAQ;CAAa;AAGlD,MAAM,WAAW,OAAO,eAAe,QAAQ,UAAU;IAC/D,WAAW,MAAM,QAAQ,cAAe;QACvC,IAAI,CAAC,eAAe,SAAS;YAC5B,QAAQ,MAAM,UAAU;QACzB;IACD;AACD;AAGO,MAAM,eAAe,CAAC,YAAY,UAAU;IAClD,KAAK,MAAM,QAAQ,WAAY;QAC9B,QAAQ,MAAM,UAAU;IACzB;AACD;AAEA,8EAA8E;AAC9E,wCAAwC;AACxC,+HAA+H;AAC/H,uFAAuF;AACvF,oHAAoH;AACpH,uHAAuH;AACvH,kHAAkH;AAClH,MAAM,iBAAiB,CAAA,SAAU,OAAO,cAAc,CAAC,KAAK,CAAC,MAAM,GAAG;AAEtE,gDAAgD;AAChD,MAAM,UAAU,CAAC,MAAM,UAAU;IAChC,MAAM,iBAAiB,IAAA,yKAAuB,EAAC;IAC/C,IAAA,4JAAU,EAAC;QACV,MAAM;QACN;QACA;QACA;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4283, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/io/output-sync.js"],"sourcesContent":["import {writeFileSync, appendFileSync} from 'node:fs';\nimport {shouldLogOutput, logLinesSync} from '../verbose/output.js';\nimport {runGeneratorsSync} from '../transform/generator.js';\nimport {splitLinesSync} from '../transform/split.js';\nimport {joinToString, joinToUint8Array, bufferToUint8Array} from '../utils/uint-array.js';\nimport {FILE_TYPES} from '../stdio/type.js';\nimport {truncateMaxBufferSync} from './max-buffer.js';\n\n// Apply `stdout`/`stderr` options, after spawning, in sync mode\nexport const transformOutputSync = ({fileDescriptors, syncResult: {output}, options, isMaxBuffer, verboseInfo}) => {\n\tif (output === null) {\n\t\treturn {output: Array.from({length: 3})};\n\t}\n\n\tconst state = {};\n\tconst outputFiles = new Set([]);\n\tconst transformedOutput = output.map((result, fdNumber) =>\n\t\ttransformOutputResultSync({\n\t\t\tresult,\n\t\t\tfileDescriptors,\n\t\t\tfdNumber,\n\t\t\tstate,\n\t\t\toutputFiles,\n\t\t\tisMaxBuffer,\n\t\t\tverboseInfo,\n\t\t}, options));\n\treturn {output: transformedOutput, ...state};\n};\n\nconst transformOutputResultSync = (\n\t{result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo},\n\t{buffer, encoding, lines, stripFinalNewline, maxBuffer},\n) => {\n\tif (result === null) {\n\t\treturn;\n\t}\n\n\tconst truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);\n\tconst uint8ArrayResult = bufferToUint8Array(truncatedResult);\n\tconst {stdioItems, objectMode} = fileDescriptors[fdNumber];\n\tconst chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);\n\tconst {serializedResult, finalResult = serializedResult} = serializeChunks({\n\t\tchunks,\n\t\tobjectMode,\n\t\tencoding,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tfdNumber,\n\t});\n\n\tlogOutputSync({\n\t\tserializedResult,\n\t\tfdNumber,\n\t\tstate,\n\t\tverboseInfo,\n\t\tencoding,\n\t\tstdioItems,\n\t\tobjectMode,\n\t});\n\n\tconst returnedResult = buffer[fdNumber] ? finalResult : undefined;\n\n\ttry {\n\t\tif (state.error === undefined) {\n\t\t\twriteToFiles(serializedResult, stdioItems, outputFiles);\n\t\t}\n\n\t\treturn returnedResult;\n\t} catch (error) {\n\t\tstate.error = error;\n\t\treturn returnedResult;\n\t}\n};\n\n// Applies transform generators to `stdout`/`stderr`\nconst runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {\n\ttry {\n\t\treturn runGeneratorsSync(chunks, stdioItems, encoding, false);\n\t} catch (error) {\n\t\tstate.error = error;\n\t\treturn chunks;\n\t}\n};\n\n// The contents is converted to three stages:\n//  - serializedResult: used when the target is a file path/URL or a file descriptor (including 'inherit')\n//  - finalResult/returnedResult: returned as `result.std*`\nconst serializeChunks = ({chunks, objectMode, encoding, lines, stripFinalNewline, fdNumber}) => {\n\tif (objectMode) {\n\t\treturn {serializedResult: chunks};\n\t}\n\n\tif (encoding === 'buffer') {\n\t\treturn {serializedResult: joinToUint8Array(chunks)};\n\t}\n\n\tconst serializedResult = joinToString(chunks, encoding);\n\tif (lines[fdNumber]) {\n\t\treturn {serializedResult, finalResult: splitLinesSync(serializedResult, !stripFinalNewline[fdNumber], objectMode)};\n\t}\n\n\treturn {serializedResult};\n};\n\nconst logOutputSync = ({serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode}) => {\n\tif (!shouldLogOutput({\n\t\tstdioItems,\n\t\tencoding,\n\t\tverboseInfo,\n\t\tfdNumber,\n\t})) {\n\t\treturn;\n\t}\n\n\tconst linesArray = splitLinesSync(serializedResult, false, objectMode);\n\n\ttry {\n\t\tlogLinesSync(linesArray, fdNumber, verboseInfo);\n\t} catch (error) {\n\t\tstate.error ??= error;\n\t}\n};\n\n// When the `std*` target is a file path/URL or a file descriptor\nconst writeToFiles = (serializedResult, stdioItems, outputFiles) => {\n\tfor (const {path, append} of stdioItems.filter(({type}) => FILE_TYPES.has(type))) {\n\t\tconst pathString = typeof path === 'string' ? path : path.toString();\n\t\tif (append || outputFiles.has(pathString)) {\n\t\t\tappendFileSync(path, serializedResult);\n\t\t} else {\n\t\t\toutputFiles.add(pathString);\n\t\t\twriteFileSync(path, serializedResult);\n\t\t}\n\t}\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4429, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/resolve/all-sync.js"],"sourcesContent":["import {isUint8Array, concatUint8Arrays} from '../utils/uint-array.js';\nimport {stripNewline} from '../io/strip-newline.js';\n\n// Retrieve `result.all` with synchronous methods\nexport const getAllSync = ([, stdout, stderr], options) => {\n\tif (!options.all) {\n\t\treturn;\n\t}\n\n\tif (stdout === undefined) {\n\t\treturn stderr;\n\t}\n\n\tif (stderr === undefined) {\n\t\treturn stdout;\n\t}\n\n\tif (Array.isArray(stdout)) {\n\t\treturn Array.isArray(stderr)\n\t\t\t? [...stdout, ...stderr]\n\t\t\t: [...stdout, stripNewline(stderr, options, 'all')];\n\t}\n\n\tif (Array.isArray(stderr)) {\n\t\treturn [stripNewline(stdout, options, 'all'), ...stderr];\n\t}\n\n\tif (isUint8Array(stdout) && isUint8Array(stderr)) {\n\t\treturn concatUint8Arrays([stdout, stderr]);\n\t}\n\n\treturn `${stdout}${stderr}`;\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAGO,MAAM,aAAa,CAAC,GAAG,QAAQ,OAAO,EAAE;IAC9C,IAAI,CAAC,QAAQ,GAAG,EAAE;QACjB;IACD;IAEA,IAAI,WAAW,WAAW;QACzB,OAAO;IACR;IAEA,IAAI,WAAW,WAAW;QACzB,OAAO;IACR;IAEA,IAAI,MAAM,OAAO,CAAC,SAAS;QAC1B,OAAO,MAAM,OAAO,CAAC,UAClB;eAAI;eAAW;SAAO,GACtB;eAAI;YAAQ,IAAA,sKAAY,EAAC,QAAQ,SAAS;SAAO;IACrD;IAEA,IAAI,MAAM,OAAO,CAAC,SAAS;QAC1B,OAAO;YAAC,IAAA,sKAAY,EAAC,QAAQ,SAAS;eAAW;SAAO;IACzD;IAEA,IAAI,IAAA,sKAAY,EAAC,WAAW,IAAA,sKAAY,EAAC,SAAS;QACjD,OAAO,IAAA,2KAAiB,EAAC;YAAC;YAAQ;SAAO;IAC1C;IAEA,OAAO,GAAG,SAAS,QAAQ;AAC5B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4474, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/resolve/exit-async.js"],"sourcesContent":["import {once} from 'node:events';\nimport {DiscardedError} from '../return/final-error.js';\n\n// If `error` is emitted before `spawn`, `exit` will never be emitted.\n// However, `error` might be emitted after `spawn`.\n// In that case, `exit` will still be emitted.\n// Since the `exit` event contains the signal name, we want to make sure we are listening for it.\n// This function also takes into account the following unlikely cases:\n//  - `exit` being emitted in the same microtask as `spawn`\n//  - `error` being emitted multiple times\nexport const waitForExit = async (subprocess, context) => {\n\tconst [exitCode, signal] = await waitForExitOrError(subprocess);\n\tcontext.isForcefullyTerminated ??= false;\n\treturn [exitCode, signal];\n};\n\nconst waitForExitOrError = async subprocess => {\n\tconst [spawnPayload, exitPayload] = await Promise.allSettled([\n\t\tonce(subprocess, 'spawn'),\n\t\tonce(subprocess, 'exit'),\n\t]);\n\n\tif (spawnPayload.status === 'rejected') {\n\t\treturn [];\n\t}\n\n\treturn exitPayload.status === 'rejected'\n\t\t? waitForSubprocessExit(subprocess)\n\t\t: exitPayload.value;\n};\n\nconst waitForSubprocessExit = async subprocess => {\n\ttry {\n\t\treturn await once(subprocess, 'exit');\n\t} catch {\n\t\treturn waitForSubprocessExit(subprocess);\n\t}\n};\n\n// Retrieve the final exit code and|or signal name\nexport const waitForSuccessfulExit = async exitPromise => {\n\tconst [exitCode, signal] = await exitPromise;\n\n\tif (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {\n\t\tthrow new DiscardedError();\n\t}\n\n\treturn [exitCode, signal];\n};\n\n// When the subprocess fails due to an `error` event\nconst isSubprocessErrorExit = (exitCode, signal) => exitCode === undefined && signal === undefined;\n// When the subprocess fails due to a non-0 exit code or to a signal termination\nexport const isFailedExit = (exitCode, signal) => exitCode !== 0 || signal !== null;\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AASO,MAAM,cAAc,OAAO,YAAY;IAC7C,MAAM,CAAC,UAAU,OAAO,GAAG,MAAM,mBAAmB;IACpD,QAAQ,sBAAsB,KAAK;IACnC,OAAO;QAAC;QAAU;KAAO;AAC1B;AAEA,MAAM,qBAAqB,OAAM;IAChC,MAAM,CAAC,cAAc,YAAY,GAAG,MAAM,QAAQ,UAAU,CAAC;QAC5D,IAAA,6HAAI,EAAC,YAAY;QACjB,IAAA,6HAAI,EAAC,YAAY;KACjB;IAED,IAAI,aAAa,MAAM,KAAK,YAAY;QACvC,OAAO,EAAE;IACV;IAEA,OAAO,YAAY,MAAM,KAAK,aAC3B,sBAAsB,cACtB,YAAY,KAAK;AACrB;AAEA,MAAM,wBAAwB,OAAM;IACnC,IAAI;QACH,OAAO,MAAM,IAAA,6HAAI,EAAC,YAAY;IAC/B,EAAE,OAAM;QACP,OAAO,sBAAsB;IAC9B;AACD;AAGO,MAAM,wBAAwB,OAAM;IAC1C,MAAM,CAAC,UAAU,OAAO,GAAG,MAAM;IAEjC,IAAI,CAAC,sBAAsB,UAAU,WAAW,aAAa,UAAU,SAAS;QAC/E,MAAM,IAAI,0KAAc;IACzB;IAEA,OAAO;QAAC;QAAU;KAAO;AAC1B;AAEA,oDAAoD;AACpD,MAAM,wBAAwB,CAAC,UAAU,SAAW,aAAa,aAAa,WAAW;AAElF,MAAM,eAAe,CAAC,UAAU,SAAW,aAAa,KAAK,WAAW","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4528, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/resolve/exit-sync.js"],"sourcesContent":["import {DiscardedError} from '../return/final-error.js';\nimport {isMaxBufferSync} from '../io/max-buffer.js';\nimport {isFailedExit} from './exit-async.js';\n\n// Retrieve exit code, signal name and error information, with synchronous methods\nexport const getExitResultSync = ({error, status: exitCode, signal, output}, {maxBuffer}) => {\n\tconst resultError = getResultError(error, exitCode, signal);\n\tconst timedOut = resultError?.code === 'ETIMEDOUT';\n\tconst isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);\n\treturn {\n\t\tresultError,\n\t\texitCode,\n\t\tsignal,\n\t\ttimedOut,\n\t\tisMaxBuffer,\n\t};\n};\n\nconst getResultError = (error, exitCode, signal) => {\n\tif (error !== undefined) {\n\t\treturn error;\n\t}\n\n\treturn isFailedExit(exitCode, signal) ? new DiscardedError() : undefined;\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAGO,MAAM,oBAAoB,CAAC,EAAC,KAAK,EAAE,QAAQ,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAC,EAAE,EAAC,SAAS,EAAC;IACvF,MAAM,cAAc,eAAe,OAAO,UAAU;IACpD,MAAM,WAAW,aAAa,SAAS;IACvC,MAAM,cAAc,IAAA,sKAAe,EAAC,aAAa,QAAQ;IACzD,OAAO;QACN;QACA;QACA;QACA;QACA;IACD;AACD;AAEA,MAAM,iBAAiB,CAAC,OAAO,UAAU;IACxC,IAAI,UAAU,WAAW;QACxB,OAAO;IACR;IAEA,OAAO,IAAA,wKAAY,EAAC,UAAU,UAAU,IAAI,0KAAc,KAAK;AAChE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4560, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/methods/main-sync.js"],"sourcesContent":["import {spawnSync} from 'node:child_process';\nimport {handleCommand} from '../arguments/command.js';\nimport {normalizeOptions} from '../arguments/options.js';\nimport {concatenateShell} from '../arguments/shell.js';\nimport {makeError, makeEarlyError, makeSuccessResult} from '../return/result.js';\nimport {handleResult} from '../return/reject.js';\nimport {handleStdioSync} from '../stdio/handle-sync.js';\nimport {stripNewline} from '../io/strip-newline.js';\nimport {addInputOptionsSync} from '../io/input-sync.js';\nimport {transformOutputSync} from '../io/output-sync.js';\nimport {getMaxBufferSync} from '../io/max-buffer.js';\nimport {getAllSync} from '../resolve/all-sync.js';\nimport {getExitResultSync} from '../resolve/exit-sync.js';\n\n// Main shared logic for all sync methods: `execaSync()`, `$.sync()`\nexport const execaCoreSync = (rawFile, rawArguments, rawOptions) => {\n\tconst {file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors} = handleSyncArguments(rawFile, rawArguments, rawOptions);\n\tconst result = spawnSubprocessSync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t});\n\treturn handleResult(result, verboseInfo, options);\n};\n\n// Compute arguments to pass to `child_process.spawnSync()`\nconst handleSyncArguments = (rawFile, rawArguments, rawOptions) => {\n\tconst {command, escapedCommand, startTime, verboseInfo} = handleCommand(rawFile, rawArguments, rawOptions);\n\tconst syncOptions = normalizeSyncOptions(rawOptions);\n\tconst {file, commandArguments, options} = normalizeOptions(rawFile, rawArguments, syncOptions);\n\tvalidateSyncOptions(options);\n\tconst fileDescriptors = handleStdioSync(options, verboseInfo);\n\treturn {\n\t\tfile,\n\t\tcommandArguments,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\toptions,\n\t\tfileDescriptors,\n\t};\n};\n\n// Options normalization logic specific to sync methods\nconst normalizeSyncOptions = options => options.node && !options.ipc ? {...options, ipc: false} : options;\n\n// Options validation logic specific to sync methods\nconst validateSyncOptions = ({ipc, ipcInput, detached, cancelSignal}) => {\n\tif (ipcInput) {\n\t\tthrowInvalidSyncOption('ipcInput');\n\t}\n\n\tif (ipc) {\n\t\tthrowInvalidSyncOption('ipc: true');\n\t}\n\n\tif (detached) {\n\t\tthrowInvalidSyncOption('detached: true');\n\t}\n\n\tif (cancelSignal) {\n\t\tthrowInvalidSyncOption('cancelSignal');\n\t}\n};\n\nconst throwInvalidSyncOption = value => {\n\tthrow new TypeError(`The \"${value}\" option cannot be used with synchronous methods.`);\n};\n\nconst spawnSubprocessSync = ({file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime}) => {\n\tconst syncResult = runSubprocessSync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t});\n\tif (syncResult.failed) {\n\t\treturn syncResult;\n\t}\n\n\tconst {resultError, exitCode, signal, timedOut, isMaxBuffer} = getExitResultSync(syncResult, options);\n\tconst {output, error = resultError} = transformOutputSync({\n\t\tfileDescriptors,\n\t\tsyncResult,\n\t\toptions,\n\t\tisMaxBuffer,\n\t\tverboseInfo,\n\t});\n\tconst stdio = output.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options, fdNumber));\n\tconst all = stripNewline(getAllSync(output, options), options, 'all');\n\treturn getSyncResult({\n\t\terror,\n\t\texitCode,\n\t\tsignal,\n\t\ttimedOut,\n\t\tisMaxBuffer,\n\t\tstdio,\n\t\tall,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t});\n};\n\nconst runSubprocessSync = ({file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime}) => {\n\ttry {\n\t\taddInputOptionsSync(fileDescriptors, options);\n\t\tconst normalizedOptions = normalizeSpawnSyncOptions(options);\n\t\treturn spawnSync(...concatenateShell(file, commandArguments, normalizedOptions));\n\t} catch (error) {\n\t\treturn makeEarlyError({\n\t\t\terror,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tfileDescriptors,\n\t\t\toptions,\n\t\t\tstartTime,\n\t\t\tisSync: true,\n\t\t});\n\t}\n};\n\n// The `encoding` option is handled by Execa, not by `child_process.spawnSync()`\nconst normalizeSpawnSyncOptions = ({encoding, maxBuffer, ...options}) => ({...options, encoding: 'buffer', maxBuffer: getMaxBufferSync(maxBuffer)});\n\nconst getSyncResult = ({error, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command, escapedCommand, startTime}) => error === undefined\n\t? makeSuccessResult({\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput: [],\n\t\toptions,\n\t\tstartTime,\n\t})\n\t: makeError({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\ttimedOut,\n\t\tisCanceled: false,\n\t\tisGracefullyCanceled: false,\n\t\tisMaxBuffer,\n\t\tisForcefullyTerminated: false,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput: [],\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: true,\n\t});\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4735, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/get-one.js"],"sourcesContent":["import {once, on} from 'node:events';\nimport {\n\tvalidateIpcMethod,\n\tthrowOnEarlyDisconnect,\n\tdisconnect,\n\tgetStrictResponseError,\n} from './validation.js';\nimport {getIpcEmitter, isConnected} from './forward.js';\nimport {addReference, removeReference} from './reference.js';\n\n// Like `[sub]process.once('message')` but promise-based\nexport const getOneMessage = ({anyProcess, channel, isSubprocess, ipc}, {reference = true, filter} = {}) => {\n\tvalidateIpcMethod({\n\t\tmethodName: 'getOneMessage',\n\t\tisSubprocess,\n\t\tipc,\n\t\tisConnected: isConnected(anyProcess),\n\t});\n\n\treturn getOneMessageAsync({\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tfilter,\n\t\treference,\n\t});\n};\n\nconst getOneMessageAsync = async ({anyProcess, channel, isSubprocess, filter, reference}) => {\n\taddReference(channel, reference);\n\tconst ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);\n\tconst controller = new AbortController();\n\ttry {\n\t\treturn await Promise.race([\n\t\t\tgetMessage(ipcEmitter, filter, controller),\n\t\t\tthrowOnDisconnect(ipcEmitter, isSubprocess, controller),\n\t\t\tthrowOnStrictError(ipcEmitter, isSubprocess, controller),\n\t\t]);\n\t} catch (error) {\n\t\tdisconnect(anyProcess);\n\t\tthrow error;\n\t} finally {\n\t\tcontroller.abort();\n\t\tremoveReference(channel, reference);\n\t}\n};\n\nconst getMessage = async (ipcEmitter, filter, {signal}) => {\n\tif (filter === undefined) {\n\t\tconst [message] = await once(ipcEmitter, 'message', {signal});\n\t\treturn message;\n\t}\n\n\tfor await (const [message] of on(ipcEmitter, 'message', {signal})) {\n\t\tif (filter(message)) {\n\t\t\treturn message;\n\t\t}\n\t}\n};\n\nconst throwOnDisconnect = async (ipcEmitter, isSubprocess, {signal}) => {\n\tawait once(ipcEmitter, 'disconnect', {signal});\n\tthrowOnEarlyDisconnect(isSubprocess);\n};\n\nconst throwOnStrictError = async (ipcEmitter, isSubprocess, {signal}) => {\n\tconst [error] = await once(ipcEmitter, 'strict:error', {signal});\n\tthrow getStrictResponseError(error, isSubprocess);\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AAMA;AACA;;;;;AAGO,MAAM,gBAAgB,CAAC,EAAC,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,GAAG,EAAC,EAAE,EAAC,YAAY,IAAI,EAAE,MAAM,EAAC,GAAG,CAAC,CAAC;IACtG,IAAA,sKAAiB,EAAC;QACjB,YAAY;QACZ;QACA;QACA,aAAa,IAAA,6JAAW,EAAC;IAC1B;IAEA,OAAO,mBAAmB;QACzB;QACA;QACA;QACA;QACA;IACD;AACD;AAEA,MAAM,qBAAqB,OAAO,EAAC,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,MAAM,EAAE,SAAS,EAAC;IACvF,IAAA,gKAAY,EAAC,SAAS;IACtB,MAAM,aAAa,IAAA,+JAAa,EAAC,YAAY,SAAS;IACtD,MAAM,aAAa,IAAI;IACvB,IAAI;QACH,OAAO,MAAM,QAAQ,IAAI,CAAC;YACzB,WAAW,YAAY,QAAQ;YAC/B,kBAAkB,YAAY,cAAc;YAC5C,mBAAmB,YAAY,cAAc;SAC7C;IACF,EAAE,OAAO,OAAO;QACf,IAAA,+JAAU,EAAC;QACX,MAAM;IACP,SAAU;QACT,WAAW,KAAK;QAChB,IAAA,mKAAe,EAAC,SAAS;IAC1B;AACD;AAEA,MAAM,aAAa,OAAO,YAAY,QAAQ,EAAC,MAAM,EAAC;IACrD,IAAI,WAAW,WAAW;QACzB,MAAM,CAAC,QAAQ,GAAG,MAAM,IAAA,6HAAI,EAAC,YAAY,WAAW;YAAC;QAAM;QAC3D,OAAO;IACR;IAEA,WAAW,MAAM,CAAC,QAAQ,IAAI,IAAA,2HAAE,EAAC,YAAY,WAAW;QAAC;IAAM,GAAI;QAClE,IAAI,OAAO,UAAU;YACpB,OAAO;QACR;IACD;AACD;AAEA,MAAM,oBAAoB,OAAO,YAAY,cAAc,EAAC,MAAM,EAAC;IAClE,MAAM,IAAA,6HAAI,EAAC,YAAY,cAAc;QAAC;IAAM;IAC5C,IAAA,2KAAsB,EAAC;AACxB;AAEA,MAAM,qBAAqB,OAAO,YAAY,cAAc,EAAC,MAAM,EAAC;IACnE,MAAM,CAAC,MAAM,GAAG,MAAM,IAAA,6HAAI,EAAC,YAAY,gBAAgB;QAAC;IAAM;IAC9D,MAAM,IAAA,2KAAsB,EAAC,OAAO;AACrC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4811, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/get-each.js"],"sourcesContent":["import {once, on} from 'node:events';\nimport {validateIpcMethod, disconnect, getStrictResponseError} from './validation.js';\nimport {getIpcEmitter, isConnected} from './forward.js';\nimport {addReference, removeReference} from './reference.js';\n\n// Like `[sub]process.on('message')` but promise-based\nexport const getEachMessage = ({anyProcess, channel, isSubprocess, ipc}, {reference = true} = {}) => loopOnMessages({\n\tanyProcess,\n\tchannel,\n\tisSubprocess,\n\tipc,\n\tshouldAwait: !isSubprocess,\n\treference,\n});\n\n// Same but used internally\nexport const loopOnMessages = ({anyProcess, channel, isSubprocess, ipc, shouldAwait, reference}) => {\n\tvalidateIpcMethod({\n\t\tmethodName: 'getEachMessage',\n\t\tisSubprocess,\n\t\tipc,\n\t\tisConnected: isConnected(anyProcess),\n\t});\n\n\taddReference(channel, reference);\n\tconst ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);\n\tconst controller = new AbortController();\n\tconst state = {};\n\tstopOnDisconnect(anyProcess, ipcEmitter, controller);\n\tabortOnStrictError({\n\t\tipcEmitter,\n\t\tisSubprocess,\n\t\tcontroller,\n\t\tstate,\n\t});\n\treturn iterateOnMessages({\n\t\tanyProcess,\n\t\tchannel,\n\t\tipcEmitter,\n\t\tisSubprocess,\n\t\tshouldAwait,\n\t\tcontroller,\n\t\tstate,\n\t\treference,\n\t});\n};\n\nconst stopOnDisconnect = async (anyProcess, ipcEmitter, controller) => {\n\ttry {\n\t\tawait once(ipcEmitter, 'disconnect', {signal: controller.signal});\n\t\tcontroller.abort();\n\t} catch {}\n};\n\nconst abortOnStrictError = async ({ipcEmitter, isSubprocess, controller, state}) => {\n\ttry {\n\t\tconst [error] = await once(ipcEmitter, 'strict:error', {signal: controller.signal});\n\t\tstate.error = getStrictResponseError(error, isSubprocess);\n\t\tcontroller.abort();\n\t} catch {}\n};\n\nconst iterateOnMessages = async function * ({anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference}) {\n\ttry {\n\t\tfor await (const [message] of on(ipcEmitter, 'message', {signal: controller.signal})) {\n\t\t\tthrowIfStrictError(state);\n\t\t\tyield message;\n\t\t}\n\t} catch {\n\t\tthrowIfStrictError(state);\n\t} finally {\n\t\tcontroller.abort();\n\t\tremoveReference(channel, reference);\n\n\t\tif (!isSubprocess) {\n\t\t\tdisconnect(anyProcess);\n\t\t}\n\n\t\tif (shouldAwait) {\n\t\t\tawait anyProcess;\n\t\t}\n\t}\n};\n\nconst throwIfStrictError = ({error}) => {\n\tif (error) {\n\t\tthrow error;\n\t}\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAGO,MAAM,iBAAiB,CAAC,EAAC,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,GAAG,EAAC,EAAE,EAAC,YAAY,IAAI,EAAC,GAAG,CAAC,CAAC,GAAK,eAAe;QACnH;QACA;QACA;QACA;QACA,aAAa,CAAC;QACd;IACD;AAGO,MAAM,iBAAiB,CAAC,EAAC,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,GAAG,EAAE,WAAW,EAAE,SAAS,EAAC;IAC9F,IAAA,sKAAiB,EAAC;QACjB,YAAY;QACZ;QACA;QACA,aAAa,IAAA,6JAAW,EAAC;IAC1B;IAEA,IAAA,gKAAY,EAAC,SAAS;IACtB,MAAM,aAAa,IAAA,+JAAa,EAAC,YAAY,SAAS;IACtD,MAAM,aAAa,IAAI;IACvB,MAAM,QAAQ,CAAC;IACf,iBAAiB,YAAY,YAAY;IACzC,mBAAmB;QAClB;QACA;QACA;QACA;IACD;IACA,OAAO,kBAAkB;QACxB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACD;AACD;AAEA,MAAM,mBAAmB,OAAO,YAAY,YAAY;IACvD,IAAI;QACH,MAAM,IAAA,6HAAI,EAAC,YAAY,cAAc;YAAC,QAAQ,WAAW,MAAM;QAAA;QAC/D,WAAW,KAAK;IACjB,EAAE,OAAM,CAAC;AACV;AAEA,MAAM,qBAAqB,OAAO,EAAC,UAAU,EAAE,YAAY,EAAE,UAAU,EAAE,KAAK,EAAC;IAC9E,IAAI;QACH,MAAM,CAAC,MAAM,GAAG,MAAM,IAAA,6HAAI,EAAC,YAAY,gBAAgB;YAAC,QAAQ,WAAW,MAAM;QAAA;QACjF,MAAM,KAAK,GAAG,IAAA,2KAAsB,EAAC,OAAO;QAC5C,WAAW,KAAK;IACjB,EAAE,OAAM,CAAC;AACV;AAEA,MAAM,oBAAoB,gBAAkB,EAAC,UAAU,EAAE,OAAO,EAAE,UAAU,EAAE,YAAY,EAAE,WAAW,EAAE,UAAU,EAAE,KAAK,EAAE,SAAS,EAAC;IACrI,IAAI;QACH,WAAW,MAAM,CAAC,QAAQ,IAAI,IAAA,2HAAE,EAAC,YAAY,WAAW;YAAC,QAAQ,WAAW,MAAM;QAAA,GAAI;YACrF,mBAAmB;YACnB,MAAM;QACP;IACD,EAAE,OAAM;QACP,mBAAmB;IACpB,SAAU;QACT,WAAW,KAAK;QAChB,IAAA,mKAAe,EAAC,SAAS;QAEzB,IAAI,CAAC,cAAc;YAClB,IAAA,+JAAU,EAAC;QACZ;QAEA,IAAI,aAAa;YAChB,MAAM;QACP;IACD;AACD;AAEA,MAAM,qBAAqB,CAAC,EAAC,KAAK,EAAC;IAClC,IAAI,OAAO;QACV,MAAM;IACP;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4909, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/methods.js"],"sourcesContent":["import process from 'node:process';\nimport {sendMessage} from './send.js';\nimport {getOneMessage} from './get-one.js';\nimport {getEachMessage} from './get-each.js';\nimport {getCancelSignal} from './graceful.js';\n\n// Add promise-based IPC methods in current process\nexport const addIpcMethods = (subprocess, {ipc}) => {\n\tObject.assign(subprocess, getIpcMethods(subprocess, false, ipc));\n};\n\n// Get promise-based IPC in the subprocess\nexport const getIpcExport = () => {\n\tconst anyProcess = process;\n\tconst isSubprocess = true;\n\tconst ipc = process.channel !== undefined;\n\n\treturn {\n\t\t...getIpcMethods(anyProcess, isSubprocess, ipc),\n\t\tgetCancelSignal: getCancelSignal.bind(undefined, {\n\t\t\tanyProcess,\n\t\t\tchannel: anyProcess.channel,\n\t\t\tisSubprocess,\n\t\t\tipc,\n\t\t}),\n\t};\n};\n\n// Retrieve the `ipc` shared by both the current process and the subprocess\nconst getIpcMethods = (anyProcess, isSubprocess, ipc) => ({\n\tsendMessage: sendMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel: anyProcess.channel,\n\t\tisSubprocess,\n\t\tipc,\n\t}),\n\tgetOneMessage: getOneMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel: anyProcess.channel,\n\t\tisSubprocess,\n\t\tipc,\n\t}),\n\tgetEachMessage: getEachMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel: anyProcess.channel,\n\t\tisSubprocess,\n\t\tipc,\n\t}),\n});\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAGO,MAAM,gBAAgB,CAAC,YAAY,EAAC,GAAG,EAAC;IAC9C,OAAO,MAAM,CAAC,YAAY,cAAc,YAAY,OAAO;AAC5D;AAGO,MAAM,eAAe;IAC3B,MAAM,aAAa,kIAAO;IAC1B,MAAM,eAAe;IACrB,MAAM,MAAM,kIAAO,CAAC,OAAO,KAAK;IAEhC,OAAO;QACN,GAAG,cAAc,YAAY,cAAc,IAAI;QAC/C,iBAAiB,kKAAe,CAAC,IAAI,CAAC,WAAW;YAChD;YACA,SAAS,WAAW,OAAO;YAC3B;YACA;QACD;IACD;AACD;AAEA,2EAA2E;AAC3E,MAAM,gBAAgB,CAAC,YAAY,cAAc,MAAQ,CAAC;QACzD,aAAa,0JAAW,CAAC,IAAI,CAAC,WAAW;YACxC;YACA,SAAS,WAAW,OAAO;YAC3B;YACA;QACD;QACA,eAAe,kKAAa,CAAC,IAAI,CAAC,WAAW;YAC5C;YACA,SAAS,WAAW,OAAO;YAC3B;YACA;QACD;QACA,gBAAgB,oKAAc,CAAC,IAAI,CAAC,WAAW;YAC9C;YACA,SAAS,WAAW,OAAO;YAC3B;YACA;QACD;IACD,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4967, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/return/early-error.js"],"sourcesContent":["import {ChildProcess} from 'node:child_process';\nimport {\n\tPassThrough,\n\tReadable,\n\tWritable,\n\tDuplex,\n} from 'node:stream';\nimport {cleanupCustomStreams} from '../stdio/handle.js';\nimport {makeEarlyError} from './result.js';\nimport {handleResult} from './reject.js';\n\n// When the subprocess fails to spawn.\n// We ensure the returned error is always both a promise and a subprocess.\nexport const handleEarlyError = ({error, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo}) => {\n\tcleanupCustomStreams(fileDescriptors);\n\n\tconst subprocess = new ChildProcess();\n\tcreateDummyStreams(subprocess, fileDescriptors);\n\tObject.assign(subprocess, {readable, writable, duplex});\n\n\tconst earlyError = makeEarlyError({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: false,\n\t});\n\tconst promise = handleDummyPromise(earlyError, verboseInfo, options);\n\treturn {subprocess, promise};\n};\n\nconst createDummyStreams = (subprocess, fileDescriptors) => {\n\tconst stdin = createDummyStream();\n\tconst stdout = createDummyStream();\n\tconst stderr = createDummyStream();\n\tconst extraStdio = Array.from({length: fileDescriptors.length - 3}, createDummyStream);\n\tconst all = createDummyStream();\n\tconst stdio = [stdin, stdout, stderr, ...extraStdio];\n\tObject.assign(subprocess, {\n\t\tstdin,\n\t\tstdout,\n\t\tstderr,\n\t\tall,\n\t\tstdio,\n\t});\n};\n\nconst createDummyStream = () => {\n\tconst stream = new PassThrough();\n\tstream.end();\n\treturn stream;\n};\n\nconst readable = () => new Readable({read() {}});\nconst writable = () => new Writable({write() {}});\nconst duplex = () => new Duplex({read() {}, write() {}});\n\nconst handleDummyPromise = async (error, verboseInfo, options) => handleResult(error, verboseInfo, options);\n"],"names":[],"mappings":";;;;AAAA;AACA;AAMA;AACA;AACA;;;;;;AAIO,MAAM,mBAAmB,CAAC,EAAC,KAAK,EAAE,OAAO,EAAE,cAAc,EAAE,eAAe,EAAE,OAAO,EAAE,SAAS,EAAE,WAAW,EAAC;IAClH,IAAA,uKAAoB,EAAC;IAErB,MAAM,aAAa,IAAI,mJAAY;IACnC,mBAAmB,YAAY;IAC/B,OAAO,MAAM,CAAC,YAAY;QAAC;QAAU;QAAU;IAAM;IAErD,MAAM,aAAa,IAAA,kKAAc,EAAC;QACjC;QACA;QACA;QACA;QACA;QACA;QACA,QAAQ;IACT;IACA,MAAM,UAAU,mBAAmB,YAAY,aAAa;IAC5D,OAAO;QAAC;QAAY;IAAO;AAC5B;AAEA,MAAM,qBAAqB,CAAC,YAAY;IACvC,MAAM,QAAQ;IACd,MAAM,SAAS;IACf,MAAM,SAAS;IACf,MAAM,aAAa,MAAM,IAAI,CAAC;QAAC,QAAQ,gBAAgB,MAAM,GAAG;IAAC,GAAG;IACpE,MAAM,MAAM;IACZ,MAAM,QAAQ;QAAC;QAAO;QAAQ;WAAW;KAAW;IACpD,OAAO,MAAM,CAAC,YAAY;QACzB;QACA;QACA;QACA;QACA;IACD;AACD;AAEA,MAAM,oBAAoB;IACzB,MAAM,SAAS,IAAI,oIAAW;IAC9B,OAAO,GAAG;IACV,OAAO;AACR;AAEA,MAAM,WAAW,IAAM,IAAI,iIAAQ,CAAC;QAAC,SAAQ;IAAC;AAC9C,MAAM,WAAW,IAAM,IAAI,iIAAQ,CAAC;QAAC,UAAS;IAAC;AAC/C,MAAM,SAAS,IAAM,IAAI,+HAAM,CAAC;QAAC,SAAQ;QAAG,UAAS;IAAC;AAEtD,MAAM,qBAAqB,OAAO,OAAO,aAAa,UAAY,IAAA,gKAAY,EAAC,OAAO,aAAa","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5047, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/stdio/handle-async.js"],"sourcesContent":["import {createReadStream, createWriteStream} from 'node:fs';\nimport {Buffer} from 'node:buffer';\nimport {Readable, Writable, Duplex} from 'node:stream';\nimport {generatorToStream} from '../transform/generator.js';\nimport {handleStdio} from './handle.js';\nimport {TYPE_TO_MESSAGE} from './type.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async mode\nexport const handleStdioAsync = (options, verboseInfo) => handleStdio(addPropertiesAsync, options, verboseInfo, false);\n\nconst forbiddenIfAsync = ({type, optionName}) => {\n\tthrow new TypeError(`The \\`${optionName}\\` option cannot be ${TYPE_TO_MESSAGE[type]}.`);\n};\n\n// Create streams used internally for piping when using specific values for the `std*` options, in async mode.\n// For example, `stdout: {file}` creates a file stream, which is piped from/to.\nconst addProperties = {\n\tfileNumber: forbiddenIfAsync,\n\tgenerator: generatorToStream,\n\tasyncGenerator: generatorToStream,\n\tnodeStream: ({value}) => ({stream: value}),\n\twebTransform({value: {transform, writableObjectMode, readableObjectMode}}) {\n\t\tconst objectMode = writableObjectMode || readableObjectMode;\n\t\tconst stream = Duplex.fromWeb(transform, {objectMode});\n\t\treturn {stream};\n\t},\n\tduplex: ({value: {transform}}) => ({stream: transform}),\n\tnative() {},\n};\n\nconst addPropertiesAsync = {\n\tinput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({stream: createReadStream(value)}),\n\t\tfilePath: ({value: {file}}) => ({stream: createReadStream(file)}),\n\t\twebStream: ({value}) => ({stream: Readable.fromWeb(value)}),\n\t\titerable: ({value}) => ({stream: Readable.from(value)}),\n\t\tasyncIterable: ({value}) => ({stream: Readable.from(value)}),\n\t\tstring: ({value}) => ({stream: Readable.from(value)}),\n\t\tuint8Array: ({value}) => ({stream: Readable.from(Buffer.from(value))}),\n\t},\n\toutput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({stream: createWriteStream(value)}),\n\t\tfilePath: ({value: {file, append}}) => ({stream: createWriteStream(file, append ? {flags: 'a'} : {})}),\n\t\twebStream: ({value}) => ({stream: Writable.fromWeb(value)}),\n\t\titerable: forbiddenIfAsync,\n\t\tasyncIterable: forbiddenIfAsync,\n\t\tstring: forbiddenIfAsync,\n\t\tuint8Array: forbiddenIfAsync,\n\t},\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAGO,MAAM,mBAAmB,CAAC,SAAS,cAAgB,IAAA,8JAAW,EAAC,oBAAoB,SAAS,aAAa;AAEhH,MAAM,mBAAmB,CAAC,EAAC,IAAI,EAAE,UAAU,EAAC;IAC3C,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE,WAAW,oBAAoB,EAAE,gKAAe,CAAC,KAAK,CAAC,CAAC,CAAC;AACvF;AAEA,8GAA8G;AAC9G,+EAA+E;AAC/E,MAAM,gBAAgB;IACrB,YAAY;IACZ,WAAW,2KAAiB;IAC5B,gBAAgB,2KAAiB;IACjC,YAAY,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;YAAC,QAAQ;QAAK,CAAC;IACzC,cAAa,EAAC,OAAO,EAAC,SAAS,EAAE,kBAAkB,EAAE,kBAAkB,EAAC,EAAC;QACxE,MAAM,aAAa,sBAAsB;QACzC,MAAM,SAAS,+HAAM,CAAC,OAAO,CAAC,WAAW;YAAC;QAAU;QACpD,OAAO;YAAC;QAAM;IACf;IACA,QAAQ,CAAC,EAAC,OAAO,EAAC,SAAS,EAAC,EAAC,GAAK,CAAC;YAAC,QAAQ;QAAS,CAAC;IACtD,WAAU;AACX;AAEA,MAAM,qBAAqB;IAC1B,OAAO;QACN,GAAG,aAAa;QAChB,SAAS,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,QAAQ,IAAA,iIAAgB,EAAC;YAAM,CAAC;QACxD,UAAU,CAAC,EAAC,OAAO,EAAC,IAAI,EAAC,EAAC,GAAK,CAAC;gBAAC,QAAQ,IAAA,iIAAgB,EAAC;YAAK,CAAC;QAChE,WAAW,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,QAAQ,iIAAQ,CAAC,OAAO,CAAC;YAAM,CAAC;QAC1D,UAAU,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,QAAQ,iIAAQ,CAAC,IAAI,CAAC;YAAM,CAAC;QACtD,eAAe,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,QAAQ,iIAAQ,CAAC,IAAI,CAAC;YAAM,CAAC;QAC3D,QAAQ,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,QAAQ,iIAAQ,CAAC,IAAI,CAAC;YAAM,CAAC;QACpD,YAAY,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,QAAQ,iIAAQ,CAAC,IAAI,CAAC,+HAAM,CAAC,IAAI,CAAC;YAAO,CAAC;IACtE;IACA,QAAQ;QACP,GAAG,aAAa;QAChB,SAAS,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,QAAQ,IAAA,kIAAiB,EAAC;YAAM,CAAC;QACzD,UAAU,CAAC,EAAC,OAAO,EAAC,IAAI,EAAE,MAAM,EAAC,EAAC,GAAK,CAAC;gBAAC,QAAQ,IAAA,kIAAiB,EAAC,MAAM,SAAS;oBAAC,OAAO;gBAAG,IAAI,CAAC;YAAE,CAAC;QACrG,WAAW,CAAC,EAAC,KAAK,EAAC,GAAK,CAAC;gBAAC,QAAQ,iIAAQ,CAAC,OAAO,CAAC;YAAM,CAAC;QAC1D,UAAU;QACV,eAAe;QACf,QAAQ;QACR,YAAY;IACb;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5138, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/io/pipeline.js"],"sourcesContent":["import {finished} from 'node:stream/promises';\nimport {isStandardStream} from '../utils/standard-stream.js';\n\n// Similar to `Stream.pipeline(source, destination)`, but does not destroy standard streams\nexport const pipeStreams = (source, destination) => {\n\tsource.pipe(destination);\n\tonSourceFinish(source, destination);\n\tonDestinationFinish(source, destination);\n};\n\n// `source.pipe(destination)` makes `destination` end when `source` ends.\n// But it does not propagate aborts or errors. This function does it.\nconst onSourceFinish = async (source, destination) => {\n\tif (isStandardStream(source) || isStandardStream(destination)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait finished(source, {cleanup: true, readable: true, writable: false});\n\t} catch {}\n\n\tendDestinationStream(destination);\n};\n\nexport const endDestinationStream = destination => {\n\tif (destination.writable) {\n\t\tdestination.end();\n\t}\n};\n\n// We do the same thing in the other direction as well.\nconst onDestinationFinish = async (source, destination) => {\n\tif (isStandardStream(source) || isStandardStream(destination)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait finished(destination, {cleanup: true, readable: false, writable: true});\n\t} catch {}\n\n\tabortSourceStream(source);\n};\n\nexport const abortSourceStream = source => {\n\tif (source.readable) {\n\t\tsource.destroy();\n\t}\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAGO,MAAM,cAAc,CAAC,QAAQ;IACnC,OAAO,IAAI,CAAC;IACZ,eAAe,QAAQ;IACvB,oBAAoB,QAAQ;AAC7B;AAEA,yEAAyE;AACzE,qEAAqE;AACrE,MAAM,iBAAiB,OAAO,QAAQ;IACrC,IAAI,IAAA,+KAAgB,EAAC,WAAW,IAAA,+KAAgB,EAAC,cAAc;QAC9D;IACD;IAEA,IAAI;QACH,MAAM,IAAA,yJAAQ,EAAC,QAAQ;YAAC,SAAS;YAAM,UAAU;YAAM,UAAU;QAAK;IACvE,EAAE,OAAM,CAAC;IAET,qBAAqB;AACtB;AAEO,MAAM,uBAAuB,CAAA;IACnC,IAAI,YAAY,QAAQ,EAAE;QACzB,YAAY,GAAG;IAChB;AACD;AAEA,uDAAuD;AACvD,MAAM,sBAAsB,OAAO,QAAQ;IAC1C,IAAI,IAAA,+KAAgB,EAAC,WAAW,IAAA,+KAAgB,EAAC,cAAc;QAC9D;IACD;IAEA,IAAI;QACH,MAAM,IAAA,yJAAQ,EAAC,aAAa;YAAC,SAAS;YAAM,UAAU;YAAO,UAAU;QAAI;IAC5E,EAAE,OAAM,CAAC;IAET,kBAAkB;AACnB;AAEO,MAAM,oBAAoB,CAAA;IAChC,IAAI,OAAO,QAAQ,EAAE;QACpB,OAAO,OAAO;IACf;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5198, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/io/output-async.js"],"sourcesContent":["import mergeStreams from '@sindresorhus/merge-streams';\nimport {isStandardStream} from '../utils/standard-stream.js';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {pipeStreams} from './pipeline.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, after spawning, in async mode\n// When multiple input streams are used, we merge them to ensure the output stream ends only once each input stream has ended\nexport const pipeOutputAsync = (subprocess, fileDescriptors, controller) => {\n\tconst pipeGroups = new Map();\n\n\tfor (const [fdNumber, {stdioItems, direction}] of Object.entries(fileDescriptors)) {\n\t\tfor (const {stream} of stdioItems.filter(({type}) => TRANSFORM_TYPES.has(type))) {\n\t\t\tpipeTransform(subprocess, stream, direction, fdNumber);\n\t\t}\n\n\t\tfor (const {stream} of stdioItems.filter(({type}) => !TRANSFORM_TYPES.has(type))) {\n\t\t\tpipeStdioItem({\n\t\t\t\tsubprocess,\n\t\t\t\tstream,\n\t\t\t\tdirection,\n\t\t\t\tfdNumber,\n\t\t\t\tpipeGroups,\n\t\t\t\tcontroller,\n\t\t\t});\n\t\t}\n\t}\n\n\tfor (const [outputStream, inputStreams] of pipeGroups.entries()) {\n\t\tconst inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);\n\t\tpipeStreams(inputStream, outputStream);\n\t}\n};\n\n// When using transforms, `subprocess.stdin|stdout|stderr|stdio` is directly mutated\nconst pipeTransform = (subprocess, stream, direction, fdNumber) => {\n\tif (direction === 'output') {\n\t\tpipeStreams(subprocess.stdio[fdNumber], stream);\n\t} else {\n\t\tpipeStreams(stream, subprocess.stdio[fdNumber]);\n\t}\n\n\tconst streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];\n\tif (streamProperty !== undefined) {\n\t\tsubprocess[streamProperty] = stream;\n\t}\n\n\tsubprocess.stdio[fdNumber] = stream;\n};\n\nconst SUBPROCESS_STREAM_PROPERTIES = ['stdin', 'stdout', 'stderr'];\n\n// Most `std*` option values involve piping `subprocess.std*` to a stream.\n// The stream is either passed by the user or created internally.\nconst pipeStdioItem = ({subprocess, stream, direction, fdNumber, pipeGroups, controller}) => {\n\tif (stream === undefined) {\n\t\treturn;\n\t}\n\n\tsetStandardStreamMaxListeners(stream, controller);\n\n\tconst [inputStream, outputStream] = direction === 'output'\n\t\t? [stream, subprocess.stdio[fdNumber]]\n\t\t: [subprocess.stdio[fdNumber], stream];\n\tconst outputStreams = pipeGroups.get(inputStream) ?? [];\n\tpipeGroups.set(inputStream, [...outputStreams, outputStream]);\n};\n\n// Multiple subprocesses might be piping from/to `process.std*` at the same time.\n// This is not necessarily an error and should not print a `maxListeners` warning.\nconst setStandardStreamMaxListeners = (stream, {signal}) => {\n\tif (isStandardStream(stream)) {\n\t\tincrementMaxListeners(stream, MAX_LISTENERS_INCREMENT, signal);\n\t}\n};\n\n// `source.pipe(destination)` adds at most 1 listener for each event.\n// If `stdin` option is an array, the values might be combined with `merge-streams`.\n// That library also listens for `source` end, which adds 1 more listener.\nconst MAX_LISTENERS_INCREMENT = 2;\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAIO,MAAM,kBAAkB,CAAC,YAAY,iBAAiB;IAC5D,MAAM,aAAa,IAAI;IAEvB,KAAK,MAAM,CAAC,UAAU,EAAC,UAAU,EAAE,SAAS,EAAC,CAAC,IAAI,OAAO,OAAO,CAAC,iBAAkB;QAClF,KAAK,MAAM,EAAC,MAAM,EAAC,IAAI,WAAW,MAAM,CAAC,CAAC,EAAC,IAAI,EAAC,GAAK,gKAAe,CAAC,GAAG,CAAC,OAAQ;YAChF,cAAc,YAAY,QAAQ,WAAW;QAC9C;QAEA,KAAK,MAAM,EAAC,MAAM,EAAC,IAAI,WAAW,MAAM,CAAC,CAAC,EAAC,IAAI,EAAC,GAAK,CAAC,gKAAe,CAAC,GAAG,CAAC,OAAQ;YACjF,cAAc;gBACb;gBACA;gBACA;gBACA;gBACA;gBACA;YACD;QACD;IACD;IAEA,KAAK,MAAM,CAAC,cAAc,aAAa,IAAI,WAAW,OAAO,GAAI;QAChE,MAAM,cAAc,aAAa,MAAM,KAAK,IAAI,YAAY,CAAC,EAAE,GAAG,IAAA,sKAAY,EAAC;QAC/E,IAAA,6JAAW,EAAC,aAAa;IAC1B;AACD;AAEA,oFAAoF;AACpF,MAAM,gBAAgB,CAAC,YAAY,QAAQ,WAAW;IACrD,IAAI,cAAc,UAAU;QAC3B,IAAA,6JAAW,EAAC,WAAW,KAAK,CAAC,SAAS,EAAE;IACzC,OAAO;QACN,IAAA,6JAAW,EAAC,QAAQ,WAAW,KAAK,CAAC,SAAS;IAC/C;IAEA,MAAM,iBAAiB,4BAA4B,CAAC,SAAS;IAC7D,IAAI,mBAAmB,WAAW;QACjC,UAAU,CAAC,eAAe,GAAG;IAC9B;IAEA,WAAW,KAAK,CAAC,SAAS,GAAG;AAC9B;AAEA,MAAM,+BAA+B;IAAC;IAAS;IAAU;CAAS;AAElE,0EAA0E;AAC1E,iEAAiE;AACjE,MAAM,gBAAgB,CAAC,EAAC,UAAU,EAAE,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,UAAU,EAAE,UAAU,EAAC;IACvF,IAAI,WAAW,WAAW;QACzB;IACD;IAEA,8BAA8B,QAAQ;IAEtC,MAAM,CAAC,aAAa,aAAa,GAAG,cAAc,WAC/C;QAAC;QAAQ,WAAW,KAAK,CAAC,SAAS;KAAC,GACpC;QAAC,WAAW,KAAK,CAAC,SAAS;QAAE;KAAO;IACvC,MAAM,gBAAgB,WAAW,GAAG,CAAC,gBAAgB,EAAE;IACvD,WAAW,GAAG,CAAC,aAAa;WAAI;QAAe;KAAa;AAC7D;AAEA,iFAAiF;AACjF,kFAAkF;AAClF,MAAM,gCAAgC,CAAC,QAAQ,EAAC,MAAM,EAAC;IACtD,IAAI,IAAA,+KAAgB,EAAC,SAAS;QAC7B,IAAA,kLAAqB,EAAC,QAAQ,yBAAyB;IACxD;AACD;AAEA,qEAAqE;AACrE,oFAAoF;AACpF,0EAA0E;AAC1E,MAAM,0BAA0B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5287, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/terminate/cleanup.js"],"sourcesContent":["import {addAbortListener} from 'node:events';\nimport {onExit} from 'signal-exit';\n\n// If the `cleanup` option is used, call `subprocess.kill()` when the parent process exits\nexport const cleanupOnExit = (subprocess, {cleanup, detached}, {signal}) => {\n\tif (!cleanup || detached) {\n\t\treturn;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tsubprocess.kill();\n\t});\n\taddAbortListener(signal, () => {\n\t\tremoveExitHandler();\n\t});\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAGO,MAAM,gBAAgB,CAAC,YAAY,EAAC,OAAO,EAAE,QAAQ,EAAC,EAAE,EAAC,MAAM,EAAC;IACtE,IAAI,CAAC,WAAW,UAAU;QACzB;IACD;IAEA,MAAM,oBAAoB,IAAA,gLAAM,EAAC;QAChC,WAAW,IAAI;IAChB;IACA,IAAA,yIAAgB,EAAC,QAAQ;QACxB;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5310, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/pipe/pipe-arguments.js"],"sourcesContent":["import {normalizeParameters} from '../methods/parameters.js';\nimport {getStartTime} from '../return/duration.js';\nimport {SUBPROCESS_OPTIONS, getToStream, getFromStream} from '../arguments/fd-options.js';\nimport {isDenoExecPath} from '../arguments/file-url.js';\n\n// Normalize and validate arguments passed to `source.pipe(destination)`\nexport const normalizePipeArguments = ({source, sourcePromise, boundOptions, createNested}, ...pipeArguments) => {\n\tconst startTime = getStartTime();\n\tconst {\n\t\tdestination,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tfrom,\n\t\tunpipeSignal,\n\t} = getDestinationStream(boundOptions, createNested, pipeArguments);\n\tconst {sourceStream, sourceError} = getSourceStream(source, from);\n\tconst {options: sourceOptions, fileDescriptors} = SUBPROCESS_OPTIONS.get(source);\n\treturn {\n\t\tsourcePromise,\n\t\tsourceStream,\n\t\tsourceOptions,\n\t\tsourceError,\n\t\tdestination,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tunpipeSignal,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t};\n};\n\nconst getDestinationStream = (boundOptions, createNested, pipeArguments) => {\n\ttry {\n\t\tconst {\n\t\t\tdestination,\n\t\t\tpipeOptions: {from, to, unpipeSignal} = {},\n\t\t} = getDestination(boundOptions, createNested, ...pipeArguments);\n\t\tconst destinationStream = getToStream(destination, to);\n\t\treturn {\n\t\t\tdestination,\n\t\t\tdestinationStream,\n\t\t\tfrom,\n\t\t\tunpipeSignal,\n\t\t};\n\t} catch (error) {\n\t\treturn {destinationError: error};\n\t}\n};\n\n// Piping subprocesses can use three syntaxes:\n//  - source.pipe('command', commandArguments, pipeOptionsOrDestinationOptions)\n//  - source.pipe`command commandArgument` or source.pipe(pipeOptionsOrDestinationOptions)`command commandArgument`\n//  - source.pipe(execa(...), pipeOptions)\nconst getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {\n\tif (Array.isArray(firstArgument)) {\n\t\tconst destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);\n\t\treturn {destination, pipeOptions: boundOptions};\n\t}\n\n\tif (typeof firstArgument === 'string' || firstArgument instanceof URL || isDenoExecPath(firstArgument)) {\n\t\tif (Object.keys(boundOptions).length > 0) {\n\t\t\tthrow new TypeError('Please use .pipe(\"file\", ..., options) or .pipe(execa(\"file\", ..., options)) instead of .pipe(options)(\"file\", ...).');\n\t\t}\n\n\t\tconst [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);\n\t\tconst destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);\n\t\treturn {destination, pipeOptions: rawOptions};\n\t}\n\n\tif (SUBPROCESS_OPTIONS.has(firstArgument)) {\n\t\tif (Object.keys(boundOptions).length > 0) {\n\t\t\tthrow new TypeError('Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).');\n\t\t}\n\n\t\treturn {destination: firstArgument, pipeOptions: pipeArguments[0]};\n\t}\n\n\tthrow new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);\n};\n\n// Force `stdin: 'pipe'` with the destination subprocess\nconst mapDestinationArguments = ({options}) => ({options: {...options, stdin: 'pipe', piped: true}});\n\nconst getSourceStream = (source, from) => {\n\ttry {\n\t\tconst sourceStream = getFromStream(source, from);\n\t\treturn {sourceStream};\n\t} catch (error) {\n\t\treturn {sourceError: error};\n\t}\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAGO,MAAM,yBAAyB,CAAC,EAAC,MAAM,EAAE,aAAa,EAAE,YAAY,EAAE,YAAY,EAAC,EAAE,GAAG;IAC9F,MAAM,YAAY,IAAA,kKAAY;IAC9B,MAAM,EACL,WAAW,EACX,iBAAiB,EACjB,gBAAgB,EAChB,IAAI,EACJ,YAAY,EACZ,GAAG,qBAAqB,cAAc,cAAc;IACrD,MAAM,EAAC,YAAY,EAAE,WAAW,EAAC,GAAG,gBAAgB,QAAQ;IAC5D,MAAM,EAAC,SAAS,aAAa,EAAE,eAAe,EAAC,GAAG,gLAAkB,CAAC,GAAG,CAAC;IACzE,OAAO;QACN;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACD;AACD;AAEA,MAAM,uBAAuB,CAAC,cAAc,cAAc;IACzD,IAAI;QACH,MAAM,EACL,WAAW,EACX,aAAa,EAAC,IAAI,EAAE,EAAE,EAAE,YAAY,EAAC,GAAG,CAAC,CAAC,EAC1C,GAAG,eAAe,cAAc,iBAAiB;QAClD,MAAM,oBAAoB,IAAA,yKAAW,EAAC,aAAa;QACnD,OAAO;YACN;YACA;YACA;YACA;QACD;IACD,EAAE,OAAO,OAAO;QACf,OAAO;YAAC,kBAAkB;QAAK;IAChC;AACD;AAEA,8CAA8C;AAC9C,+EAA+E;AAC/E,mHAAmH;AACnH,0CAA0C;AAC1C,MAAM,iBAAiB,CAAC,cAAc,cAAc,eAAe,GAAG;IACrE,IAAI,MAAM,OAAO,CAAC,gBAAgB;QACjC,MAAM,cAAc,aAAa,yBAAyB,cAAc,kBAAkB;QAC1F,OAAO;YAAC;YAAa,aAAa;QAAY;IAC/C;IAEA,IAAI,OAAO,kBAAkB,YAAY,yBAAyB,OAAO,IAAA,0KAAc,EAAC,gBAAgB;QACvG,IAAI,OAAO,IAAI,CAAC,cAAc,MAAM,GAAG,GAAG;YACzC,MAAM,IAAI,UAAU;QACrB;QAEA,MAAM,CAAC,SAAS,cAAc,WAAW,GAAG,IAAA,4KAAmB,EAAC,kBAAkB;QAClF,MAAM,cAAc,aAAa,yBAAyB,SAAS,cAAc;QACjF,OAAO;YAAC;YAAa,aAAa;QAAU;IAC7C;IAEA,IAAI,gLAAkB,CAAC,GAAG,CAAC,gBAAgB;QAC1C,IAAI,OAAO,IAAI,CAAC,cAAc,MAAM,GAAG,GAAG;YACzC,MAAM,IAAI,UAAU;QACrB;QAEA,OAAO;YAAC,aAAa;YAAe,aAAa,aAAa,CAAC,EAAE;QAAA;IAClE;IAEA,MAAM,IAAI,UAAU,CAAC,yFAAyF,EAAE,eAAe;AAChI;AAEA,wDAAwD;AACxD,MAAM,0BAA0B,CAAC,EAAC,OAAO,EAAC,GAAK,CAAC;QAAC,SAAS;YAAC,GAAG,OAAO;YAAE,OAAO;YAAQ,OAAO;QAAI;IAAC,CAAC;AAEnG,MAAM,kBAAkB,CAAC,QAAQ;IAChC,IAAI;QACH,MAAM,eAAe,IAAA,2KAAa,EAAC,QAAQ;QAC3C,OAAO;YAAC;QAAY;IACrB,EAAE,OAAO,OAAO;QACf,OAAO;YAAC,aAAa;QAAK;IAC3B;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5414, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/pipe/throw.js"],"sourcesContent":["import {makeEarlyError} from '../return/result.js';\nimport {abortSourceStream, endDestinationStream} from '../io/pipeline.js';\n\n// When passing invalid arguments to `source.pipe()`, throw asynchronously.\n// We also abort both subprocesses.\nexport const handlePipeArgumentsError = ({\n\tsourceStream,\n\tsourceError,\n\tdestinationStream,\n\tdestinationError,\n\tfileDescriptors,\n\tsourceOptions,\n\tstartTime,\n}) => {\n\tconst error = getPipeArgumentsError({\n\t\tsourceStream,\n\t\tsourceError,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t});\n\tif (error !== undefined) {\n\t\tthrow createNonCommandError({\n\t\t\terror,\n\t\t\tfileDescriptors,\n\t\t\tsourceOptions,\n\t\t\tstartTime,\n\t\t});\n\t}\n};\n\nconst getPipeArgumentsError = ({sourceStream, sourceError, destinationStream, destinationError}) => {\n\tif (sourceError !== undefined && destinationError !== undefined) {\n\t\treturn destinationError;\n\t}\n\n\tif (destinationError !== undefined) {\n\t\tabortSourceStream(sourceStream);\n\t\treturn destinationError;\n\t}\n\n\tif (sourceError !== undefined) {\n\t\tendDestinationStream(destinationStream);\n\t\treturn sourceError;\n\t}\n};\n\n// Specific error return value when passing invalid arguments to `subprocess.pipe()` or when using `unpipeSignal`\nexport const createNonCommandError = ({error, fileDescriptors, sourceOptions, startTime}) => makeEarlyError({\n\terror,\n\tcommand: PIPE_COMMAND_MESSAGE,\n\tescapedCommand: PIPE_COMMAND_MESSAGE,\n\tfileDescriptors,\n\toptions: sourceOptions,\n\tstartTime,\n\tisSync: false,\n});\n\nconst PIPE_COMMAND_MESSAGE = 'source.pipe(destination)';\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAIO,MAAM,2BAA2B,CAAC,EACxC,YAAY,EACZ,WAAW,EACX,iBAAiB,EACjB,gBAAgB,EAChB,eAAe,EACf,aAAa,EACb,SAAS,EACT;IACA,MAAM,QAAQ,sBAAsB;QACnC;QACA;QACA;QACA;IACD;IACA,IAAI,UAAU,WAAW;QACxB,MAAM,sBAAsB;YAC3B;YACA;YACA;YACA;QACD;IACD;AACD;AAEA,MAAM,wBAAwB,CAAC,EAAC,YAAY,EAAE,WAAW,EAAE,iBAAiB,EAAE,gBAAgB,EAAC;IAC9F,IAAI,gBAAgB,aAAa,qBAAqB,WAAW;QAChE,OAAO;IACR;IAEA,IAAI,qBAAqB,WAAW;QACnC,IAAA,mKAAiB,EAAC;QAClB,OAAO;IACR;IAEA,IAAI,gBAAgB,WAAW;QAC9B,IAAA,sKAAoB,EAAC;QACrB,OAAO;IACR;AACD;AAGO,MAAM,wBAAwB,CAAC,EAAC,KAAK,EAAE,eAAe,EAAE,aAAa,EAAE,SAAS,EAAC,GAAK,IAAA,kKAAc,EAAC;QAC3G;QACA,SAAS;QACT,gBAAgB;QAChB;QACA,SAAS;QACT;QACA,QAAQ;IACT;AAEA,MAAM,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5467, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/pipe/sequence.js"],"sourcesContent":["// Like Bash, we await both subprocesses. This is unlike some other shells which only await the destination subprocess.\n// Like Bash with the `pipefail` option, if either subprocess fails, the whole pipe fails.\n// Like Bash, if both subprocesses fail, we return the failure of the destination.\n// This ensures both subprocesses' errors are present, using `error.pipedFrom`.\nexport const waitForBothSubprocesses = async subprocessPromises => {\n\tconst [\n\t\t{status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason},\n\t\t{status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason},\n\t] = await subprocessPromises;\n\n\tif (!destinationResult.pipedFrom.includes(sourceResult)) {\n\t\tdestinationResult.pipedFrom.push(sourceResult);\n\t}\n\n\tif (destinationStatus === 'rejected') {\n\t\tthrow destinationResult;\n\t}\n\n\tif (sourceStatus === 'rejected') {\n\t\tthrow sourceResult;\n\t}\n\n\treturn destinationResult;\n};\n"],"names":[],"mappings":"AAAA,uHAAuH;AACvH,0FAA0F;AAC1F,kFAAkF;AAClF,+EAA+E;;;;;AACxE,MAAM,0BAA0B,OAAM;IAC5C,MAAM,CACL,EAAC,QAAQ,YAAY,EAAE,QAAQ,YAAY,EAAE,OAAO,eAAe,YAAY,EAAC,EAChF,EAAC,QAAQ,iBAAiB,EAAE,QAAQ,iBAAiB,EAAE,OAAO,oBAAoB,iBAAiB,EAAC,CACpG,GAAG,MAAM;IAEV,IAAI,CAAC,kBAAkB,SAAS,CAAC,QAAQ,CAAC,eAAe;QACxD,kBAAkB,SAAS,CAAC,IAAI,CAAC;IAClC;IAEA,IAAI,sBAAsB,YAAY;QACrC,MAAM;IACP;IAEA,IAAI,iBAAiB,YAAY;QAChC,MAAM;IACP;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5492, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/pipe/streaming.js"],"sourcesContent":["import {finished} from 'node:stream/promises';\nimport mergeStreams from '@sindresorhus/merge-streams';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {pipeStreams} from '../io/pipeline.js';\n\n// The piping behavior is like Bash.\n// In particular, when one subprocess exits, the other is not terminated by a signal.\n// Instead, its stdout (for the source) or stdin (for the destination) closes.\n// If the subprocess uses it, it will make it error with SIGPIPE or EPIPE (for the source) or end (for the destination).\n// If it does not use it, it will continue running.\n// This allows for subprocesses to gracefully exit and lower the coupling between subprocesses.\nexport const pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {\n\tconst mergedStream = MERGED_STREAMS.has(destinationStream)\n\t\t? pipeMoreSubprocessStream(sourceStream, destinationStream)\n\t\t: pipeFirstSubprocessStream(sourceStream, destinationStream);\n\tincrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);\n\tincrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);\n\tcleanupMergedStreamsMap(destinationStream);\n\treturn mergedStream;\n};\n\n// We use `merge-streams` to allow for multiple sources to pipe to the same destination.\nconst pipeFirstSubprocessStream = (sourceStream, destinationStream) => {\n\tconst mergedStream = mergeStreams([sourceStream]);\n\tpipeStreams(mergedStream, destinationStream);\n\tMERGED_STREAMS.set(destinationStream, mergedStream);\n\treturn mergedStream;\n};\n\nconst pipeMoreSubprocessStream = (sourceStream, destinationStream) => {\n\tconst mergedStream = MERGED_STREAMS.get(destinationStream);\n\tmergedStream.add(sourceStream);\n\treturn mergedStream;\n};\n\nconst cleanupMergedStreamsMap = async destinationStream => {\n\ttry {\n\t\tawait finished(destinationStream, {cleanup: true, readable: false, writable: true});\n\t} catch {}\n\n\tMERGED_STREAMS.delete(destinationStream);\n};\n\nconst MERGED_STREAMS = new WeakMap();\n\n// Number of listeners set up on `sourceStream` by each `sourceStream.pipe(destinationStream)`\n// Those are added by `merge-streams`\nconst SOURCE_LISTENERS_PER_PIPE = 2;\n// Number of listeners set up on `destinationStream` by each `sourceStream.pipe(destinationStream)`\n// Those are added by `finished()` in `cleanupMergedStreamsMap()`\nconst DESTINATION_LISTENERS_PER_PIPE = 1;\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAQO,MAAM,uBAAuB,CAAC,cAAc,mBAAmB;IACrE,MAAM,eAAe,eAAe,GAAG,CAAC,qBACrC,yBAAyB,cAAc,qBACvC,0BAA0B,cAAc;IAC3C,IAAA,kLAAqB,EAAC,cAAc,2BAA2B,uBAAuB,MAAM;IAC5F,IAAA,kLAAqB,EAAC,mBAAmB,gCAAgC,uBAAuB,MAAM;IACtG,wBAAwB;IACxB,OAAO;AACR;AAEA,wFAAwF;AACxF,MAAM,4BAA4B,CAAC,cAAc;IAChD,MAAM,eAAe,IAAA,sKAAY,EAAC;QAAC;KAAa;IAChD,IAAA,6JAAW,EAAC,cAAc;IAC1B,eAAe,GAAG,CAAC,mBAAmB;IACtC,OAAO;AACR;AAEA,MAAM,2BAA2B,CAAC,cAAc;IAC/C,MAAM,eAAe,eAAe,GAAG,CAAC;IACxC,aAAa,GAAG,CAAC;IACjB,OAAO;AACR;AAEA,MAAM,0BAA0B,OAAM;IACrC,IAAI;QACH,MAAM,IAAA,yJAAQ,EAAC,mBAAmB;YAAC,SAAS;YAAM,UAAU;YAAO,UAAU;QAAI;IAClF,EAAE,OAAM,CAAC;IAET,eAAe,MAAM,CAAC;AACvB;AAEA,MAAM,iBAAiB,IAAI;AAE3B,8FAA8F;AAC9F,qCAAqC;AACrC,MAAM,4BAA4B;AAClC,mGAAmG;AACnG,iEAAiE;AACjE,MAAM,iCAAiC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5546, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/pipe/abort.js"],"sourcesContent":["import {aborted} from 'node:util';\nimport {createNonCommandError} from './throw.js';\n\n// When passing an `unpipeSignal` option, abort piping when the signal is aborted.\n// However, do not terminate the subprocesses.\nexport const unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === undefined\n\t? []\n\t: [unpipeOnSignalAbort(unpipeSignal, unpipeContext)];\n\nconst unpipeOnSignalAbort = async (unpipeSignal, {sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime}) => {\n\tawait aborted(unpipeSignal, sourceStream);\n\tawait mergedStream.remove(sourceStream);\n\tconst error = new Error('Pipe canceled by `unpipeSignal` option.');\n\tthrow createNonCommandError({\n\t\terror,\n\t\tfileDescriptors,\n\t\tsourceOptions,\n\t\tstartTime,\n\t});\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAIO,MAAM,gBAAgB,CAAC,cAAc,gBAAkB,iBAAiB,YAC5E,EAAE,GACF;QAAC,oBAAoB,cAAc;KAAe;AAErD,MAAM,sBAAsB,OAAO,cAAc,EAAC,YAAY,EAAE,YAAY,EAAE,eAAe,EAAE,aAAa,EAAE,SAAS,EAAC;IACvH,MAAM,IAAA,4HAAO,EAAC,cAAc;IAC5B,MAAM,aAAa,MAAM,CAAC;IAC1B,MAAM,QAAQ,IAAI,MAAM;IACxB,MAAM,IAAA,sKAAqB,EAAC;QAC3B;QACA;QACA;QACA;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5572, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/pipe/setup.js"],"sourcesContent":["import isPlainObject from 'is-plain-obj';\nimport {normalizePipeArguments} from './pipe-arguments.js';\nimport {handlePipeArgumentsError} from './throw.js';\nimport {waitForBothSubprocesses} from './sequence.js';\nimport {pipeSubprocessStream} from './streaming.js';\nimport {unpipeOnAbort} from './abort.js';\n\n// Pipe a subprocess' `stdout`/`stderr`/`stdio` into another subprocess' `stdin`\nexport const pipeToSubprocess = (sourceInfo, ...pipeArguments) => {\n\tif (isPlainObject(pipeArguments[0])) {\n\t\treturn pipeToSubprocess.bind(undefined, {\n\t\t\t...sourceInfo,\n\t\t\tboundOptions: {...sourceInfo.boundOptions, ...pipeArguments[0]},\n\t\t});\n\t}\n\n\tconst {destination, ...normalizedInfo} = normalizePipeArguments(sourceInfo, ...pipeArguments);\n\tconst promise = handlePipePromise({...normalizedInfo, destination});\n\tpromise.pipe = pipeToSubprocess.bind(undefined, {\n\t\t...sourceInfo,\n\t\tsource: destination,\n\t\tsourcePromise: promise,\n\t\tboundOptions: {},\n\t});\n\treturn promise;\n};\n\n// Asynchronous logic when piping subprocesses\nconst handlePipePromise = async ({\n\tsourcePromise,\n\tsourceStream,\n\tsourceOptions,\n\tsourceError,\n\tdestination,\n\tdestinationStream,\n\tdestinationError,\n\tunpipeSignal,\n\tfileDescriptors,\n\tstartTime,\n}) => {\n\tconst subprocessPromises = getSubprocessPromises(sourcePromise, destination);\n\thandlePipeArgumentsError({\n\t\tsourceStream,\n\t\tsourceError,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tfileDescriptors,\n\t\tsourceOptions,\n\t\tstartTime,\n\t});\n\tconst maxListenersController = new AbortController();\n\ttry {\n\t\tconst mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);\n\t\treturn await Promise.race([\n\t\t\twaitForBothSubprocesses(subprocessPromises),\n\t\t\t...unpipeOnAbort(unpipeSignal, {\n\t\t\t\tsourceStream,\n\t\t\t\tmergedStream,\n\t\t\t\tsourceOptions,\n\t\t\t\tfileDescriptors,\n\t\t\t\tstartTime,\n\t\t\t}),\n\t\t]);\n\t} finally {\n\t\tmaxListenersController.abort();\n\t}\n};\n\n// `.pipe()` awaits the subprocess promises.\n// When invalid arguments are passed to `.pipe()`, we throw an error, which prevents awaiting them.\n// We need to ensure this does not create unhandled rejections.\nconst getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAGO,MAAM,mBAAmB,CAAC,YAAY,GAAG;IAC/C,IAAI,IAAA,sJAAa,EAAC,aAAa,CAAC,EAAE,GAAG;QACpC,OAAO,iBAAiB,IAAI,CAAC,WAAW;YACvC,GAAG,UAAU;YACb,cAAc;gBAAC,GAAG,WAAW,YAAY;gBAAE,GAAG,aAAa,CAAC,EAAE;YAAA;QAC/D;IACD;IAEA,MAAM,EAAC,WAAW,EAAE,GAAG,gBAAe,GAAG,IAAA,mLAAsB,EAAC,eAAe;IAC/E,MAAM,UAAU,kBAAkB;QAAC,GAAG,cAAc;QAAE;IAAW;IACjE,QAAQ,IAAI,GAAG,iBAAiB,IAAI,CAAC,WAAW;QAC/C,GAAG,UAAU;QACb,QAAQ;QACR,eAAe;QACf,cAAc,CAAC;IAChB;IACA,OAAO;AACR;AAEA,8CAA8C;AAC9C,MAAM,oBAAoB,OAAO,EAChC,aAAa,EACb,YAAY,EACZ,aAAa,EACb,WAAW,EACX,WAAW,EACX,iBAAiB,EACjB,gBAAgB,EAChB,YAAY,EACZ,eAAe,EACf,SAAS,EACT;IACA,MAAM,qBAAqB,sBAAsB,eAAe;IAChE,IAAA,yKAAwB,EAAC;QACxB;QACA;QACA;QACA;QACA;QACA;QACA;IACD;IACA,MAAM,yBAAyB,IAAI;IACnC,IAAI;QACH,MAAM,eAAe,IAAA,yKAAoB,EAAC,cAAc,mBAAmB;QAC3E,OAAO,MAAM,QAAQ,IAAI,CAAC;YACzB,IAAA,2KAAuB,EAAC;eACrB,IAAA,8JAAa,EAAC,cAAc;gBAC9B;gBACA;gBACA;gBACA;gBACA;YACD;SACA;IACF,SAAU;QACT,uBAAuB,KAAK;IAC7B;AACD;AAEA,4CAA4C;AAC5C,mGAAmG;AACnG,+DAA+D;AAC/D,MAAM,wBAAwB,CAAC,eAAe,cAAgB,QAAQ,UAAU,CAAC;QAAC;QAAe;KAAY","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5651, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/io/iterate.js"],"sourcesContent":["import {on} from 'node:events';\nimport {getDefaultHighWaterMark} from 'node:stream';\nimport {getEncodingTransformGenerator} from '../transform/encoding-transform.js';\nimport {getSplitLinesGenerator} from '../transform/split.js';\nimport {transformChunkSync, finalChunksSync} from '../transform/run-sync.js';\n\n// Iterate over lines of `subprocess.stdout`, used by `subprocess.readable|duplex|iterable()`\nexport const iterateOnSubprocessStream = ({subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines}) => {\n\tconst controller = new AbortController();\n\tstopReadingOnExit(subprocess, controller);\n\treturn iterateOnStream({\n\t\tstream: subprocessStdout,\n\t\tcontroller,\n\t\tbinary,\n\t\tshouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,\n\t\tencoding,\n\t\tshouldSplit: !subprocessStdout.readableObjectMode,\n\t\tpreserveNewlines,\n\t});\n};\n\nconst stopReadingOnExit = async (subprocess, controller) => {\n\ttry {\n\t\tawait subprocess;\n\t} catch {} finally {\n\t\tcontroller.abort();\n\t}\n};\n\n// Iterate over lines of `subprocess.stdout`, used by `result.stdout` and the `verbose: 'full'` option.\n// Applies the `lines` and `encoding` options.\nexport const iterateForResult = ({stream, onStreamEnd, lines, encoding, stripFinalNewline, allMixed}) => {\n\tconst controller = new AbortController();\n\tstopReadingOnStreamEnd(onStreamEnd, controller, stream);\n\tconst objectMode = stream.readableObjectMode && !allMixed;\n\treturn iterateOnStream({\n\t\tstream,\n\t\tcontroller,\n\t\tbinary: encoding === 'buffer',\n\t\tshouldEncode: !objectMode,\n\t\tencoding,\n\t\tshouldSplit: !objectMode && lines,\n\t\tpreserveNewlines: !stripFinalNewline,\n\t});\n};\n\nconst stopReadingOnStreamEnd = async (onStreamEnd, controller, stream) => {\n\ttry {\n\t\tawait onStreamEnd;\n\t} catch {\n\t\tstream.destroy();\n\t} finally {\n\t\tcontroller.abort();\n\t}\n};\n\nconst iterateOnStream = ({stream, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) => {\n\tconst onStdoutChunk = on(stream, 'data', {\n\t\tsignal: controller.signal,\n\t\thighWaterMark: HIGH_WATER_MARK,\n\t\t// Backward compatibility with older name for this option\n\t\t// See https://github.com/nodejs/node/pull/52080#discussion_r1525227861\n\t\t// @todo Remove after removing support for Node 21\n\t\thighWatermark: HIGH_WATER_MARK,\n\t});\n\treturn iterateOnData({\n\t\tonStdoutChunk,\n\t\tcontroller,\n\t\tbinary,\n\t\tshouldEncode,\n\t\tencoding,\n\t\tshouldSplit,\n\t\tpreserveNewlines,\n\t});\n};\n\nexport const DEFAULT_OBJECT_HIGH_WATER_MARK = getDefaultHighWaterMark(true);\n\n// The `highWaterMark` of `events.on()` is measured in number of events, not in bytes.\n// Not knowing the average amount of bytes per `data` event, we use the same heuristic as streams in objectMode, since they have the same issue.\n// Therefore, we use the value of `getDefaultHighWaterMark(true)`.\n// Note: this option does not exist on Node 18, but this is ok since the logic works without it. It just consumes more memory.\nconst HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;\n\nconst iterateOnData = async function * ({onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) {\n\tconst generators = getGenerators({\n\t\tbinary,\n\t\tshouldEncode,\n\t\tencoding,\n\t\tshouldSplit,\n\t\tpreserveNewlines,\n\t});\n\n\ttry {\n\t\tfor await (const [chunk] of onStdoutChunk) {\n\t\t\tyield * transformChunkSync(chunk, generators, 0);\n\t\t}\n\t} catch (error) {\n\t\tif (!controller.signal.aborted) {\n\t\t\tthrow error;\n\t\t}\n\t} finally {\n\t\tyield * finalChunksSync(generators);\n\t}\n};\n\nconst getGenerators = ({binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) => [\n\tgetEncodingTransformGenerator(binary, encoding, !shouldEncode),\n\tgetSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {}),\n].filter(Boolean);\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAGO,MAAM,4BAA4B,CAAC,EAAC,gBAAgB,EAAE,UAAU,EAAE,MAAM,EAAE,YAAY,EAAE,QAAQ,EAAE,gBAAgB,EAAC;IACzH,MAAM,aAAa,IAAI;IACvB,kBAAkB,YAAY;IAC9B,OAAO,gBAAgB;QACtB,QAAQ;QACR;QACA;QACA,cAAc,CAAC,iBAAiB,kBAAkB,IAAI;QACtD;QACA,aAAa,CAAC,iBAAiB,kBAAkB;QACjD;IACD;AACD;AAEA,MAAM,oBAAoB,OAAO,YAAY;IAC5C,IAAI;QACH,MAAM;IACP,EAAE,OAAM,CAAC,SAAU;QAClB,WAAW,KAAK;IACjB;AACD;AAIO,MAAM,mBAAmB,CAAC,EAAC,MAAM,EAAE,WAAW,EAAE,KAAK,EAAE,QAAQ,EAAE,iBAAiB,EAAE,QAAQ,EAAC;IACnG,MAAM,aAAa,IAAI;IACvB,uBAAuB,aAAa,YAAY;IAChD,MAAM,aAAa,OAAO,kBAAkB,IAAI,CAAC;IACjD,OAAO,gBAAgB;QACtB;QACA;QACA,QAAQ,aAAa;QACrB,cAAc,CAAC;QACf;QACA,aAAa,CAAC,cAAc;QAC5B,kBAAkB,CAAC;IACpB;AACD;AAEA,MAAM,yBAAyB,OAAO,aAAa,YAAY;IAC9D,IAAI;QACH,MAAM;IACP,EAAE,OAAM;QACP,OAAO,OAAO;IACf,SAAU;QACT,WAAW,KAAK;IACjB;AACD;AAEA,MAAM,kBAAkB,CAAC,EAAC,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,YAAY,EAAE,QAAQ,EAAE,WAAW,EAAE,gBAAgB,EAAC;IAC3G,MAAM,gBAAgB,IAAA,2HAAE,EAAC,QAAQ,QAAQ;QACxC,QAAQ,WAAW,MAAM;QACzB,eAAe;QACf,yDAAyD;QACzD,uEAAuE;QACvE,kDAAkD;QAClD,eAAe;IAChB;IACA,OAAO,cAAc;QACpB;QACA;QACA;QACA;QACA;QACA;QACA;IACD;AACD;AAEO,MAAM,iCAAiC,IAAA,gJAAuB,EAAC;AAEtE,sFAAsF;AACtF,gJAAgJ;AAChJ,kEAAkE;AAClE,8HAA8H;AAC9H,MAAM,kBAAkB;AAExB,MAAM,gBAAgB,gBAAkB,EAAC,aAAa,EAAE,UAAU,EAAE,MAAM,EAAE,YAAY,EAAE,QAAQ,EAAE,WAAW,EAAE,gBAAgB,EAAC;IACjI,MAAM,aAAa,cAAc;QAChC;QACA;QACA;QACA;QACA;IACD;IAEA,IAAI;QACH,WAAW,MAAM,CAAC,MAAM,IAAI,cAAe;YAC1C,OAAQ,IAAA,8KAAkB,EAAC,OAAO,YAAY;QAC/C;IACD,EAAE,OAAO,OAAO;QACf,IAAI,CAAC,WAAW,MAAM,CAAC,OAAO,EAAE;YAC/B,MAAM;QACP;IACD,SAAU;QACT,OAAQ,IAAA,2KAAe,EAAC;IACzB;AACD;AAEA,MAAM,gBAAgB,CAAC,EAAC,MAAM,EAAE,YAAY,EAAE,QAAQ,EAAE,WAAW,EAAE,gBAAgB,EAAC,GAAK;QAC1F,IAAA,mMAA6B,EAAC,QAAQ,UAAU,CAAC;QACjD,IAAA,4KAAsB,EAAC,QAAQ,kBAAkB,CAAC,aAAa,CAAC;KAChE,CAAC,MAAM,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5765, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/io/contents.js"],"sourcesContent":["import {setImmediate} from 'node:timers/promises';\nimport getStream, {getStreamAsArrayBuffer, getStreamAsArray} from 'get-stream';\nimport {isArrayBuffer} from '../utils/uint-array.js';\nimport {shouldLogOutput, logLines} from '../verbose/output.js';\nimport {iterateForResult} from './iterate.js';\nimport {handleMaxBuffer} from './max-buffer.js';\nimport {getStripFinalNewline} from './strip-newline.js';\n\n// Retrieve `result.stdout|stderr|all|stdio[*]`\nexport const getStreamOutput = async ({stream, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo}) => {\n\tconst logPromise = logOutputAsync({\n\t\tstream,\n\t\tonStreamEnd,\n\t\tfdNumber,\n\t\tencoding,\n\t\tallMixed,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\n\tif (!buffer) {\n\t\tawait Promise.all([resumeStream(stream), logPromise]);\n\t\treturn;\n\t}\n\n\tconst stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline, fdNumber);\n\tconst iterable = iterateForResult({\n\t\tstream,\n\t\tonStreamEnd,\n\t\tlines,\n\t\tencoding,\n\t\tstripFinalNewline: stripFinalNewlineValue,\n\t\tallMixed,\n\t});\n\tconst [output] = await Promise.all([\n\t\tgetStreamContents({\n\t\t\tstream,\n\t\t\titerable,\n\t\t\tfdNumber,\n\t\t\tencoding,\n\t\t\tmaxBuffer,\n\t\t\tlines,\n\t\t}),\n\t\tlogPromise,\n\t]);\n\treturn output;\n};\n\nconst logOutputAsync = async ({stream, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: {fileDescriptors}}) => {\n\tif (!shouldLogOutput({\n\t\tstdioItems: fileDescriptors[fdNumber]?.stdioItems,\n\t\tencoding,\n\t\tverboseInfo,\n\t\tfdNumber,\n\t})) {\n\t\treturn;\n\t}\n\n\tconst linesIterable = iterateForResult({\n\t\tstream,\n\t\tonStreamEnd,\n\t\tlines: true,\n\t\tencoding,\n\t\tstripFinalNewline: true,\n\t\tallMixed,\n\t});\n\tawait logLines(linesIterable, stream, fdNumber, verboseInfo);\n};\n\n// When using `buffer: false`, users need to read `subprocess.stdout|stderr|all` right away\n// See https://github.com/sindresorhus/execa/issues/730 and https://github.com/sindresorhus/execa/pull/729#discussion_r1465496310\nconst resumeStream = async stream => {\n\tawait setImmediate();\n\tif (stream.readableFlowing === null) {\n\t\tstream.resume();\n\t}\n};\n\nconst getStreamContents = async ({stream, stream: {readableObjectMode}, iterable, fdNumber, encoding, maxBuffer, lines}) => {\n\ttry {\n\t\tif (readableObjectMode || lines) {\n\t\t\treturn await getStreamAsArray(iterable, {maxBuffer});\n\t\t}\n\n\t\tif (encoding === 'buffer') {\n\t\t\treturn new Uint8Array(await getStreamAsArrayBuffer(iterable, {maxBuffer}));\n\t\t}\n\n\t\treturn await getStream(iterable, {maxBuffer});\n\t} catch (error) {\n\t\treturn handleBufferedData(handleMaxBuffer({\n\t\t\terror,\n\t\t\tstream,\n\t\t\treadableObjectMode,\n\t\t\tlines,\n\t\t\tencoding,\n\t\t\tfdNumber,\n\t\t}));\n\t}\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\n// They are automatically closed and flushed by Node.js when the subprocess exits\n// When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve\nexport const getBufferedData = async streamPromise => {\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn handleBufferedData(error);\n\t}\n};\n\n// Ensure we are returning Uint8Arrays when using `encoding: 'buffer'`\nconst handleBufferedData = ({bufferedData}) => isArrayBuffer(bufferedData)\n\t? new Uint8Array(bufferedData)\n\t: bufferedData;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAGO,MAAM,kBAAkB,OAAO,EAAC,MAAM,EAAE,WAAW,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,QAAQ,EAAE,iBAAiB,EAAE,WAAW,EAAE,UAAU,EAAC;IAC9J,MAAM,aAAa,eAAe;QACjC;QACA;QACA;QACA;QACA;QACA;QACA;IACD;IAEA,IAAI,CAAC,QAAQ;QACZ,MAAM,QAAQ,GAAG,CAAC;YAAC,aAAa;YAAS;SAAW;QACpD;IACD;IAEA,MAAM,yBAAyB,IAAA,8KAAoB,EAAC,mBAAmB;IACvE,MAAM,WAAW,IAAA,iKAAgB,EAAC;QACjC;QACA;QACA;QACA;QACA,mBAAmB;QACnB;IACD;IACA,MAAM,CAAC,OAAO,GAAG,MAAM,QAAQ,GAAG,CAAC;QAClC,kBAAkB;YACjB;YACA;YACA;YACA;YACA;YACA;QACD;QACA;KACA;IACD,OAAO;AACR;AAEA,MAAM,iBAAiB,OAAO,EAAC,MAAM,EAAE,WAAW,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,WAAW,EAAE,YAAY,EAAC,eAAe,EAAC,EAAC;IAC5H,IAAI,CAAC,IAAA,oKAAe,EAAC;QACpB,YAAY,eAAe,CAAC,SAAS,EAAE;QACvC;QACA;QACA;IACD,IAAI;QACH;IACD;IAEA,MAAM,gBAAgB,IAAA,iKAAgB,EAAC;QACtC;QACA;QACA,OAAO;QACP;QACA,mBAAmB;QACnB;IACD;IACA,MAAM,IAAA,6JAAQ,EAAC,eAAe,QAAQ,UAAU;AACjD;AAEA,2FAA2F;AAC3F,iIAAiI;AACjI,MAAM,eAAe,OAAM;IAC1B,MAAM,IAAA,6JAAY;IAClB,IAAI,OAAO,eAAe,KAAK,MAAM;QACpC,OAAO,MAAM;IACd;AACD;AAEA,MAAM,oBAAoB,OAAO,EAAC,MAAM,EAAE,QAAQ,EAAC,kBAAkB,EAAC,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,KAAK,EAAC;IACtH,IAAI;QACH,IAAI,sBAAsB,OAAO;YAChC,OAAO,MAAM,IAAA,oKAAgB,EAAC,UAAU;gBAAC;YAAS;QACnD;QAEA,IAAI,aAAa,UAAU;YAC1B,OAAO,IAAI,WAAW,MAAM,IAAA,oLAAsB,EAAC,UAAU;gBAAC;YAAS;QACxE;QAEA,OAAO,MAAM,IAAA,4MAAS,EAAC,UAAU;YAAC;QAAS;IAC5C,EAAE,OAAO,OAAO;QACf,OAAO,mBAAmB,IAAA,sKAAe,EAAC;YACzC;YACA;YACA;YACA;YACA;YACA;QACD;IACD;AACD;AAKO,MAAM,kBAAkB,OAAM;IACpC,IAAI;QACH,OAAO,MAAM;IACd,EAAE,OAAO,OAAO;QACf,OAAO,mBAAmB;IAC3B;AACD;AAEA,sEAAsE;AACtE,MAAM,qBAAqB,CAAC,EAAC,YAAY,EAAC,GAAK,IAAA,uKAAa,EAAC,gBAC1D,IAAI,WAAW,gBACf","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5892, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/resolve/wait-stream.js"],"sourcesContent":["import {finished} from 'node:stream/promises';\n\n// Wraps `finished(stream)` to handle the following case:\n//  - When the subprocess exits, Node.js automatically calls `subprocess.stdin.destroy()`, which we need to ignore.\n//  - However, we still need to throw if `subprocess.stdin.destroy()` is called before subprocess exit.\nexport const waitForStream = async (stream, fdNumber, streamInfo, {isSameDirection, stopOnExit = false} = {}) => {\n\tconst state = handleStdinDestroy(stream, streamInfo);\n\tconst abortController = new AbortController();\n\ttry {\n\t\tawait Promise.race([\n\t\t\t...(stopOnExit ? [streamInfo.exitPromise] : []),\n\t\t\tfinished(stream, {cleanup: true, signal: abortController.signal}),\n\t\t]);\n\t} catch (error) {\n\t\tif (!state.stdinCleanedUp) {\n\t\t\thandleStreamError(error, fdNumber, streamInfo, isSameDirection);\n\t\t}\n\t} finally {\n\t\tabortController.abort();\n\t}\n};\n\n// If `subprocess.stdin` is destroyed before being fully written to, it is considered aborted and should throw an error.\n// This can happen for example when user called `subprocess.stdin.destroy()` before `subprocess.stdin.end()`.\n// However, Node.js calls `subprocess.stdin.destroy()` on exit for cleanup purposes.\n// https://github.com/nodejs/node/blob/0b4cdb4b42956cbd7019058e409e06700a199e11/lib/internal/child_process.js#L278\n// This is normal and should not throw an error.\n// Therefore, we need to differentiate between both situations to know whether to throw an error.\n// Unfortunately, events (`close`, `error`, `end`, `exit`) cannot be used because `.destroy()` can take an arbitrary amount of time.\n// For example, `stdin: 'pipe'` is implemented as a TCP socket, and its `.destroy()` method waits for TCP disconnection.\n// Therefore `.destroy()` might end before or after subprocess exit, based on OS speed and load.\n// The only way to detect this is to spy on `subprocess.stdin._destroy()` by wrapping it.\n// If `subprocess.exitCode` or `subprocess.signalCode` is set, it means `.destroy()` is being called by Node.js itself.\nconst handleStdinDestroy = (stream, {originalStreams: [originalStdin], subprocess}) => {\n\tconst state = {stdinCleanedUp: false};\n\tif (stream === originalStdin) {\n\t\tspyOnStdinDestroy(stream, subprocess, state);\n\t}\n\n\treturn state;\n};\n\nconst spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {\n\tconst {_destroy} = subprocessStdin;\n\tsubprocessStdin._destroy = (...destroyArguments) => {\n\t\tsetStdinCleanedUp(subprocess, state);\n\t\t_destroy.call(subprocessStdin, ...destroyArguments);\n\t};\n};\n\nconst setStdinCleanedUp = ({exitCode, signalCode}, state) => {\n\tif (exitCode !== null || signalCode !== null) {\n\t\tstate.stdinCleanedUp = true;\n\t}\n};\n\n// We ignore EPIPEs on writable streams and aborts on readable streams since those can happen normally.\n// When one stream errors, the error is propagated to the other streams on the same file descriptor.\n// Those other streams might have a different direction due to the above.\n// When this happens, the direction of both the initial stream and the others should then be taken into account.\n// Therefore, we keep track of whether a stream error is currently propagating.\nconst handleStreamError = (error, fdNumber, streamInfo, isSameDirection) => {\n\tif (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) {\n\t\tthrow error;\n\t}\n};\n\nconst shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true) => {\n\tif (streamInfo.propagating) {\n\t\treturn isStreamEpipe(error) || isStreamAbort(error);\n\t}\n\n\tstreamInfo.propagating = true;\n\treturn isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection\n\t\t? isStreamEpipe(error)\n\t\t: isStreamAbort(error);\n};\n\n// Unfortunately, we cannot use the stream's class or properties to know whether it is readable or writable.\n// For example, `subprocess.stdin` is technically a Duplex, but can only be used as a writable.\n// Therefore, we need to use the file descriptor's direction (`stdin` is input, `stdout` is output, etc.).\n// However, while `subprocess.std*` and transforms follow that direction, any stream passed the `std*` option has the opposite direction.\n// For example, `subprocess.stdin` is a writable, but the `stdin` option is a readable.\nexport const isInputFileDescriptor = ({fileDescriptors}, fdNumber) => fdNumber !== 'all' && fileDescriptors[fdNumber].direction === 'input';\n\n// When `stream.destroy()` is called without an `error` argument, stream is aborted.\n// This is the only way to abort a readable stream, which can be useful in some instances.\n// Therefore, we ignore this error on readable streams.\nexport const isStreamAbort = error => error?.code === 'ERR_STREAM_PREMATURE_CLOSE';\n\n// When `stream.write()` is called but the underlying source has been closed, `EPIPE` is emitted.\n// When piping subprocesses, the source subprocess usually decides when to stop piping.\n// However, there are some instances when the destination does instead, such as `... | head -n1`.\n// It notifies the source by using `EPIPE`.\n// Therefore, we ignore this error on writable streams.\nconst isStreamEpipe = error => error?.code === 'EPIPE';\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAKO,MAAM,gBAAgB,OAAO,QAAQ,UAAU,YAAY,EAAC,eAAe,EAAE,aAAa,KAAK,EAAC,GAAG,CAAC,CAAC;IAC3G,MAAM,QAAQ,mBAAmB,QAAQ;IACzC,MAAM,kBAAkB,IAAI;IAC5B,IAAI;QACH,MAAM,QAAQ,IAAI,CAAC;eACd,aAAa;gBAAC,WAAW,WAAW;aAAC,GAAG,EAAE;YAC9C,IAAA,yJAAQ,EAAC,QAAQ;gBAAC,SAAS;gBAAM,QAAQ,gBAAgB,MAAM;YAAA;SAC/D;IACF,EAAE,OAAO,OAAO;QACf,IAAI,CAAC,MAAM,cAAc,EAAE;YAC1B,kBAAkB,OAAO,UAAU,YAAY;QAChD;IACD,SAAU;QACT,gBAAgB,KAAK;IACtB;AACD;AAEA,wHAAwH;AACxH,6GAA6G;AAC7G,oFAAoF;AACpF,kHAAkH;AAClH,gDAAgD;AAChD,iGAAiG;AACjG,oIAAoI;AACpI,wHAAwH;AACxH,gGAAgG;AAChG,yFAAyF;AACzF,uHAAuH;AACvH,MAAM,qBAAqB,CAAC,QAAQ,EAAC,iBAAiB,CAAC,cAAc,EAAE,UAAU,EAAC;IACjF,MAAM,QAAQ;QAAC,gBAAgB;IAAK;IACpC,IAAI,WAAW,eAAe;QAC7B,kBAAkB,QAAQ,YAAY;IACvC;IAEA,OAAO;AACR;AAEA,MAAM,oBAAoB,CAAC,iBAAiB,YAAY;IACvD,MAAM,EAAC,QAAQ,EAAC,GAAG;IACnB,gBAAgB,QAAQ,GAAG,CAAC,GAAG;QAC9B,kBAAkB,YAAY;QAC9B,SAAS,IAAI,CAAC,oBAAoB;IACnC;AACD;AAEA,MAAM,oBAAoB,CAAC,EAAC,QAAQ,EAAE,UAAU,EAAC,EAAE;IAClD,IAAI,aAAa,QAAQ,eAAe,MAAM;QAC7C,MAAM,cAAc,GAAG;IACxB;AACD;AAEA,uGAAuG;AACvG,oGAAoG;AACpG,yEAAyE;AACzE,gHAAgH;AAChH,+EAA+E;AAC/E,MAAM,oBAAoB,CAAC,OAAO,UAAU,YAAY;IACvD,IAAI,CAAC,wBAAwB,OAAO,UAAU,YAAY,kBAAkB;QAC3E,MAAM;IACP;AACD;AAEA,MAAM,0BAA0B,CAAC,OAAO,UAAU,YAAY,kBAAkB,IAAI;IACnF,IAAI,WAAW,WAAW,EAAE;QAC3B,OAAO,cAAc,UAAU,cAAc;IAC9C;IAEA,WAAW,WAAW,GAAG;IACzB,OAAO,sBAAsB,YAAY,cAAc,kBACpD,cAAc,SACd,cAAc;AAClB;AAOO,MAAM,wBAAwB,CAAC,EAAC,eAAe,EAAC,EAAE,WAAa,aAAa,SAAS,eAAe,CAAC,SAAS,CAAC,SAAS,KAAK;AAK7H,MAAM,gBAAgB,CAAA,QAAS,OAAO,SAAS;AAEtD,iGAAiG;AACjG,uFAAuF;AACvF,iGAAiG;AACjG,2CAA2C;AAC3C,uDAAuD;AACvD,MAAM,gBAAgB,CAAA,QAAS,OAAO,SAAS","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5984, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/resolve/stdio.js"],"sourcesContent":["import {getStreamOutput} from '../io/contents.js';\nimport {waitForStream, isInputFileDescriptor} from './wait-stream.js';\n\n// Read the contents of `subprocess.std*` and|or wait for its completion\nexport const waitForStdioStreams = ({subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo}) => subprocess.stdio.map((stream, fdNumber) => waitForSubprocessStream({\n\tstream,\n\tfdNumber,\n\tencoding,\n\tbuffer: buffer[fdNumber],\n\tmaxBuffer: maxBuffer[fdNumber],\n\tlines: lines[fdNumber],\n\tallMixed: false,\n\tstripFinalNewline,\n\tverboseInfo,\n\tstreamInfo,\n}));\n\n// Read the contents of `subprocess.std*` or `subprocess.all` and|or wait for its completion\nexport const waitForSubprocessStream = async ({stream, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo}) => {\n\tif (!stream) {\n\t\treturn;\n\t}\n\n\tconst onStreamEnd = waitForStream(stream, fdNumber, streamInfo);\n\tif (isInputFileDescriptor(streamInfo, fdNumber)) {\n\t\tawait onStreamEnd;\n\t\treturn;\n\t}\n\n\tconst [output] = await Promise.all([\n\t\tgetStreamOutput({\n\t\t\tstream,\n\t\t\tonStreamEnd,\n\t\t\tfdNumber,\n\t\t\tencoding,\n\t\t\tbuffer,\n\t\t\tmaxBuffer,\n\t\t\tlines,\n\t\t\tallMixed,\n\t\t\tstripFinalNewline,\n\t\t\tverboseInfo,\n\t\t\tstreamInfo,\n\t\t}),\n\t\tonStreamEnd,\n\t]);\n\treturn output;\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAGO,MAAM,sBAAsB,CAAC,EAAC,UAAU,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,iBAAiB,EAAE,WAAW,EAAE,UAAU,EAAC,GAAK,WAAW,KAAK,CAAC,GAAG,CAAC,CAAC,QAAQ,WAAa,wBAAwB;YACvM;YACA;YACA;YACA,QAAQ,MAAM,CAAC,SAAS;YACxB,WAAW,SAAS,CAAC,SAAS;YAC9B,OAAO,KAAK,CAAC,SAAS;YACtB,UAAU;YACV;YACA;YACA;QACD;AAGO,MAAM,0BAA0B,OAAO,EAAC,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,QAAQ,EAAE,iBAAiB,EAAE,WAAW,EAAE,UAAU,EAAC;IACzJ,IAAI,CAAC,QAAQ;QACZ;IACD;IAEA,MAAM,cAAc,IAAA,0KAAa,EAAC,QAAQ,UAAU;IACpD,IAAI,IAAA,kLAAqB,EAAC,YAAY,WAAW;QAChD,MAAM;QACN;IACD;IAEA,MAAM,CAAC,OAAO,GAAG,MAAM,QAAQ,GAAG,CAAC;QAClC,IAAA,iKAAe,EAAC;YACf;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;QACD;QACA;KACA;IACD,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6037, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/resolve/all-async.js"],"sourcesContent":["import mergeStreams from '@sindresorhus/merge-streams';\nimport {waitForSubprocessStream} from './stdio.js';\n\n// `all` interleaves `stdout` and `stderr`\nexport const makeAllStream = ({stdout, stderr}, {all}) => all && (stdout || stderr)\n\t? mergeStreams([stdout, stderr].filter(Boolean))\n\t: undefined;\n\n// Read the contents of `subprocess.all` and|or wait for its completion\nexport const waitForAllStream = ({subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo}) => waitForSubprocessStream({\n\t...getAllStream(subprocess, buffer),\n\tfdNumber: 'all',\n\tencoding,\n\tmaxBuffer: maxBuffer[1] + maxBuffer[2],\n\tlines: lines[1] || lines[2],\n\tallMixed: getAllMixed(subprocess),\n\tstripFinalNewline,\n\tverboseInfo,\n\tstreamInfo,\n});\n\nconst getAllStream = ({stdout, stderr, all}, [, bufferStdout, bufferStderr]) => {\n\tconst buffer = bufferStdout || bufferStderr;\n\tif (!buffer) {\n\t\treturn {stream: all, buffer};\n\t}\n\n\tif (!bufferStdout) {\n\t\treturn {stream: stderr, buffer};\n\t}\n\n\tif (!bufferStderr) {\n\t\treturn {stream: stdout, buffer};\n\t}\n\n\treturn {stream: all, buffer};\n};\n\n// When `subprocess.stdout` is in objectMode but not `subprocess.stderr` (or the opposite), we need to use both:\n//  - `getStreamAsArray()` for the chunks in objectMode, to return as an array without changing each chunk\n//  - `getStreamAsArrayBuffer()` or `getStream()` for the chunks not in objectMode, to convert them from Buffers to string or Uint8Array\n// We do this by emulating the Buffer -> string|Uint8Array conversion performed by `get-stream` with our own, which is identical.\nconst getAllMixed = ({all, stdout, stderr}) => all\n\t&& stdout\n\t&& stderr\n\t&& stdout.readableObjectMode !== stderr.readableObjectMode;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAGO,MAAM,gBAAgB,CAAC,EAAC,MAAM,EAAE,MAAM,EAAC,EAAE,EAAC,GAAG,EAAC,GAAK,OAAO,CAAC,UAAU,MAAM,IAC/E,IAAA,sKAAY,EAAC;QAAC;QAAQ;KAAO,CAAC,MAAM,CAAC,YACrC;AAGI,MAAM,mBAAmB,CAAC,EAAC,UAAU,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,iBAAiB,EAAE,WAAW,EAAE,UAAU,EAAC,GAAK,IAAA,2KAAuB,EAAC;QACzJ,GAAG,aAAa,YAAY,OAAO;QACnC,UAAU;QACV;QACA,WAAW,SAAS,CAAC,EAAE,GAAG,SAAS,CAAC,EAAE;QACtC,OAAO,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE;QAC3B,UAAU,YAAY;QACtB;QACA;QACA;IACD;AAEA,MAAM,eAAe,CAAC,EAAC,MAAM,EAAE,MAAM,EAAE,GAAG,EAAC,EAAE,GAAG,cAAc,aAAa;IAC1E,MAAM,SAAS,gBAAgB;IAC/B,IAAI,CAAC,QAAQ;QACZ,OAAO;YAAC,QAAQ;YAAK;QAAM;IAC5B;IAEA,IAAI,CAAC,cAAc;QAClB,OAAO;YAAC,QAAQ;YAAQ;QAAM;IAC/B;IAEA,IAAI,CAAC,cAAc;QAClB,OAAO;YAAC,QAAQ;YAAQ;QAAM;IAC/B;IAEA,OAAO;QAAC,QAAQ;QAAK;IAAM;AAC5B;AAEA,gHAAgH;AAChH,0GAA0G;AAC1G,wIAAwI;AACxI,iIAAiI;AACjI,MAAM,cAAc,CAAC,EAAC,GAAG,EAAE,MAAM,EAAE,MAAM,EAAC,GAAK,OAC3C,UACA,UACA,OAAO,kBAAkB,KAAK,OAAO,kBAAkB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6096, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/verbose/ipc.js"],"sourcesContent":["import {verboseLog, serializeVerboseMessage} from './log.js';\nimport {isFullVerbose} from './values.js';\n\n// When `verbose` is `'full'`, print IPC messages from the subprocess\nexport const shouldLogIpc = verboseInfo => isFullVerbose(verboseInfo, 'ipc');\n\nexport const logIpcOutput = (message, verboseInfo) => {\n\tconst verboseMessage = serializeVerboseMessage(message);\n\tverboseLog({\n\t\ttype: 'ipc',\n\t\tverboseMessage,\n\t\tfdNumber: 'ipc',\n\t\tverboseInfo,\n\t});\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAGO,MAAM,eAAe,CAAA,cAAe,IAAA,kKAAa,EAAC,aAAa;AAE/D,MAAM,eAAe,CAAC,SAAS;IACrC,MAAM,iBAAiB,IAAA,yKAAuB,EAAC;IAC/C,IAAA,4JAAU,EAAC;QACV,MAAM;QACN;QACA,UAAU;QACV;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6120, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/ipc/buffer-messages.js"],"sourcesContent":["import {checkIpcMaxBuffer} from '../io/max-buffer.js';\nimport {shouldLogIpc, logIpcOutput} from '../verbose/ipc.js';\nimport {getFdSpecificValue} from '../arguments/specific.js';\nimport {loopOnMessages} from './get-each.js';\n\n// Iterate through IPC messages sent by the subprocess\nexport const waitForIpcOutput = async ({\n\tsubprocess,\n\tbuffer: bufferArray,\n\tmaxBuffer: maxBufferArray,\n\tipc,\n\tipcOutput,\n\tverboseInfo,\n}) => {\n\tif (!ipc) {\n\t\treturn ipcOutput;\n\t}\n\n\tconst isVerbose = shouldLogIpc(verboseInfo);\n\tconst buffer = getFdSpecificValue(bufferArray, 'ipc');\n\tconst maxBuffer = getFdSpecificValue(maxBufferArray, 'ipc');\n\n\tfor await (const message of loopOnMessages({\n\t\tanyProcess: subprocess,\n\t\tchannel: subprocess.channel,\n\t\tisSubprocess: false,\n\t\tipc,\n\t\tshouldAwait: false,\n\t\treference: true,\n\t})) {\n\t\tif (buffer) {\n\t\t\tcheckIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);\n\t\t\tipcOutput.push(message);\n\t\t}\n\n\t\tif (isVerbose) {\n\t\t\tlogIpcOutput(message, verboseInfo);\n\t\t}\n\t}\n\n\treturn ipcOutput;\n};\n\nexport const getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput) => {\n\tawait Promise.allSettled([ipcOutputPromise]);\n\treturn ipcOutput;\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAGO,MAAM,mBAAmB,OAAO,EACtC,UAAU,EACV,QAAQ,WAAW,EACnB,WAAW,cAAc,EACzB,GAAG,EACH,SAAS,EACT,WAAW,EACX;IACA,IAAI,CAAC,KAAK;QACT,OAAO;IACR;IAEA,MAAM,YAAY,IAAA,8JAAY,EAAC;IAC/B,MAAM,SAAS,IAAA,2KAAkB,EAAC,aAAa;IAC/C,MAAM,YAAY,IAAA,2KAAkB,EAAC,gBAAgB;IAErD,WAAW,MAAM,WAAW,IAAA,oKAAc,EAAC;QAC1C,YAAY;QACZ,SAAS,WAAW,OAAO;QAC3B,cAAc;QACd;QACA,aAAa;QACb,WAAW;IACZ,GAAI;QACH,IAAI,QAAQ;YACX,IAAA,wKAAiB,EAAC,YAAY,WAAW;YACzC,UAAU,IAAI,CAAC;QAChB;QAEA,IAAI,WAAW;YACd,IAAA,8JAAY,EAAC,SAAS;QACvB;IACD;IAEA,OAAO;AACR;AAEO,MAAM,uBAAuB,OAAO,kBAAkB;IAC5D,MAAM,QAAQ,UAAU,CAAC;QAAC;KAAiB;IAC3C,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6169, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/resolve/wait-subprocess.js"],"sourcesContent":["import {once} from 'node:events';\nimport {isStream as isNodeStream} from 'is-stream';\nimport {throwOnTimeout} from '../terminate/timeout.js';\nimport {throwOnCancel} from '../terminate/cancel.js';\nimport {throwOnGracefulCancel} from '../terminate/graceful.js';\nimport {isStandardStream} from '../utils/standard-stream.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {getBufferedData} from '../io/contents.js';\nimport {waitForIpcOutput, getBufferedIpcOutput} from '../ipc/buffer-messages.js';\nimport {sendIpcInput} from '../ipc/ipc-input.js';\nimport {waitForAllStream} from './all-async.js';\nimport {waitForStdioStreams} from './stdio.js';\nimport {waitForExit, waitForSuccessfulExit} from './exit-async.js';\nimport {waitForStream} from './wait-stream.js';\n\n// Retrieve result of subprocess: exit code, signal, error, streams (stdout/stderr/all)\nexport const waitForSubprocessResult = async ({\n\tsubprocess,\n\toptions: {\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\ttimeoutDuration: timeout,\n\t\tcancelSignal,\n\t\tgracefulCancel,\n\t\tforceKillAfterDelay,\n\t\tstripFinalNewline,\n\t\tipc,\n\t\tipcInput,\n\t},\n\tcontext,\n\tverboseInfo,\n\tfileDescriptors,\n\toriginalStreams,\n\tonInternalError,\n\tcontroller,\n}) => {\n\tconst exitPromise = waitForExit(subprocess, context);\n\tconst streamInfo = {\n\t\toriginalStreams,\n\t\tfileDescriptors,\n\t\tsubprocess,\n\t\texitPromise,\n\t\tpropagating: false,\n\t};\n\n\tconst stdioPromises = waitForStdioStreams({\n\t\tsubprocess,\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\tconst allPromise = waitForAllStream({\n\t\tsubprocess,\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\tconst ipcOutput = [];\n\tconst ipcOutputPromise = waitForIpcOutput({\n\t\tsubprocess,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tipc,\n\t\tipcOutput,\n\t\tverboseInfo,\n\t});\n\tconst originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);\n\tconst customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);\n\n\ttry {\n\t\treturn await Promise.race([\n\t\t\tPromise.all([\n\t\t\t\t{},\n\t\t\t\twaitForSuccessfulExit(exitPromise),\n\t\t\t\tPromise.all(stdioPromises),\n\t\t\t\tallPromise,\n\t\t\t\tipcOutputPromise,\n\t\t\t\tsendIpcInput(subprocess, ipcInput),\n\t\t\t\t...originalPromises,\n\t\t\t\t...customStreamsEndPromises,\n\t\t\t]),\n\t\t\tonInternalError,\n\t\t\tthrowOnSubprocessError(subprocess, controller),\n\t\t\t...throwOnTimeout(subprocess, timeout, context, controller),\n\t\t\t...throwOnCancel({\n\t\t\t\tsubprocess,\n\t\t\t\tcancelSignal,\n\t\t\t\tgracefulCancel,\n\t\t\t\tcontext,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t\t...throwOnGracefulCancel({\n\t\t\t\tsubprocess,\n\t\t\t\tcancelSignal,\n\t\t\t\tgracefulCancel,\n\t\t\t\tforceKillAfterDelay,\n\t\t\t\tcontext,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t]);\n\t} catch (error) {\n\t\tcontext.terminationReason ??= 'other';\n\t\treturn Promise.all([\n\t\t\t{error},\n\t\t\texitPromise,\n\t\t\tPromise.all(stdioPromises.map(stdioPromise => getBufferedData(stdioPromise))),\n\t\t\tgetBufferedData(allPromise),\n\t\t\tgetBufferedIpcOutput(ipcOutputPromise, ipcOutput),\n\t\t\tPromise.allSettled(originalPromises),\n\t\t\tPromise.allSettled(customStreamsEndPromises),\n\t\t]);\n\t}\n};\n\n// Transforms replace `subprocess.std*`, which means they are not exposed to users.\n// However, we still want to wait for their completion.\nconst waitForOriginalStreams = (originalStreams, subprocess, streamInfo) =>\n\toriginalStreams.map((stream, fdNumber) => stream === subprocess.stdio[fdNumber]\n\t\t? undefined\n\t\t: waitForStream(stream, fdNumber, streamInfo));\n\n// Some `stdin`/`stdout`/`stderr` options create a stream, e.g. when passing a file path.\n// The `.pipe()` method automatically ends that stream when `subprocess` ends.\n// This makes sure we wait for the completion of those streams, in order to catch any error.\nconst waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({stdioItems}, fdNumber) => stdioItems\n\t.filter(({value, stream = value}) => isNodeStream(stream, {checkOpen: false}) && !isStandardStream(stream))\n\t.map(({type, value, stream = value}) => waitForStream(stream, fdNumber, streamInfo, {\n\t\tisSameDirection: TRANSFORM_TYPES.has(type),\n\t\tstopOnExit: type === 'native',\n\t})));\n\n// Fails when the subprocess emits an `error` event\nconst throwOnSubprocessError = async (subprocess, {signal}) => {\n\tconst [error] = await once(subprocess, 'error', {signal});\n\tthrow error;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6310, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/convert/concurrent.js"],"sourcesContent":["import {createDeferred} from '../utils/deferred.js';\n\n// When using multiple `.readable()`/`.writable()`/`.duplex()`, `final` and `destroy` should wait for other streams\nexport const initializeConcurrentStreams = () => ({\n\treadableDestroy: new WeakMap(),\n\twritableFinal: new WeakMap(),\n\twritableDestroy: new WeakMap(),\n});\n\n// Each file descriptor + `waitName` has its own array of promises.\n// Each promise is a single `.readable()`/`.writable()`/`.duplex()` call.\nexport const addConcurrentStream = (concurrentStreams, stream, waitName) => {\n\tconst weakMap = concurrentStreams[waitName];\n\tif (!weakMap.has(stream)) {\n\t\tweakMap.set(stream, []);\n\t}\n\n\tconst promises = weakMap.get(stream);\n\tconst promise = createDeferred();\n\tpromises.push(promise);\n\tconst resolve = promise.resolve.bind(promise);\n\treturn {resolve, promises};\n};\n\n// Wait for other streams, but stop waiting when subprocess ends\nexport const waitForConcurrentStreams = async ({resolve, promises}, subprocess) => {\n\tresolve();\n\tconst [isSubprocessExit] = await Promise.race([\n\t\tPromise.allSettled([true, subprocess]),\n\t\tPromise.all([false, ...promises]),\n\t]);\n\treturn !isSubprocessExit;\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAGO,MAAM,8BAA8B,IAAM,CAAC;QACjD,iBAAiB,IAAI;QACrB,eAAe,IAAI;QACnB,iBAAiB,IAAI;IACtB,CAAC;AAIM,MAAM,sBAAsB,CAAC,mBAAmB,QAAQ;IAC9D,MAAM,UAAU,iBAAiB,CAAC,SAAS;IAC3C,IAAI,CAAC,QAAQ,GAAG,CAAC,SAAS;QACzB,QAAQ,GAAG,CAAC,QAAQ,EAAE;IACvB;IAEA,MAAM,WAAW,QAAQ,GAAG,CAAC;IAC7B,MAAM,UAAU,IAAA,mKAAc;IAC9B,SAAS,IAAI,CAAC;IACd,MAAM,UAAU,QAAQ,OAAO,CAAC,IAAI,CAAC;IACrC,OAAO;QAAC;QAAS;IAAQ;AAC1B;AAGO,MAAM,2BAA2B,OAAO,EAAC,OAAO,EAAE,QAAQ,EAAC,EAAE;IACnE;IACA,MAAM,CAAC,iBAAiB,GAAG,MAAM,QAAQ,IAAI,CAAC;QAC7C,QAAQ,UAAU,CAAC;YAAC;YAAM;SAAW;QACrC,QAAQ,GAAG,CAAC;YAAC;eAAU;SAAS;KAChC;IACD,OAAO,CAAC;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6357, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/convert/shared.js"],"sourcesContent":["import {finished} from 'node:stream/promises';\nimport {isStreamAbort} from '../resolve/wait-stream.js';\n\nexport const safeWaitForSubprocessStdin = async subprocessStdin => {\n\tif (subprocessStdin === undefined) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait waitForSubprocessStdin(subprocessStdin);\n\t} catch {}\n};\n\nexport const safeWaitForSubprocessStdout = async subprocessStdout => {\n\tif (subprocessStdout === undefined) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait waitForSubprocessStdout(subprocessStdout);\n\t} catch {}\n};\n\nexport const waitForSubprocessStdin = async subprocessStdin => {\n\tawait finished(subprocessStdin, {cleanup: true, readable: false, writable: true});\n};\n\nexport const waitForSubprocessStdout = async subprocessStdout => {\n\tawait finished(subprocessStdout, {cleanup: true, readable: true, writable: false});\n};\n\n// When `readable` or `writable` aborts/errors, awaits the subprocess, for the reason mentioned above\nexport const waitForSubprocess = async (subprocess, error) => {\n\tawait subprocess;\n\tif (error) {\n\t\tthrow error;\n\t}\n};\n\nexport const destroyOtherStream = (stream, isOpen, error) => {\n\tif (error && !isStreamAbort(error)) {\n\t\tstream.destroy(error);\n\t} else if (isOpen) {\n\t\tstream.destroy();\n\t}\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;;;AAEO,MAAM,6BAA6B,OAAM;IAC/C,IAAI,oBAAoB,WAAW;QAClC;IACD;IAEA,IAAI;QACH,MAAM,uBAAuB;IAC9B,EAAE,OAAM,CAAC;AACV;AAEO,MAAM,8BAA8B,OAAM;IAChD,IAAI,qBAAqB,WAAW;QACnC;IACD;IAEA,IAAI;QACH,MAAM,wBAAwB;IAC/B,EAAE,OAAM,CAAC;AACV;AAEO,MAAM,yBAAyB,OAAM;IAC3C,MAAM,IAAA,yJAAQ,EAAC,iBAAiB;QAAC,SAAS;QAAM,UAAU;QAAO,UAAU;IAAI;AAChF;AAEO,MAAM,0BAA0B,OAAM;IAC5C,MAAM,IAAA,yJAAQ,EAAC,kBAAkB;QAAC,SAAS;QAAM,UAAU;QAAM,UAAU;IAAK;AACjF;AAGO,MAAM,oBAAoB,OAAO,YAAY;IACnD,MAAM;IACN,IAAI,OAAO;QACV,MAAM;IACP;AACD;AAEO,MAAM,qBAAqB,CAAC,QAAQ,QAAQ;IAClD,IAAI,SAAS,CAAC,IAAA,0KAAa,EAAC,QAAQ;QACnC,OAAO,OAAO,CAAC;IAChB,OAAO,IAAI,QAAQ;QAClB,OAAO,OAAO;IACf;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6422, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/convert/readable.js"],"sourcesContent":["import {Readable} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {getFromStream} from '../arguments/fd-options.js';\nimport {iterateOnSubprocessStream, DEFAULT_OBJECT_HIGH_WATER_MARK} from '../io/iterate.js';\nimport {createDeferred} from '../utils/deferred.js';\nimport {addConcurrentStream, waitForConcurrentStreams} from './concurrent.js';\nimport {\n\tsafeWaitForSubprocessStdin,\n\twaitForSubprocessStdout,\n\twaitForSubprocess,\n\tdestroyOtherStream,\n} from './shared.js';\n\n// Create a `Readable` stream that forwards from `stdout` and awaits the subprocess\nexport const createReadable = ({subprocess, concurrentStreams, encoding}, {from, binary: binaryOption = true, preserveNewlines = true} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {subprocessStdout, waitReadableDestroy} = getSubprocessStdout(subprocess, from, concurrentStreams);\n\tconst {readableEncoding, readableObjectMode, readableHighWaterMark} = getReadableOptions(subprocessStdout, binary);\n\tconst {read, onStdoutDataDone} = getReadableMethods({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\tconst readable = new Readable({\n\t\tread,\n\t\tdestroy: callbackify(onReadableDestroy.bind(undefined, {subprocessStdout, subprocess, waitReadableDestroy})),\n\t\thighWaterMark: readableHighWaterMark,\n\t\tobjectMode: readableObjectMode,\n\t\tencoding: readableEncoding,\n\t});\n\tonStdoutFinished({\n\t\tsubprocessStdout,\n\t\tonStdoutDataDone,\n\t\treadable,\n\t\tsubprocess,\n\t});\n\treturn readable;\n};\n\n// Retrieve `stdout` (or other stream depending on `from`)\nexport const getSubprocessStdout = (subprocess, from, concurrentStreams) => {\n\tconst subprocessStdout = getFromStream(subprocess, from);\n\tconst waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, 'readableDestroy');\n\treturn {subprocessStdout, waitReadableDestroy};\n};\n\nexport const getReadableOptions = ({readableEncoding, readableObjectMode, readableHighWaterMark}, binary) => binary\n\t? {readableEncoding, readableObjectMode, readableHighWaterMark}\n\t: {readableEncoding, readableObjectMode: true, readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK};\n\nexport const getReadableMethods = ({subprocessStdout, subprocess, binary, encoding, preserveNewlines}) => {\n\tconst onStdoutDataDone = createDeferred();\n\tconst onStdoutData = iterateOnSubprocessStream({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tshouldEncode: !binary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\n\treturn {\n\t\tread() {\n\t\t\tonRead(this, onStdoutData, onStdoutDataDone);\n\t\t},\n\t\tonStdoutDataDone,\n\t};\n};\n\n// Forwards data from `stdout` to `readable`\nconst onRead = async (readable, onStdoutData, onStdoutDataDone) => {\n\ttry {\n\t\tconst {value, done} = await onStdoutData.next();\n\t\tif (done) {\n\t\t\tonStdoutDataDone.resolve();\n\t\t} else {\n\t\t\treadable.push(value);\n\t\t}\n\t} catch {}\n};\n\n// When `subprocess.stdout` ends/aborts/errors, do the same on `readable`.\n// Await the subprocess, for the same reason as above.\nexport const onStdoutFinished = async ({subprocessStdout, onStdoutDataDone, readable, subprocess, subprocessStdin}) => {\n\ttry {\n\t\tawait waitForSubprocessStdout(subprocessStdout);\n\t\tawait subprocess;\n\t\tawait safeWaitForSubprocessStdin(subprocessStdin);\n\t\tawait onStdoutDataDone;\n\n\t\tif (readable.readable) {\n\t\t\treadable.push(null);\n\t\t}\n\t} catch (error) {\n\t\tawait safeWaitForSubprocessStdin(subprocessStdin);\n\t\tdestroyOtherReadable(readable, error);\n\t}\n};\n\n// When `readable` aborts/errors, do the same on `subprocess.stdout`\nexport const onReadableDestroy = async ({subprocessStdout, subprocess, waitReadableDestroy}, error) => {\n\tif (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {\n\t\tdestroyOtherReadable(subprocessStdout, error);\n\t\tawait waitForSubprocess(subprocess, error);\n\t}\n};\n\nconst destroyOtherReadable = (stream, error) => {\n\tdestroyOtherStream(stream, stream.readable, error);\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAQO,MAAM,iBAAiB,CAAC,EAAC,UAAU,EAAE,iBAAiB,EAAE,QAAQ,EAAC,EAAE,EAAC,IAAI,EAAE,QAAQ,eAAe,IAAI,EAAE,mBAAmB,IAAI,EAAC,GAAG,CAAC,CAAC;IAC1I,MAAM,SAAS,gBAAgB,mLAAgB,CAAC,GAAG,CAAC;IACpD,MAAM,EAAC,gBAAgB,EAAE,mBAAmB,EAAC,GAAG,oBAAoB,YAAY,MAAM;IACtF,MAAM,EAAC,gBAAgB,EAAE,kBAAkB,EAAE,qBAAqB,EAAC,GAAG,mBAAmB,kBAAkB;IAC3G,MAAM,EAAC,IAAI,EAAE,gBAAgB,EAAC,GAAG,mBAAmB;QACnD;QACA;QACA;QACA;QACA;IACD;IACA,MAAM,WAAW,IAAI,iIAAQ,CAAC;QAC7B;QACA,SAAS,IAAA,gIAAW,EAAC,kBAAkB,IAAI,CAAC,WAAW;YAAC;YAAkB;YAAY;QAAmB;QACzG,eAAe;QACf,YAAY;QACZ,UAAU;IACX;IACA,iBAAiB;QAChB;QACA;QACA;QACA;IACD;IACA,OAAO;AACR;AAGO,MAAM,sBAAsB,CAAC,YAAY,MAAM;IACrD,MAAM,mBAAmB,IAAA,2KAAa,EAAC,YAAY;IACnD,MAAM,sBAAsB,IAAA,4KAAmB,EAAC,mBAAmB,kBAAkB;IACrF,OAAO;QAAC;QAAkB;IAAmB;AAC9C;AAEO,MAAM,qBAAqB,CAAC,EAAC,gBAAgB,EAAE,kBAAkB,EAAE,qBAAqB,EAAC,EAAE,SAAW,SAC1G;QAAC;QAAkB;QAAoB;IAAqB,IAC5D;QAAC;QAAkB,oBAAoB;QAAM,uBAAuB,+KAA8B;IAAA;AAE9F,MAAM,qBAAqB,CAAC,EAAC,gBAAgB,EAAE,UAAU,EAAE,MAAM,EAAE,QAAQ,EAAE,gBAAgB,EAAC;IACpG,MAAM,mBAAmB,IAAA,mKAAc;IACvC,MAAM,eAAe,IAAA,0KAAyB,EAAC;QAC9C;QACA;QACA;QACA,cAAc,CAAC;QACf;QACA;IACD;IAEA,OAAO;QACN;YACC,OAAO,IAAI,EAAE,cAAc;QAC5B;QACA;IACD;AACD;AAEA,4CAA4C;AAC5C,MAAM,SAAS,OAAO,UAAU,cAAc;IAC7C,IAAI;QACH,MAAM,EAAC,KAAK,EAAE,IAAI,EAAC,GAAG,MAAM,aAAa,IAAI;QAC7C,IAAI,MAAM;YACT,iBAAiB,OAAO;QACzB,OAAO;YACN,SAAS,IAAI,CAAC;QACf;IACD,EAAE,OAAM,CAAC;AACV;AAIO,MAAM,mBAAmB,OAAO,EAAC,gBAAgB,EAAE,gBAAgB,EAAE,QAAQ,EAAE,UAAU,EAAE,eAAe,EAAC;IACjH,IAAI;QACH,MAAM,IAAA,4KAAuB,EAAC;QAC9B,MAAM;QACN,MAAM,IAAA,+KAA0B,EAAC;QACjC,MAAM;QAEN,IAAI,SAAS,QAAQ,EAAE;YACtB,SAAS,IAAI,CAAC;QACf;IACD,EAAE,OAAO,OAAO;QACf,MAAM,IAAA,+KAA0B,EAAC;QACjC,qBAAqB,UAAU;IAChC;AACD;AAGO,MAAM,oBAAoB,OAAO,EAAC,gBAAgB,EAAE,UAAU,EAAE,mBAAmB,EAAC,EAAE;IAC5F,IAAI,MAAM,IAAA,iLAAwB,EAAC,qBAAqB,aAAa;QACpE,qBAAqB,kBAAkB;QACvC,MAAM,IAAA,sKAAiB,EAAC,YAAY;IACrC;AACD;AAEA,MAAM,uBAAuB,CAAC,QAAQ;IACrC,IAAA,uKAAkB,EAAC,QAAQ,OAAO,QAAQ,EAAE;AAC7C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6554, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/convert/writable.js"],"sourcesContent":["import {Writable} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {getToStream} from '../arguments/fd-options.js';\nimport {addConcurrentStream, waitForConcurrentStreams} from './concurrent.js';\nimport {\n\tsafeWaitForSubprocessStdout,\n\twaitForSubprocessStdin,\n\twaitForSubprocess,\n\tdestroyOtherStream,\n} from './shared.js';\n\n// Create a `Writable` stream that forwards to `stdin` and awaits the subprocess\nexport const createWritable = ({subprocess, concurrentStreams}, {to} = {}) => {\n\tconst {subprocessStdin, waitWritableFinal, waitWritableDestroy} = getSubprocessStdin(subprocess, to, concurrentStreams);\n\tconst writable = new Writable({\n\t\t...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),\n\t\tdestroy: callbackify(onWritableDestroy.bind(undefined, {\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t})),\n\t\thighWaterMark: subprocessStdin.writableHighWaterMark,\n\t\tobjectMode: subprocessStdin.writableObjectMode,\n\t});\n\tonStdinFinished(subprocessStdin, writable);\n\treturn writable;\n};\n\n// Retrieve `stdin` (or other stream depending on `to`)\nexport const getSubprocessStdin = (subprocess, to, concurrentStreams) => {\n\tconst subprocessStdin = getToStream(subprocess, to);\n\tconst waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableFinal');\n\tconst waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableDestroy');\n\treturn {subprocessStdin, waitWritableFinal, waitWritableDestroy};\n};\n\nexport const getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({\n\twrite: onWrite.bind(undefined, subprocessStdin),\n\tfinal: callbackify(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal)),\n});\n\n// Forwards data from `writable` to `stdin`\nconst onWrite = (subprocessStdin, chunk, encoding, done) => {\n\tif (subprocessStdin.write(chunk, encoding)) {\n\t\tdone();\n\t} else {\n\t\tsubprocessStdin.once('drain', done);\n\t}\n};\n\n// Ensures that the writable `final` and readable `end` events awaits the subprocess.\n// Like this, any subprocess failure is propagated as a stream `error` event, instead of being lost.\n// The user does not need to `await` the subprocess anymore, but now needs to await the stream completion or error.\n// When multiple writables are targeting the same stream, they wait for each other, unless the subprocess ends first.\nconst onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {\n\tif (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {\n\t\tif (subprocessStdin.writable) {\n\t\t\tsubprocessStdin.end();\n\t\t}\n\n\t\tawait subprocess;\n\t}\n};\n\n// When `subprocess.stdin` ends/aborts/errors, do the same on `writable`.\nexport const onStdinFinished = async (subprocessStdin, writable, subprocessStdout) => {\n\ttry {\n\t\tawait waitForSubprocessStdin(subprocessStdin);\n\t\tif (writable.writable) {\n\t\t\twritable.end();\n\t\t}\n\t} catch (error) {\n\t\tawait safeWaitForSubprocessStdout(subprocessStdout);\n\t\tdestroyOtherWritable(writable, error);\n\t}\n};\n\n// When `writable` aborts/errors, do the same on `subprocess.stdin`\nexport const onWritableDestroy = async ({subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy}, error) => {\n\tawait waitForConcurrentStreams(waitWritableFinal, subprocess);\n\tif (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {\n\t\tdestroyOtherWritable(subprocessStdin, error);\n\t\tawait waitForSubprocess(subprocess, error);\n\t}\n};\n\nconst destroyOtherWritable = (stream, error) => {\n\tdestroyOtherStream(stream, stream.writable, error);\n};\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAQO,MAAM,iBAAiB,CAAC,EAAC,UAAU,EAAE,iBAAiB,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,CAAC,CAAC;IACxE,MAAM,EAAC,eAAe,EAAE,iBAAiB,EAAE,mBAAmB,EAAC,GAAG,mBAAmB,YAAY,IAAI;IACrG,MAAM,WAAW,IAAI,iIAAQ,CAAC;QAC7B,GAAG,mBAAmB,iBAAiB,YAAY,kBAAkB;QACrE,SAAS,IAAA,gIAAW,EAAC,kBAAkB,IAAI,CAAC,WAAW;YACtD;YACA;YACA;YACA;QACD;QACA,eAAe,gBAAgB,qBAAqB;QACpD,YAAY,gBAAgB,kBAAkB;IAC/C;IACA,gBAAgB,iBAAiB;IACjC,OAAO;AACR;AAGO,MAAM,qBAAqB,CAAC,YAAY,IAAI;IAClD,MAAM,kBAAkB,IAAA,yKAAW,EAAC,YAAY;IAChD,MAAM,oBAAoB,IAAA,4KAAmB,EAAC,mBAAmB,iBAAiB;IAClF,MAAM,sBAAsB,IAAA,4KAAmB,EAAC,mBAAmB,iBAAiB;IACpF,OAAO;QAAC;QAAiB;QAAmB;IAAmB;AAChE;AAEO,MAAM,qBAAqB,CAAC,iBAAiB,YAAY,oBAAsB,CAAC;QACtF,OAAO,QAAQ,IAAI,CAAC,WAAW;QAC/B,OAAO,IAAA,gIAAW,EAAC,gBAAgB,IAAI,CAAC,WAAW,iBAAiB,YAAY;IACjF,CAAC;AAED,2CAA2C;AAC3C,MAAM,UAAU,CAAC,iBAAiB,OAAO,UAAU;IAClD,IAAI,gBAAgB,KAAK,CAAC,OAAO,WAAW;QAC3C;IACD,OAAO;QACN,gBAAgB,IAAI,CAAC,SAAS;IAC/B;AACD;AAEA,qFAAqF;AACrF,oGAAoG;AACpG,mHAAmH;AACnH,qHAAqH;AACrH,MAAM,kBAAkB,OAAO,iBAAiB,YAAY;IAC3D,IAAI,MAAM,IAAA,iLAAwB,EAAC,mBAAmB,aAAa;QAClE,IAAI,gBAAgB,QAAQ,EAAE;YAC7B,gBAAgB,GAAG;QACpB;QAEA,MAAM;IACP;AACD;AAGO,MAAM,kBAAkB,OAAO,iBAAiB,UAAU;IAChE,IAAI;QACH,MAAM,IAAA,2KAAsB,EAAC;QAC7B,IAAI,SAAS,QAAQ,EAAE;YACtB,SAAS,GAAG;QACb;IACD,EAAE,OAAO,OAAO;QACf,MAAM,IAAA,gLAA2B,EAAC;QAClC,qBAAqB,UAAU;IAChC;AACD;AAGO,MAAM,oBAAoB,OAAO,EAAC,eAAe,EAAE,UAAU,EAAE,iBAAiB,EAAE,mBAAmB,EAAC,EAAE;IAC9G,MAAM,IAAA,iLAAwB,EAAC,mBAAmB;IAClD,IAAI,MAAM,IAAA,iLAAwB,EAAC,qBAAqB,aAAa;QACpE,qBAAqB,iBAAiB;QACtC,MAAM,IAAA,sKAAiB,EAAC,YAAY;IACrC;AACD;AAEA,MAAM,uBAAuB,CAAC,QAAQ;IACrC,IAAA,uKAAkB,EAAC,QAAQ,OAAO,QAAQ,EAAE;AAC7C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6651, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/convert/duplex.js"],"sourcesContent":["import {Duplex} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {\n\tgetSubprocessStdout,\n\tgetReadableOptions,\n\tgetReadableMethods,\n\tonStdoutFinished,\n\tonReadableDestroy,\n} from './readable.js';\nimport {\n\tgetSubprocessStdin,\n\tgetWritableMethods,\n\tonStdinFinished,\n\tonWritableDestroy,\n} from './writable.js';\n\n// Create a `Duplex` stream combining both `subprocess.readable()` and `subprocess.writable()`\nexport const createDuplex = ({subprocess, concurrentStreams, encoding}, {from, to, binary: binaryOption = true, preserveNewlines = true} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {subprocessStdout, waitReadableDestroy} = getSubprocessStdout(subprocess, from, concurrentStreams);\n\tconst {subprocessStdin, waitWritableFinal, waitWritableDestroy} = getSubprocessStdin(subprocess, to, concurrentStreams);\n\tconst {readableEncoding, readableObjectMode, readableHighWaterMark} = getReadableOptions(subprocessStdout, binary);\n\tconst {read, onStdoutDataDone} = getReadableMethods({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\tconst duplex = new Duplex({\n\t\tread,\n\t\t...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),\n\t\tdestroy: callbackify(onDuplexDestroy.bind(undefined, {\n\t\t\tsubprocessStdout,\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitReadableDestroy,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t})),\n\t\treadableHighWaterMark,\n\t\twritableHighWaterMark: subprocessStdin.writableHighWaterMark,\n\t\treadableObjectMode,\n\t\twritableObjectMode: subprocessStdin.writableObjectMode,\n\t\tencoding: readableEncoding,\n\t});\n\tonStdoutFinished({\n\t\tsubprocessStdout,\n\t\tonStdoutDataDone,\n\t\treadable: duplex,\n\t\tsubprocess,\n\t\tsubprocessStdin,\n\t});\n\tonStdinFinished(subprocessStdin, duplex, subprocessStdout);\n\treturn duplex;\n};\n\nconst onDuplexDestroy = async ({subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy}, error) => {\n\tawait Promise.all([\n\t\tonReadableDestroy({subprocessStdout, subprocess, waitReadableDestroy}, error),\n\t\tonWritableDestroy({\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t}, error),\n\t]);\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AAOA;;;;;;AAQO,MAAM,eAAe,CAAC,EAAC,UAAU,EAAE,iBAAiB,EAAE,QAAQ,EAAC,EAAE,EAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,eAAe,IAAI,EAAE,mBAAmB,IAAI,EAAC,GAAG,CAAC,CAAC;IAC5I,MAAM,SAAS,gBAAgB,mLAAgB,CAAC,GAAG,CAAC;IACpD,MAAM,EAAC,gBAAgB,EAAE,mBAAmB,EAAC,GAAG,IAAA,0KAAmB,EAAC,YAAY,MAAM;IACtF,MAAM,EAAC,eAAe,EAAE,iBAAiB,EAAE,mBAAmB,EAAC,GAAG,IAAA,yKAAkB,EAAC,YAAY,IAAI;IACrG,MAAM,EAAC,gBAAgB,EAAE,kBAAkB,EAAE,qBAAqB,EAAC,GAAG,IAAA,yKAAkB,EAAC,kBAAkB;IAC3G,MAAM,EAAC,IAAI,EAAE,gBAAgB,EAAC,GAAG,IAAA,yKAAkB,EAAC;QACnD;QACA;QACA;QACA;QACA;IACD;IACA,MAAM,SAAS,IAAI,+HAAM,CAAC;QACzB;QACA,GAAG,IAAA,yKAAkB,EAAC,iBAAiB,YAAY,kBAAkB;QACrE,SAAS,IAAA,gIAAW,EAAC,gBAAgB,IAAI,CAAC,WAAW;YACpD;YACA;YACA;YACA;YACA;YACA;QACD;QACA;QACA,uBAAuB,gBAAgB,qBAAqB;QAC5D;QACA,oBAAoB,gBAAgB,kBAAkB;QACtD,UAAU;IACX;IACA,IAAA,uKAAgB,EAAC;QAChB;QACA;QACA,UAAU;QACV;QACA;IACD;IACA,IAAA,sKAAe,EAAC,iBAAiB,QAAQ;IACzC,OAAO;AACR;AAEA,MAAM,kBAAkB,OAAO,EAAC,gBAAgB,EAAE,eAAe,EAAE,UAAU,EAAE,mBAAmB,EAAE,iBAAiB,EAAE,mBAAmB,EAAC,EAAE;IAC5I,MAAM,QAAQ,GAAG,CAAC;QACjB,IAAA,wKAAiB,EAAC;YAAC;YAAkB;YAAY;QAAmB,GAAG;QACvE,IAAA,wKAAiB,EAAC;YACjB;YACA;YACA;YACA;QACD,GAAG;KACH;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6723, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/convert/iterable.js"],"sourcesContent":["import {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {getFromStream} from '../arguments/fd-options.js';\nimport {iterateOnSubprocessStream} from '../io/iterate.js';\n\n// Convert the subprocess to an async iterable\nexport const createIterable = (subprocess, encoding, {\n\tfrom,\n\tbinary: binaryOption = false,\n\tpreserveNewlines = false,\n} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst subprocessStdout = getFromStream(subprocess, from);\n\tconst onStdoutData = iterateOnSubprocessStream({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tshouldEncode: true,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\treturn iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);\n};\n\nconst iterateOnStdoutData = async function * (onStdoutData, subprocessStdout, subprocess) {\n\ttry {\n\t\tyield * onStdoutData;\n\t} finally {\n\t\tif (subprocessStdout.readable) {\n\t\t\tsubprocessStdout.destroy();\n\t\t}\n\n\t\tawait subprocess;\n\t}\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAGO,MAAM,iBAAiB,CAAC,YAAY,UAAU,EACpD,IAAI,EACJ,QAAQ,eAAe,KAAK,EAC5B,mBAAmB,KAAK,EACxB,GAAG,CAAC,CAAC;IACL,MAAM,SAAS,gBAAgB,mLAAgB,CAAC,GAAG,CAAC;IACpD,MAAM,mBAAmB,IAAA,2KAAa,EAAC,YAAY;IACnD,MAAM,eAAe,IAAA,0KAAyB,EAAC;QAC9C;QACA;QACA;QACA,cAAc;QACd;QACA;IACD;IACA,OAAO,oBAAoB,cAAc,kBAAkB;AAC5D;AAEA,MAAM,sBAAsB,gBAAkB,YAAY,EAAE,gBAAgB,EAAE,UAAU;IACvF,IAAI;QACH,OAAQ;IACT,SAAU;QACT,IAAI,iBAAiB,QAAQ,EAAE;YAC9B,iBAAiB,OAAO;QACzB;QAEA,MAAM;IACP;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6760, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/convert/add.js"],"sourcesContent":["import {initializeConcurrentStreams} from './concurrent.js';\nimport {createReadable} from './readable.js';\nimport {createWritable} from './writable.js';\nimport {createDuplex} from './duplex.js';\nimport {createIterable} from './iterable.js';\n\n// Add methods to convert the subprocess to a stream or iterable\nexport const addConvertedStreams = (subprocess, {encoding}) => {\n\tconst concurrentStreams = initializeConcurrentStreams();\n\tsubprocess.readable = createReadable.bind(undefined, {subprocess, concurrentStreams, encoding});\n\tsubprocess.writable = createWritable.bind(undefined, {subprocess, concurrentStreams});\n\tsubprocess.duplex = createDuplex.bind(undefined, {subprocess, concurrentStreams, encoding});\n\tsubprocess.iterable = createIterable.bind(undefined, subprocess, encoding);\n\tsubprocess[Symbol.asyncIterator] = createIterable.bind(undefined, subprocess, encoding, {});\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAGO,MAAM,sBAAsB,CAAC,YAAY,EAAC,QAAQ,EAAC;IACzD,MAAM,oBAAoB,IAAA,oLAA2B;IACrD,WAAW,QAAQ,GAAG,qKAAc,CAAC,IAAI,CAAC,WAAW;QAAC;QAAY;QAAmB;IAAQ;IAC7F,WAAW,QAAQ,GAAG,qKAAc,CAAC,IAAI,CAAC,WAAW;QAAC;QAAY;IAAiB;IACnF,WAAW,MAAM,GAAG,iKAAY,CAAC,IAAI,CAAC,WAAW;QAAC;QAAY;QAAmB;IAAQ;IACzF,WAAW,QAAQ,GAAG,qKAAc,CAAC,IAAI,CAAC,WAAW,YAAY;IACjE,UAAU,CAAC,OAAO,aAAa,CAAC,GAAG,qKAAc,CAAC,IAAI,CAAC,WAAW,YAAY,UAAU,CAAC;AAC1F","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6797, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/methods/promise.js"],"sourcesContent":["// The return value is a mixin of `subprocess` and `Promise`\nexport const mergePromise = (subprocess, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\tconst value = descriptor.value.bind(promise);\n\t\tReflect.defineProperty(subprocess, property, {...descriptor, value});\n\t}\n};\n\n// eslint-disable-next-line unicorn/prefer-top-level-await\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\n\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property),\n]);\n"],"names":[],"mappings":"AAAA,4DAA4D;;;;;AACrD,MAAM,eAAe,CAAC,YAAY;IACxC,KAAK,MAAM,CAAC,UAAU,WAAW,IAAI,YAAa;QACjD,MAAM,QAAQ,WAAW,KAAK,CAAC,IAAI,CAAC;QACpC,QAAQ,cAAc,CAAC,YAAY,UAAU;YAAC,GAAG,UAAU;YAAE;QAAK;IACnE;AACD;AAEA,0DAA0D;AAC1D,MAAM,yBAAyB,CAAC,WAAa,CAAC,IAAI,WAAW,CAAC,SAAS;AAEvE,MAAM,cAAc;IAAC;IAAQ;IAAS;CAAU,CAAC,GAAG,CAAC,CAAA,WAAY;QAChE;QACA,QAAQ,wBAAwB,CAAC,wBAAwB;KACzD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6825, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/methods/main-async.js"],"sourcesContent":["import {setMaxListeners} from 'node:events';\nimport {spawn} from 'node:child_process';\nimport {MaxBufferError} from 'get-stream';\nimport {handleCommand} from '../arguments/command.js';\nimport {normalizeOptions} from '../arguments/options.js';\nimport {SUBPROCESS_OPTIONS} from '../arguments/fd-options.js';\nimport {concatenateShell} from '../arguments/shell.js';\nimport {addIpcMethods} from '../ipc/methods.js';\nimport {makeError, makeSuccessResult} from '../return/result.js';\nimport {handleResult} from '../return/reject.js';\nimport {handleEarlyError} from '../return/early-error.js';\nimport {handleStdioAsync} from '../stdio/handle-async.js';\nimport {stripNewline} from '../io/strip-newline.js';\nimport {pipeOutputAsync} from '../io/output-async.js';\nimport {subprocessKill} from '../terminate/kill.js';\nimport {cleanupOnExit} from '../terminate/cleanup.js';\nimport {pipeToSubprocess} from '../pipe/setup.js';\nimport {makeAllStream} from '../resolve/all-async.js';\nimport {waitForSubprocessResult} from '../resolve/wait-subprocess.js';\nimport {addConvertedStreams} from '../convert/add.js';\nimport {createDeferred} from '../utils/deferred.js';\nimport {mergePromise} from './promise.js';\n\n// Main shared logic for all async methods: `execa()`, `$`, `execaNode()`\nexport const execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {\n\tconst {file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors} = handleAsyncArguments(rawFile, rawArguments, rawOptions);\n\tconst {subprocess, promise} = spawnSubprocessAsync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t});\n\tsubprocess.pipe = pipeToSubprocess.bind(undefined, {\n\t\tsource: subprocess,\n\t\tsourcePromise: promise,\n\t\tboundOptions: {},\n\t\tcreateNested,\n\t});\n\tmergePromise(subprocess, promise);\n\tSUBPROCESS_OPTIONS.set(subprocess, {options, fileDescriptors});\n\treturn subprocess;\n};\n\n// Compute arguments to pass to `child_process.spawn()`\nconst handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {\n\tconst {command, escapedCommand, startTime, verboseInfo} = handleCommand(rawFile, rawArguments, rawOptions);\n\tconst {file, commandArguments, options: normalizedOptions} = normalizeOptions(rawFile, rawArguments, rawOptions);\n\tconst options = handleAsyncOptions(normalizedOptions);\n\tconst fileDescriptors = handleStdioAsync(options, verboseInfo);\n\treturn {\n\t\tfile,\n\t\tcommandArguments,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\toptions,\n\t\tfileDescriptors,\n\t};\n};\n\n// Options normalization logic specific to async methods.\n// Prevent passing the `timeout` option directly to `child_process.spawn()`.\nconst handleAsyncOptions = ({timeout, signal, ...options}) => {\n\tif (signal !== undefined) {\n\t\tthrow new TypeError('The \"signal\" option has been renamed to \"cancelSignal\" instead.');\n\t}\n\n\treturn {...options, timeoutDuration: timeout};\n};\n\nconst spawnSubprocessAsync = ({file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors}) => {\n\tlet subprocess;\n\ttry {\n\t\tsubprocess = spawn(...concatenateShell(file, commandArguments, options));\n\t} catch (error) {\n\t\treturn handleEarlyError({\n\t\t\terror,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tfileDescriptors,\n\t\t\toptions,\n\t\t\tstartTime,\n\t\t\tverboseInfo,\n\t\t});\n\t}\n\n\tconst controller = new AbortController();\n\tsetMaxListeners(Number.POSITIVE_INFINITY, controller.signal);\n\n\tconst originalStreams = [...subprocess.stdio];\n\tpipeOutputAsync(subprocess, fileDescriptors, controller);\n\tcleanupOnExit(subprocess, options, controller);\n\n\tconst context = {};\n\tconst onInternalError = createDeferred();\n\tsubprocess.kill = subprocessKill.bind(undefined, {\n\t\tkill: subprocess.kill.bind(subprocess),\n\t\toptions,\n\t\tonInternalError,\n\t\tcontext,\n\t\tcontroller,\n\t});\n\tsubprocess.all = makeAllStream(subprocess, options);\n\taddConvertedStreams(subprocess, options);\n\taddIpcMethods(subprocess, options);\n\n\tconst promise = handlePromise({\n\t\tsubprocess,\n\t\toptions,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\toriginalStreams,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tcontext,\n\t\tonInternalError,\n\t\tcontroller,\n\t});\n\treturn {subprocess, promise};\n};\n\n// Asynchronous logic, as opposed to the previous logic which can be run synchronously, i.e. can be returned to user right away\nconst handlePromise = async ({subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, context, onInternalError, controller}) => {\n\tconst [\n\t\terrorInfo,\n\t\t[exitCode, signal],\n\t\tstdioResults,\n\t\tallResult,\n\t\tipcOutput,\n\t] = await waitForSubprocessResult({\n\t\tsubprocess,\n\t\toptions,\n\t\tcontext,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\toriginalStreams,\n\t\tonInternalError,\n\t\tcontroller,\n\t});\n\tcontroller.abort();\n\tonInternalError.resolve();\n\n\tconst stdio = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options, fdNumber));\n\tconst all = stripNewline(allResult, options, 'all');\n\tconst result = getAsyncResult({\n\t\terrorInfo,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\tcontext,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t});\n\treturn handleResult(result, verboseInfo, options);\n};\n\nconst getAsyncResult = ({errorInfo, exitCode, signal, stdio, all, ipcOutput, context, options, command, escapedCommand, startTime}) => 'error' in errorInfo\n\t? makeError({\n\t\terror: errorInfo.error,\n\t\tcommand,\n\t\tescapedCommand,\n\t\ttimedOut: context.terminationReason === 'timeout',\n\t\tisCanceled: context.terminationReason === 'cancel' || context.terminationReason === 'gracefulCancel',\n\t\tisGracefullyCanceled: context.terminationReason === 'gracefulCancel',\n\t\tisMaxBuffer: errorInfo.error instanceof MaxBufferError,\n\t\tisForcefullyTerminated: context.isForcefullyTerminated,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: false,\n\t})\n\t: makeSuccessResult({\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\toptions,\n\t\tstartTime,\n\t});\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7039, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/methods/bind.js"],"sourcesContent":["import isPlainObject from 'is-plain-obj';\nimport {FD_SPECIFIC_OPTIONS} from '../arguments/specific.js';\n\n// Deep merge specific options like `env`. Shallow merge the other ones.\nexport const mergeOptions = (boundOptions, options) => {\n\tconst newOptions = Object.fromEntries(\n\t\tObject.entries(options).map(([optionName, optionValue]) => [\n\t\t\toptionName,\n\t\t\tmergeOption(optionName, boundOptions[optionName], optionValue),\n\t\t]),\n\t);\n\treturn {...boundOptions, ...newOptions};\n};\n\nconst mergeOption = (optionName, boundOptionValue, optionValue) => {\n\tif (DEEP_OPTIONS.has(optionName) && isPlainObject(boundOptionValue) && isPlainObject(optionValue)) {\n\t\treturn {...boundOptionValue, ...optionValue};\n\t}\n\n\treturn optionValue;\n};\n\nconst DEEP_OPTIONS = new Set(['env', ...FD_SPECIFIC_OPTIONS]);\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAGO,MAAM,eAAe,CAAC,cAAc;IAC1C,MAAM,aAAa,OAAO,WAAW,CACpC,OAAO,OAAO,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,YAAY,YAAY,GAAK;YAC1D;YACA,YAAY,YAAY,YAAY,CAAC,WAAW,EAAE;SAClD;IAEF,OAAO;QAAC,GAAG,YAAY;QAAE,GAAG,UAAU;IAAA;AACvC;AAEA,MAAM,cAAc,CAAC,YAAY,kBAAkB;IAClD,IAAI,aAAa,GAAG,CAAC,eAAe,IAAA,sJAAa,EAAC,qBAAqB,IAAA,sJAAa,EAAC,cAAc;QAClG,OAAO;YAAC,GAAG,gBAAgB;YAAE,GAAG,WAAW;QAAA;IAC5C;IAEA,OAAO;AACR;AAEA,MAAM,eAAe,IAAI,IAAI;IAAC;OAAU,4KAAmB;CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7074, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/methods/create.js"],"sourcesContent":["import isPlainObject from 'is-plain-obj';\nimport {normalizeParameters} from './parameters.js';\nimport {isTemplateString, parseTemplates} from './template.js';\nimport {execaCoreSync} from './main-sync.js';\nimport {execaCoreAsync} from './main-async.js';\nimport {mergeOptions} from './bind.js';\n\n// Wraps every exported methods to provide the following features:\n//  - template string syntax: execa`command argument`\n//  - options binding: boundExeca = execa(options)\n//  - optional argument/options: execa(file), execa(file, args), execa(file, options), execa(file, args, options)\n// `mapArguments()` and `setBoundExeca()` allows for method-specific logic.\nexport const createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {\n\tconst createNested = (mapArguments, boundOptions, setBoundExeca) => createExeca(mapArguments, boundOptions, deepOptions, setBoundExeca);\n\tconst boundExeca = (...execaArguments) => callBoundExeca({\n\t\tmapArguments,\n\t\tdeepOptions,\n\t\tboundOptions,\n\t\tsetBoundExeca,\n\t\tcreateNested,\n\t}, ...execaArguments);\n\n\tif (setBoundExeca !== undefined) {\n\t\tsetBoundExeca(boundExeca, createNested, boundOptions);\n\t}\n\n\treturn boundExeca;\n};\n\nconst callBoundExeca = ({mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested}, firstArgument, ...nextArguments) => {\n\tif (isPlainObject(firstArgument)) {\n\t\treturn createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);\n\t}\n\n\tconst {file, commandArguments, options, isSync} = parseArguments({\n\t\tmapArguments,\n\t\tfirstArgument,\n\t\tnextArguments,\n\t\tdeepOptions,\n\t\tboundOptions,\n\t});\n\treturn isSync\n\t\t? execaCoreSync(file, commandArguments, options)\n\t\t: execaCoreAsync(file, commandArguments, options, createNested);\n};\n\nconst parseArguments = ({mapArguments, firstArgument, nextArguments, deepOptions, boundOptions}) => {\n\tconst callArguments = isTemplateString(firstArgument)\n\t\t? parseTemplates(firstArgument, nextArguments)\n\t\t: [firstArgument, ...nextArguments];\n\tconst [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);\n\tconst mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);\n\tconst {\n\t\tfile = initialFile,\n\t\tcommandArguments = initialArguments,\n\t\toptions = mergedOptions,\n\t\tisSync = false,\n\t} = mapArguments({file: initialFile, commandArguments: initialArguments, options: mergedOptions});\n\treturn {\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tisSync,\n\t};\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOO,MAAM,cAAc,CAAC,cAAc,cAAc,aAAa;IACpE,MAAM,eAAe,CAAC,cAAc,cAAc,gBAAkB,YAAY,cAAc,cAAc,aAAa;IACzH,MAAM,aAAa,CAAC,GAAG,iBAAmB,eAAe;YACxD;YACA;YACA;YACA;YACA;QACD,MAAM;IAEN,IAAI,kBAAkB,WAAW;QAChC,cAAc,YAAY,cAAc;IACzC;IAEA,OAAO;AACR;AAEA,MAAM,iBAAiB,CAAC,EAAC,YAAY,EAAE,cAAc,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC,EAAE,aAAa,EAAE,YAAY,EAAC,EAAE,eAAe,GAAG;IAC3H,IAAI,IAAA,sJAAa,EAAC,gBAAgB;QACjC,OAAO,aAAa,cAAc,IAAA,+JAAY,EAAC,cAAc,gBAAgB;IAC9E;IAEA,MAAM,EAAC,IAAI,EAAE,gBAAgB,EAAE,OAAO,EAAE,MAAM,EAAC,GAAG,eAAe;QAChE;QACA;QACA;QACA;QACA;IACD;IACA,OAAO,SACJ,IAAA,wKAAa,EAAC,MAAM,kBAAkB,WACtC,IAAA,0KAAc,EAAC,MAAM,kBAAkB,SAAS;AACpD;AAEA,MAAM,iBAAiB,CAAC,EAAC,YAAY,EAAE,aAAa,EAAE,aAAa,EAAE,WAAW,EAAE,YAAY,EAAC;IAC9F,MAAM,gBAAgB,IAAA,uKAAgB,EAAC,iBACpC,IAAA,qKAAc,EAAC,eAAe,iBAC9B;QAAC;WAAkB;KAAc;IACpC,MAAM,CAAC,aAAa,kBAAkB,eAAe,GAAG,IAAA,4KAAmB,KAAI;IAC/E,MAAM,gBAAgB,IAAA,+JAAY,EAAC,IAAA,+JAAY,EAAC,aAAa,eAAe;IAC5E,MAAM,EACL,OAAO,WAAW,EAClB,mBAAmB,gBAAgB,EACnC,UAAU,aAAa,EACvB,SAAS,KAAK,EACd,GAAG,aAAa;QAAC,MAAM;QAAa,kBAAkB;QAAkB,SAAS;IAAa;IAC/F,OAAO;QACN;QACA;QACA;QACA;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/methods/command.js"],"sourcesContent":["// Main logic for `execaCommand()`\nexport const mapCommandAsync = ({file, commandArguments}) => parseCommand(file, commandArguments);\n\n// Main logic for `execaCommandSync()`\nexport const mapCommandSync = ({file, commandArguments}) => ({...parseCommand(file, commandArguments), isSync: true});\n\n// Convert `execaCommand(command)` into `execa(file, ...commandArguments)`\nconst parseCommand = (command, unusedArguments) => {\n\tif (unusedArguments.length > 0) {\n\t\tthrow new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);\n\t}\n\n\tconst [file, ...commandArguments] = parseCommandString(command);\n\treturn {file, commandArguments};\n};\n\n// Convert `command` string into an array of file or arguments to pass to $`${...fileOrCommandArguments}`\nexport const parseCommandString = command => {\n\tif (typeof command !== 'string') {\n\t\tthrow new TypeError(`The command must be a string: ${String(command)}.`);\n\t}\n\n\tconst trimmedCommand = command.trim();\n\tif (trimmedCommand === '') {\n\t\treturn [];\n\t}\n\n\tconst tokens = [];\n\tfor (const token of trimmedCommand.split(SPACES_REGEXP)) {\n\t\t// Allow spaces to be escaped by a backslash if not meant as a delimiter\n\t\tconst previousToken = tokens.at(-1);\n\t\tif (previousToken && previousToken.endsWith('\\\\')) {\n\t\t\t// Merge previous token with current one\n\t\t\ttokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n\t\t} else {\n\t\t\ttokens.push(token);\n\t\t}\n\t}\n\n\treturn tokens;\n};\n\nconst SPACES_REGEXP = / +/g;\n"],"names":[],"mappings":"AAAA,kCAAkC;;;;;;;;;AAC3B,MAAM,kBAAkB,CAAC,EAAC,IAAI,EAAE,gBAAgB,EAAC,GAAK,aAAa,MAAM;AAGzE,MAAM,iBAAiB,CAAC,EAAC,IAAI,EAAE,gBAAgB,EAAC,GAAK,CAAC;QAAC,GAAG,aAAa,MAAM,iBAAiB;QAAE,QAAQ;IAAI,CAAC;AAEpH,0EAA0E;AAC1E,MAAM,eAAe,CAAC,SAAS;IAC9B,IAAI,gBAAgB,MAAM,GAAG,GAAG;QAC/B,MAAM,IAAI,UAAU,CAAC,iEAAiE,EAAE,QAAQ,CAAC,EAAE,gBAAgB,CAAC,CAAC;IACtH;IAEA,MAAM,CAAC,MAAM,GAAG,iBAAiB,GAAG,mBAAmB;IACvD,OAAO;QAAC;QAAM;IAAgB;AAC/B;AAGO,MAAM,qBAAqB,CAAA;IACjC,IAAI,OAAO,YAAY,UAAU;QAChC,MAAM,IAAI,UAAU,CAAC,8BAA8B,EAAE,OAAO,SAAS,CAAC,CAAC;IACxE;IAEA,MAAM,iBAAiB,QAAQ,IAAI;IACnC,IAAI,mBAAmB,IAAI;QAC1B,OAAO,EAAE;IACV;IAEA,MAAM,SAAS,EAAE;IACjB,KAAK,MAAM,SAAS,eAAe,KAAK,CAAC,eAAgB;QACxD,wEAAwE;QACxE,MAAM,gBAAgB,OAAO,EAAE,CAAC,CAAC;QACjC,IAAI,iBAAiB,cAAc,QAAQ,CAAC,OAAO;YAClD,wCAAwC;YACxC,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,GAAG,GAAG,cAAc,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,OAAO;QACrE,OAAO;YACN,OAAO,IAAI,CAAC;QACb;IACD;IAEA,OAAO;AACR;AAEA,MAAM,gBAAgB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/lib/methods/script.js"],"sourcesContent":["// Sets `$.sync` and `$.s`\nexport const setScriptSync = (boundExeca, createNested, boundOptions) => {\n\tboundExeca.sync = createNested(mapScriptSync, boundOptions);\n\tboundExeca.s = boundExeca.sync;\n};\n\n// Main logic for `$`\nexport const mapScriptAsync = ({options}) => getScriptOptions(options);\n\n// Main logic for `$.sync`\nconst mapScriptSync = ({options}) => ({...getScriptOptions(options), isSync: true});\n\n// `$` is like `execa` but with script-friendly options: `{stdin: 'inherit', preferLocal: true}`\nconst getScriptOptions = options => ({options: {...getScriptStdinOption(options), ...options}});\n\nconst getScriptStdinOption = ({input, inputFile, stdio}) => input === undefined && inputFile === undefined && stdio === undefined\n\t? {stdin: 'inherit'}\n\t: {};\n\n// When using $(...).pipe(...), most script-friendly options should apply to both commands.\n// However, some options (like `stdin: 'inherit'`) would create issues with piping, i.e. cannot be deep.\nexport const deepScriptOptions = {preferLocal: true};\n"],"names":[],"mappings":"AAAA,0BAA0B;;;;;;;;;AACnB,MAAM,gBAAgB,CAAC,YAAY,cAAc;IACvD,WAAW,IAAI,GAAG,aAAa,eAAe;IAC9C,WAAW,CAAC,GAAG,WAAW,IAAI;AAC/B;AAGO,MAAM,iBAAiB,CAAC,EAAC,OAAO,EAAC,GAAK,iBAAiB;AAE9D,0BAA0B;AAC1B,MAAM,gBAAgB,CAAC,EAAC,OAAO,EAAC,GAAK,CAAC;QAAC,GAAG,iBAAiB,QAAQ;QAAE,QAAQ;IAAI,CAAC;AAElF,gGAAgG;AAChG,MAAM,mBAAmB,CAAA,UAAW,CAAC;QAAC,SAAS;YAAC,GAAG,qBAAqB,QAAQ;YAAE,GAAG,OAAO;QAAA;IAAC,CAAC;AAE9F,MAAM,uBAAuB,CAAC,EAAC,KAAK,EAAE,SAAS,EAAE,KAAK,EAAC,GAAK,UAAU,aAAa,cAAc,aAAa,UAAU,YACrH;QAAC,OAAO;IAAS,IACjB,CAAC;AAIG,MAAM,oBAAoB;IAAC,aAAa;AAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7227, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Patron/Contacts/Desktop/Ghost%20in%20the%20Shell/aurora-dashboard/node_modules/execa/index.js"],"sourcesContent":["import {createExeca} from './lib/methods/create.js';\nimport {mapCommandAsync, mapCommandSync} from './lib/methods/command.js';\nimport {mapNode} from './lib/methods/node.js';\nimport {mapScriptAsync, setScriptSync, deepScriptOptions} from './lib/methods/script.js';\nimport {getIpcExport} from './lib/ipc/methods.js';\n\nexport {parseCommandString} from './lib/methods/command.js';\nexport {ExecaError, ExecaSyncError} from './lib/return/final-error.js';\n\nexport const execa = createExeca(() => ({}));\nexport const execaSync = createExeca(() => ({isSync: true}));\nexport const execaCommand = createExeca(mapCommandAsync);\nexport const execaCommandSync = createExeca(mapCommandSync);\nexport const execaNode = createExeca(mapNode);\nexport const $ = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);\n\nconst {\n\tsendMessage,\n\tgetOneMessage,\n\tgetEachMessage,\n\tgetCancelSignal,\n} = getIpcExport();\nexport {\n\tsendMessage,\n\tgetOneMessage,\n\tgetEachMessage,\n\tgetCancelSignal,\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAKO,MAAM,QAAQ,IAAA,gKAAW,EAAC,IAAM,CAAC,CAAC,CAAC;AACnC,MAAM,YAAY,IAAA,gKAAW,EAAC,IAAM,CAAC;QAAC,QAAQ;IAAI,CAAC;AACnD,MAAM,eAAe,IAAA,gKAAW,EAAC,qKAAe;AAChD,MAAM,mBAAmB,IAAA,gKAAW,EAAC,oKAAc;AACnD,MAAM,YAAY,IAAA,gKAAW,EAAC,0JAAO;AACrC,MAAM,IAAI,IAAA,gKAAW,EAAC,mKAAc,EAAE,CAAC,GAAG,sKAAiB,EAAE,kKAAa;AAEjF,MAAM,EACL,WAAW,EACX,aAAa,EACb,cAAc,EACd,eAAe,EACf,GAAG,IAAA,8JAAY","ignoreList":[0],"debugId":null}}]
}