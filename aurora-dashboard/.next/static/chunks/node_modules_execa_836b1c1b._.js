(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/execa/lib/arguments/file-url.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isDenoExecPath",
    ()=>isDenoExecPath,
    "normalizeFileUrl",
    ()=>normalizeFileUrl,
    "safeNormalizeFileUrl",
    ()=>safeNormalizeFileUrl
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$native$2d$url$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)");
;
const safeNormalizeFileUrl = (file, name)=>{
    const fileString = normalizeFileUrl(normalizeDenoExecPath(file));
    if (typeof fileString !== 'string') {
        throw new TypeError("".concat(name, " must be a string or a file URL: ").concat(fileString, "."));
    }
    return fileString;
};
// In Deno node:process execPath is a special object, not just a string:
// https://github.com/denoland/deno/blob/f460188e583f00144000aa0d8ade08218d47c3c1/ext/node/polyfills/process.ts#L344
const normalizeDenoExecPath = (file)=>isDenoExecPath(file) ? file.toString() : file;
const isDenoExecPath = (file)=>typeof file !== 'string' && file && Object.getPrototypeOf(file) === String.prototype;
const normalizeFileUrl = (file)=>file instanceof URL ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$native$2d$url$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fileURLToPath"])(file) : file;
}),
"[project]/node_modules/execa/lib/methods/parameters.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizeParameters",
    ()=>normalizeParameters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/file-url.js [app-client] (ecmascript)");
;
;
const normalizeParameters = function(rawFile) {
    let rawArguments = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], rawOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const filePath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeNormalizeFileUrl"])(rawFile, 'First argument');
    const [commandArguments, options] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rawArguments) ? [
        [],
        rawArguments
    ] : [
        rawArguments,
        rawOptions
    ];
    if (!Array.isArray(commandArguments)) {
        throw new TypeError("Second argument must be either an array of arguments or an options object: ".concat(commandArguments));
    }
    if (commandArguments.some((commandArgument)=>typeof commandArgument === 'object' && commandArgument !== null)) {
        throw new TypeError("Second argument must be an array of strings: ".concat(commandArguments));
    }
    const normalizedArguments = commandArguments.map(String);
    const nullByteArgument = normalizedArguments.find((normalizedArgument)=>normalizedArgument.includes('\0'));
    if (nullByteArgument !== undefined) {
        throw new TypeError('Arguments cannot contain null bytes ("\\0"): '.concat(nullByteArgument));
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(options)) {
        throw new TypeError("Last argument must be an options object: ".concat(options));
    }
    return [
        filePath,
        normalizedArguments,
        options
    ];
};
}),
"[project]/node_modules/execa/lib/utils/uint-array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bufferToUint8Array",
    ()=>bufferToUint8Array,
    "concatUint8Arrays",
    ()=>concatUint8Arrays,
    "isArrayBuffer",
    ()=>isArrayBuffer,
    "isUint8Array",
    ()=>isUint8Array,
    "joinToString",
    ()=>joinToString,
    "joinToUint8Array",
    ()=>joinToUint8Array,
    "uint8ArrayToString",
    ()=>uint8ArrayToString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$string_decoder$2f$string_decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/string_decoder/string_decoder.js [app-client] (ecmascript)");
;
const { toString: objectToString } = Object.prototype;
const isArrayBuffer = (value)=>objectToString.call(value) === '[object ArrayBuffer]';
const isUint8Array = (value)=>objectToString.call(value) === '[object Uint8Array]';
const bufferToUint8Array = (buffer)=>new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
const textEncoder = new TextEncoder();
const stringToUint8Array = (string)=>textEncoder.encode(string);
const textDecoder = new TextDecoder();
const uint8ArrayToString = (uint8Array)=>textDecoder.decode(uint8Array);
const joinToString = (uint8ArraysOrStrings, encoding)=>{
    const strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);
    return strings.join('');
};
const uint8ArraysToStrings = (uint8ArraysOrStrings, encoding)=>{
    if (encoding === 'utf8' && uint8ArraysOrStrings.every((uint8ArrayOrString)=>typeof uint8ArrayOrString === 'string')) {
        return uint8ArraysOrStrings;
    }
    const decoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$string_decoder$2f$string_decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StringDecoder"](encoding);
    const strings = uint8ArraysOrStrings.map((uint8ArrayOrString)=>typeof uint8ArrayOrString === 'string' ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString).map((uint8Array)=>decoder.write(uint8Array));
    const finalString = decoder.end();
    return finalString === '' ? strings : [
        ...strings,
        finalString
    ];
};
const joinToUint8Array = (uint8ArraysOrStrings)=>{
    if (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {
        return uint8ArraysOrStrings[0];
    }
    return concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));
};
const stringsToUint8Arrays = (uint8ArraysOrStrings)=>uint8ArraysOrStrings.map((uint8ArrayOrString)=>typeof uint8ArrayOrString === 'string' ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString);
const concatUint8Arrays = (uint8Arrays)=>{
    const result = new Uint8Array(getJoinLength(uint8Arrays));
    let index = 0;
    for (const uint8Array of uint8Arrays){
        result.set(uint8Array, index);
        index += uint8Array.length;
    }
    return result;
};
const getJoinLength = (uint8Arrays)=>{
    let joinLength = 0;
    for (const uint8Array of uint8Arrays){
        joinLength += uint8Array.length;
    }
    return joinLength;
};
}),
"[project]/node_modules/execa/lib/methods/template.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/methods/template.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:child_process)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/methods/template.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:child_process)");

}}),
"[project]/node_modules/execa/lib/utils/standard-stream.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "STANDARD_STREAMS",
    ()=>STANDARD_STREAMS,
    "STANDARD_STREAMS_ALIASES",
    ()=>STANDARD_STREAMS_ALIASES,
    "getStreamName",
    ()=>getStreamName,
    "isStandardStream",
    ()=>isStandardStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
;
const isStandardStream = (stream)=>STANDARD_STREAMS.includes(stream);
const STANDARD_STREAMS = [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stdin,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stdout,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stderr
];
const STANDARD_STREAMS_ALIASES = [
    'stdin',
    'stdout',
    'stderr'
];
const getStreamName = (fdNumber)=>{
    var _STANDARD_STREAMS_ALIASES_fdNumber;
    return (_STANDARD_STREAMS_ALIASES_fdNumber = STANDARD_STREAMS_ALIASES[fdNumber]) !== null && _STANDARD_STREAMS_ALIASES_fdNumber !== void 0 ? _STANDARD_STREAMS_ALIASES_fdNumber : "stdio[".concat(fdNumber, "]");
};
}),
"[project]/node_modules/execa/lib/arguments/specific.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FD_SPECIFIC_OPTIONS",
    ()=>FD_SPECIFIC_OPTIONS,
    "getFdSpecificValue",
    ()=>getFdSpecificValue,
    "normalizeFdSpecificOption",
    ()=>normalizeFdSpecificOption,
    "normalizeFdSpecificOptions",
    ()=>normalizeFdSpecificOptions,
    "parseFd",
    ()=>parseFd
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-client] (ecmascript)");
;
;
;
const normalizeFdSpecificOptions = (options)=>{
    const optionsCopy = {
        ...options
    };
    for (const optionName of FD_SPECIFIC_OPTIONS){
        optionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);
    }
    return optionsCopy;
};
const normalizeFdSpecificOption = (options, optionName)=>{
    const optionBaseArray = Array.from({
        length: getStdioLength(options) + 1
    });
    const optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);
    return addDefaultValue(optionArray, optionName);
};
const getStdioLength = (param)=>{
    let { stdio } = param;
    return Array.isArray(stdio) ? Math.max(stdio.length, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].length) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].length;
};
const normalizeFdSpecificValue = (optionValue, optionArray, optionName)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(optionValue) ? normalizeOptionObject(optionValue, optionArray, optionName) : optionArray.fill(optionValue);
const normalizeOptionObject = (optionValue, optionArray, optionName)=>{
    for (const fdName of Object.keys(optionValue).sort(compareFdName)){
        for (const fdNumber of parseFdName(fdName, optionName, optionArray)){
            optionArray[fdNumber] = optionValue[fdName];
        }
    }
    return optionArray;
};
// Ensure priority order when setting both `stdout`/`stderr`, `fd1`/`fd2`, and `all`
const compareFdName = (fdNameA, fdNameB)=>getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;
const getFdNameOrder = (fdName)=>{
    if (fdName === 'stdout' || fdName === 'stderr') {
        return 0;
    }
    return fdName === 'all' ? 2 : 1;
};
const parseFdName = (fdName, optionName, optionArray)=>{
    if (fdName === 'ipc') {
        return [
            optionArray.length - 1
        ];
    }
    const fdNumber = parseFd(fdName);
    if (fdNumber === undefined || fdNumber === 0) {
        throw new TypeError('"'.concat(optionName, ".").concat(fdName, '" is invalid.\nIt must be "').concat(optionName, '.stdout", "').concat(optionName, '.stderr", "').concat(optionName, '.all", "').concat(optionName, '.ipc", or "').concat(optionName, '.fd3", "').concat(optionName, '.fd4" (and so on).'));
    }
    if (fdNumber >= optionArray.length) {
        throw new TypeError('"'.concat(optionName, ".").concat(fdName, '" is invalid: that file descriptor does not exist.\nPlease set the "stdio" option to ensure that file descriptor exists.'));
    }
    return fdNumber === 'all' ? [
        1,
        2
    ] : [
        fdNumber
    ];
};
const parseFd = (fdName)=>{
    if (fdName === 'all') {
        return fdName;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].includes(fdName)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].indexOf(fdName);
    }
    const regexpResult = FD_REGEXP.exec(fdName);
    if (regexpResult !== null) {
        return Number(regexpResult[1]);
    }
};
const FD_REGEXP = /^fd(\d+)$/;
const addDefaultValue = (optionArray, optionName)=>optionArray.map((optionValue)=>optionValue === undefined ? DEFAULT_OPTIONS[optionName] : optionValue);
// Default value for the `verbose` option
const verboseDefault = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["debuglog"])('execa').enabled ? 'full' : 'none';
const DEFAULT_OPTIONS = {
    lines: false,
    buffer: true,
    maxBuffer: 1000 * 1000 * 100,
    verbose: verboseDefault,
    stripFinalNewline: true
};
const FD_SPECIFIC_OPTIONS = [
    'lines',
    'buffer',
    'maxBuffer',
    'verbose',
    'stripFinalNewline'
];
const getFdSpecificValue = (optionArray, fdNumber)=>fdNumber === 'ipc' ? optionArray.at(-1) : optionArray[fdNumber];
}),
"[project]/node_modules/execa/lib/verbose/values.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VERBOSE_VALUES",
    ()=>VERBOSE_VALUES,
    "getVerboseFunction",
    ()=>getVerboseFunction,
    "isFullVerbose",
    ()=>isFullVerbose,
    "isVerbose",
    ()=>isVerbose,
    "isVerboseFunction",
    ()=>isVerboseFunction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-client] (ecmascript)");
;
const isVerbose = (param, fdNumber)=>{
    let { verbose } = param;
    return getFdVerbose(verbose, fdNumber) !== 'none';
};
const isFullVerbose = (param, fdNumber)=>{
    let { verbose } = param;
    return ![
        'none',
        'short'
    ].includes(getFdVerbose(verbose, fdNumber));
};
const getVerboseFunction = (param, fdNumber)=>{
    let { verbose } = param;
    const fdVerbose = getFdVerbose(verbose, fdNumber);
    return isVerboseFunction(fdVerbose) ? fdVerbose : undefined;
};
// When using `verbose: {stdout, stderr, fd3, ipc}`:
//  - `verbose.stdout|stderr|fd3` is used for 'output'
//  - `verbose.ipc` is only used for 'ipc'
//  - highest `verbose.*` value is used for 'command', 'error' and 'duration'
const getFdVerbose = (verbose, fdNumber)=>fdNumber === undefined ? getFdGenericVerbose(verbose) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFdSpecificValue"])(verbose, fdNumber);
// When using `verbose: {stdout, stderr, fd3, ipc}` and logging is not specific to a file descriptor.
// We then use the highest `verbose.*` value, using the following order:
//  - function > 'full' > 'short' > 'none'
//  - if several functions are defined: stdout > stderr > fd3 > ipc
const getFdGenericVerbose = (verbose)=>{
    var _verbose_find;
    return (_verbose_find = verbose.find((fdVerbose)=>isVerboseFunction(fdVerbose))) !== null && _verbose_find !== void 0 ? _verbose_find : VERBOSE_VALUES.findLast((fdVerbose)=>verbose.includes(fdVerbose));
};
const isVerboseFunction = (fdVerbose)=>typeof fdVerbose === 'function';
const VERBOSE_VALUES = [
    'none',
    'short',
    'full'
];
}),
"[project]/node_modules/execa/lib/arguments/escape.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "escapeLines",
    ()=>escapeLines,
    "joinCommand",
    ()=>joinCommand
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
;
;
const joinCommand = (filePath, rawArguments)=>{
    const fileAndArguments = [
        filePath,
        ...rawArguments
    ];
    const command = fileAndArguments.join(' ');
    const escapedCommand = fileAndArguments.map((fileAndArgument)=>quoteString(escapeControlCharacters(fileAndArgument))).join(' ');
    return {
        command,
        escapedCommand
    };
};
const escapeLines = (lines)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stripVTControlCharacters"])(lines).split('\n').map((line)=>escapeControlCharacters(line)).join('\n');
const escapeControlCharacters = (line)=>line.replaceAll(SPECIAL_CHAR_REGEXP, (character)=>escapeControlCharacter(character));
const escapeControlCharacter = (character)=>{
    const commonEscape = COMMON_ESCAPES[character];
    if (commonEscape !== undefined) {
        return commonEscape;
    }
    const codepoint = character.codePointAt(0);
    const codepointHex = codepoint.toString(16);
    return codepoint <= ASTRAL_START ? "\\u".concat(codepointHex.padStart(4, '0')) : "\\U".concat(codepointHex);
};
// Characters that would create issues when printed are escaped using the \u or \U notation.
// Those include control characters and newlines.
// The \u and \U notation is Bash specific, but there is no way to do this in a shell-agnostic way.
// Some shells do not even have a way to print those characters in an escaped fashion.
// Therefore, we prioritize printing those safely, instead of allowing those to be copy-pasted.
// List of Unicode character categories: https://www.fileformat.info/info/unicode/category/index.htm
const getSpecialCharRegExp = ()=>{
    try {
        // This throws when using Node.js without ICU support.
        // When using a RegExp literal, this would throw at parsing-time, instead of runtime.
        // eslint-disable-next-line prefer-regex-literals
        return new RegExp('\\p{Separator}|\\p{Other}', 'gu');
    } catch (e) {
        // Similar to the above RegExp, but works even when Node.js has been built without ICU support.
        // Unlike the above RegExp, it only covers whitespaces and C0/C1 control characters.
        // It does not cover some edge cases, such as Unicode reserved characters.
        // See https://github.com/sindresorhus/execa/issues/1143
        // eslint-disable-next-line no-control-regex
        return /[\s\u0000-\u001F\u007F-\u009F\u00AD]/g;
    }
};
const SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();
// Accepted by $'...' in Bash.
// Exclude \a \e \v which are accepted in Bash but not in JavaScript (except \v) and JSON.
const COMMON_ESCAPES = {
    ' ': ' ',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t'
};
// Up until that codepoint, \u notation can be used instead of \U
const ASTRAL_START = 65_535;
// Some characters are shell-specific, i.e. need to be escaped when the command is copy-pasted then run.
// Escaping is shell-specific. We cannot know which shell is used: `process.platform` detection is not enough.
// For example, Windows users could be using `cmd.exe`, Powershell or Bash for Windows which all use different escaping.
// We use '...' on Unix, which is POSIX shell compliant and escape all characters but ' so this is fairly safe.
// On Windows, we assume cmd.exe is used and escape with "...", which also works with Powershell.
const quoteString = (escapedArgument)=>{
    if (NO_ESCAPE_REGEXP.test(escapedArgument)) {
        return escapedArgument;
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["platform"] === 'win32' ? '"'.concat(escapedArgument.replaceAll('"', '""'), '"') : "'".concat(escapedArgument.replaceAll('\'', '\'\\\'\''), "'");
};
const NO_ESCAPE_REGEXP = /^[\w./-]+$/;
}),
"[project]/node_modules/execa/lib/verbose/default.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "defaultVerboseFunction",
    ()=>defaultVerboseFunction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$figures$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/figures/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/yoctocolors/base.js [app-client] (ecmascript)");
;
;
const defaultVerboseFunction = (param)=>{
    let { type, message, timestamp, piped, commandId, result: { failed = false } = {}, options: { reject = true } } = param;
    const timestampString = serializeTimestamp(timestamp);
    const icon = ICONS[type]({
        failed,
        reject,
        piped
    });
    const color = COLORS[type]({
        reject
    });
    return "".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gray"])("[".concat(timestampString, "]")), " ").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gray"])("[".concat(commandId, "]")), " ").concat(color(icon), " ").concat(color(message));
};
// Prepending the timestamp allows debugging the slow paths of a subprocess
const serializeTimestamp = (timestamp)=>"".concat(padField(timestamp.getHours(), 2), ":").concat(padField(timestamp.getMinutes(), 2), ":").concat(padField(timestamp.getSeconds(), 2), ".").concat(padField(timestamp.getMilliseconds(), 3));
const padField = (field, padding)=>String(field).padStart(padding, '0');
const getFinalIcon = (param)=>{
    let { failed, reject } = param;
    if (!failed) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$figures$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].tick;
    }
    return reject ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$figures$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cross : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$figures$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].warning;
};
const ICONS = {
    command: (param)=>{
        let { piped } = param;
        return piped ? '|' : '$';
    },
    output: ()=>' ',
    ipc: ()=>'*',
    error: getFinalIcon,
    duration: getFinalIcon
};
const identity = (string)=>string;
const COLORS = {
    command: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bold"],
    output: ()=>identity,
    ipc: ()=>identity,
    error: (param)=>{
        let { reject } = param;
        return reject ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["redBright"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["yellowBright"];
    },
    duration: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yoctocolors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gray"]
};
}),
"[project]/node_modules/execa/lib/verbose/custom.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "applyVerboseOnLines",
    ()=>applyVerboseOnLines
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-client] (ecmascript)");
;
const applyVerboseOnLines = (printedLines, verboseInfo, fdNumber)=>{
    const verboseFunction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getVerboseFunction"])(verboseInfo, fdNumber);
    return printedLines.map((param)=>{
        let { verboseLine, verboseObject } = param;
        return applyVerboseFunction(verboseLine, verboseObject, verboseFunction);
    }).filter((printedLine)=>printedLine !== undefined).map((printedLine)=>appendNewline(printedLine)).join('');
};
const applyVerboseFunction = (verboseLine, verboseObject, verboseFunction)=>{
    if (verboseFunction === undefined) {
        return verboseLine;
    }
    const printedLine = verboseFunction(verboseLine, verboseObject);
    if (typeof printedLine === 'string') {
        return printedLine;
    }
};
const appendNewline = (printedLine)=>printedLine.endsWith('\n') ? printedLine : "".concat(printedLine, "\n");
}),
"[project]/node_modules/execa/lib/verbose/log.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "serializeVerboseMessage",
    ()=>serializeVerboseMessage,
    "verboseLog",
    ()=>verboseLog
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/escape.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/default.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$custom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/custom.js [app-client] (ecmascript)");
;
;
;
;
const verboseLog = (param)=>{
    let { type, verboseMessage, fdNumber, verboseInfo, result } = param;
    const verboseObject = getVerboseObject({
        type,
        result,
        verboseInfo
    });
    const printedLines = getPrintedLines(verboseMessage, verboseObject);
    const finalLines = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$custom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyVerboseOnLines"])(printedLines, verboseInfo, fdNumber);
    if (finalLines !== '') {
        console.warn(finalLines.slice(0, -1));
    }
};
const getVerboseObject = (param)=>{
    let { type, result, verboseInfo: { escapedCommand, commandId, rawOptions: { piped = false, ...options } } } = param;
    return {
        type,
        escapedCommand,
        commandId: "".concat(commandId),
        timestamp: new Date(),
        piped,
        result,
        options
    };
};
const getPrintedLines = (verboseMessage, verboseObject)=>verboseMessage.split('\n').map((message)=>getPrintedLine({
            ...verboseObject,
            message
        }));
const getPrintedLine = (verboseObject)=>{
    const verboseLine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultVerboseFunction"])(verboseObject);
    return {
        verboseLine,
        verboseObject
    };
};
const serializeVerboseMessage = (message)=>{
    const messageString = typeof message === 'string' ? message : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inspect"])(message);
    const escapedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["escapeLines"])(messageString);
    return escapedMessage.replaceAll('\t', ' '.repeat(TAB_SIZE));
};
// Same as `util.inspect()`
const TAB_SIZE = 2;
}),
"[project]/node_modules/execa/lib/verbose/start.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logCommand",
    ()=>logCommand
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/log.js [app-client] (ecmascript)");
;
;
const logCommand = (escapedCommand, verboseInfo)=>{
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isVerbose"])(verboseInfo)) {
        return;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verboseLog"])({
        type: 'command',
        verboseMessage: escapedCommand,
        verboseInfo
    });
};
}),
"[project]/node_modules/execa/lib/verbose/info.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getVerboseInfo",
    ()=>getVerboseInfo
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-client] (ecmascript)");
;
const getVerboseInfo = (verbose, escapedCommand, rawOptions)=>{
    validateVerbose(verbose);
    const commandId = getCommandId(verbose);
    return {
        verbose,
        escapedCommand,
        commandId,
        rawOptions
    };
};
const getCommandId = (verbose)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isVerbose"])({
        verbose
    }) ? COMMAND_ID++ : undefined;
// Prepending the `pid` is useful when multiple commands print their output at the same time.
// However, we cannot use the real PID since this is not available with `child_process.spawnSync()`.
// Also, we cannot use the real PID if we want to print it before `child_process.spawn()` is run.
// As a pro, it is shorter than a normal PID and never re-uses the same id.
// As a con, it cannot be used to send signals.
let COMMAND_ID = 0n;
const validateVerbose = (verbose)=>{
    for (const fdVerbose of verbose){
        if (fdVerbose === false) {
            throw new TypeError('The "verbose: false" option was renamed to "verbose: \'none\'".');
        }
        if (fdVerbose === true) {
            throw new TypeError('The "verbose: true" option was renamed to "verbose: \'short\'".');
        }
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERBOSE_VALUES"].includes(fdVerbose) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isVerboseFunction"])(fdVerbose)) {
            const allowedValues = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERBOSE_VALUES"].map((allowedValue)=>"'".concat(allowedValue, "'")).join(', ');
            throw new TypeError('The "verbose" option must not be '.concat(fdVerbose, ". Allowed values are: ").concat(allowedValues, " or a function."));
        }
    }
};
}),
"[project]/node_modules/execa/lib/return/duration.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getDurationMs",
    ()=>getDurationMs,
    "getStartTime",
    ()=>getStartTime
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
;
const getStartTime = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hrtime"].bigint();
const getDurationMs = (startTime)=>Number(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hrtime"].bigint() - startTime) / 1e6;
}),
"[project]/node_modules/execa/lib/arguments/command.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleCommand",
    ()=>handleCommand
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$start$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/start.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/duration.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/escape.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-client] (ecmascript)");
;
;
;
;
;
const handleCommand = (filePath, rawArguments, rawOptions)=>{
    const startTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStartTime"])();
    const { command, escapedCommand } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinCommand"])(filePath, rawArguments);
    const verbose = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeFdSpecificOption"])(rawOptions, 'verbose');
    const verboseInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getVerboseInfo"])(verbose, escapedCommand, {
        ...rawOptions
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$start$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logCommand"])(escapedCommand, verboseInfo);
    return {
        command,
        escapedCommand,
        startTime,
        verboseInfo
    };
};
}),
"[project]/node_modules/execa/lib/return/final-error.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// When the subprocess fails, this is the error instance being returned.
// If another error instance is being thrown, it is kept as `error.cause`.
__turbopack_context__.s([
    "DiscardedError",
    ()=>DiscardedError,
    "ExecaError",
    ()=>ExecaError,
    "ExecaSyncError",
    ()=>ExecaSyncError,
    "getFinalError",
    ()=>getFinalError,
    "isErrorInstance",
    ()=>isErrorInstance,
    "isExecaError",
    ()=>isExecaError
]);
const getFinalError = (originalError, message, isSync)=>{
    const ErrorClass = isSync ? ExecaSyncError : ExecaError;
    const options = originalError instanceof DiscardedError ? {} : {
        cause: originalError
    };
    return new ErrorClass(message, options);
};
class DiscardedError extends Error {
}
// Proper way to set `error.name`: it should be inherited and non-enumerable
const setErrorName = (ErrorClass, value)=>{
    Object.defineProperty(ErrorClass.prototype, 'name', {
        value,
        writable: true,
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ErrorClass.prototype, execaErrorSymbol, {
        value: true,
        writable: false,
        enumerable: false,
        configurable: false
    });
};
const isExecaError = (error)=>isErrorInstance(error) && execaErrorSymbol in error;
const execaErrorSymbol = Symbol('isExecaError');
const isErrorInstance = (value)=>Object.prototype.toString.call(value) === '[object Error]';
class ExecaError extends Error {
}
setErrorName(ExecaError, ExecaError.name);
class ExecaSyncError extends Error {
}
setErrorName(ExecaSyncError, ExecaSyncError.name);
}),
"[project]/node_modules/execa/lib/terminate/signal.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getSignalDescription",
    ()=>getSignalDescription,
    "normalizeKillSignal",
    ()=>normalizeKillSignal,
    "normalizeSignalArgument",
    ()=>normalizeSignalArgument
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$os$2d$browserify$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/os-browserify/browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$human$2d$signals$2f$build$2f$src$2f$main$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/human-signals/build/src/main.js [app-client] (ecmascript)");
;
;
const normalizeKillSignal = (killSignal)=>{
    const optionName = 'option `killSignal`';
    if (killSignal === 0) {
        throw new TypeError("Invalid ".concat(optionName, ": 0 cannot be used."));
    }
    return normalizeSignal(killSignal, optionName);
};
const normalizeSignalArgument = (signal)=>signal === 0 ? signal : normalizeSignal(signal, '`subprocess.kill()`\'s argument');
const normalizeSignal = (signalNameOrInteger, optionName)=>{
    if (Number.isInteger(signalNameOrInteger)) {
        return normalizeSignalInteger(signalNameOrInteger, optionName);
    }
    if (typeof signalNameOrInteger === 'string') {
        return normalizeSignalName(signalNameOrInteger, optionName);
    }
    throw new TypeError("Invalid ".concat(optionName, " ").concat(String(signalNameOrInteger), ": it must be a string or an integer.\n").concat(getAvailableSignals()));
};
const normalizeSignalInteger = (signalInteger, optionName)=>{
    if (signalsIntegerToName.has(signalInteger)) {
        return signalsIntegerToName.get(signalInteger);
    }
    throw new TypeError("Invalid ".concat(optionName, " ").concat(signalInteger, ": this signal integer does not exist.\n").concat(getAvailableSignals()));
};
const getSignalsIntegerToName = ()=>new Map(Object.entries(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$os$2d$browserify$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].signals).reverse().map((param)=>{
        let [signalName, signalInteger] = param;
        return [
            signalInteger,
            signalName
        ];
    }));
const signalsIntegerToName = getSignalsIntegerToName();
const normalizeSignalName = (signalName, optionName)=>{
    if (signalName in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$os$2d$browserify$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].signals) {
        return signalName;
    }
    if (signalName.toUpperCase() in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$os$2d$browserify$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].signals) {
        throw new TypeError("Invalid ".concat(optionName, " '").concat(signalName, "': please rename it to '").concat(signalName.toUpperCase(), "'."));
    }
    throw new TypeError("Invalid ".concat(optionName, " '").concat(signalName, "': this signal name does not exist.\n").concat(getAvailableSignals()));
};
const getAvailableSignals = ()=>"Available signal names: ".concat(getAvailableSignalNames(), ".\nAvailable signal numbers: ").concat(getAvailableSignalIntegers(), ".");
const getAvailableSignalNames = ()=>Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$os$2d$browserify$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].signals).sort().map((signalName)=>"'".concat(signalName, "'")).join(', ');
const getAvailableSignalIntegers = ()=>[
        ...new Set(Object.values(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$os$2d$browserify$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].signals).sort((signalInteger, signalIntegerTwo)=>signalInteger - signalIntegerTwo))
    ].join(', ');
const getSignalDescription = (signal)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$human$2d$signals$2f$build$2f$src$2f$main$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["signalsByName"][signal].description;
}),
"[project]/node_modules/execa/lib/terminate/kill.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/terminate/kill.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:timers/promises)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/terminate/kill.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:timers/promises)");

}}),
"[project]/node_modules/execa/lib/utils/abort-signal.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "onAbortedSignal",
    ()=>onAbortedSignal
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
;
const onAbortedSignal = async (mainSignal, stopSignal)=>{
    if (!mainSignal.aborted) {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(mainSignal, 'abort', {
            signal: stopSignal
        });
    }
};
}),
"[project]/node_modules/execa/lib/terminate/cancel.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "throwOnCancel",
    ()=>throwOnCancel,
    "validateCancelSignal",
    ()=>validateCancelSignal
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$abort$2d$signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/abort-signal.js [app-client] (ecmascript)");
;
const validateCancelSignal = (param)=>{
    let { cancelSignal } = param;
    if (cancelSignal !== undefined && Object.prototype.toString.call(cancelSignal) !== '[object AbortSignal]') {
        throw new Error("The `cancelSignal` option must be an AbortSignal: ".concat(String(cancelSignal)));
    }
};
const throwOnCancel = (param)=>{
    let { subprocess, cancelSignal, gracefulCancel, context, controller } = param;
    return cancelSignal === undefined || gracefulCancel ? [] : [
        terminateOnCancel(subprocess, cancelSignal, context, controller)
    ];
};
const terminateOnCancel = async (subprocess, cancelSignal, context, param)=>{
    let { signal } = param;
    var _context;
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$abort$2d$signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onAbortedSignal"])(cancelSignal, signal);
    var _terminationReason;
    (_terminationReason = (_context = context).terminationReason) !== null && _terminationReason !== void 0 ? _terminationReason : _context.terminationReason = 'cancel';
    subprocess.kill();
    throw cancelSignal.reason;
};
}),
"[project]/node_modules/execa/lib/ipc/validation.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Validate the IPC channel is connected before receiving/sending messages
__turbopack_context__.s([
    "disconnect",
    ()=>disconnect,
    "getAbortDisconnectError",
    ()=>getAbortDisconnectError,
    "getStrictResponseError",
    ()=>getStrictResponseError,
    "handleEpipeError",
    ()=>handleEpipeError,
    "handleSerializationError",
    ()=>handleSerializationError,
    "throwOnEarlyDisconnect",
    ()=>throwOnEarlyDisconnect,
    "throwOnMissingParent",
    ()=>throwOnMissingParent,
    "throwOnMissingStrict",
    ()=>throwOnMissingStrict,
    "throwOnStrictDeadlockError",
    ()=>throwOnStrictDeadlockError,
    "throwOnStrictDisconnect",
    ()=>throwOnStrictDisconnect,
    "validateConnection",
    ()=>validateConnection,
    "validateIpcMethod",
    ()=>validateIpcMethod
]);
const validateIpcMethod = (param)=>{
    let { methodName, isSubprocess, ipc, isConnected } = param;
    validateIpcOption(methodName, isSubprocess, ipc);
    validateConnection(methodName, isSubprocess, isConnected);
};
// Better error message when forgetting to set `ipc: true` and using the IPC methods
const validateIpcOption = (methodName, isSubprocess, ipc)=>{
    if (!ipc) {
        throw new Error("".concat(getMethodName(methodName, isSubprocess), " can only be used if the `ipc` option is `true`."));
    }
};
const validateConnection = (methodName, isSubprocess, isConnected)=>{
    if (!isConnected) {
        throw new Error("".concat(getMethodName(methodName, isSubprocess), " cannot be used: the ").concat(getOtherProcessName(isSubprocess), " has already exited or disconnected."));
    }
};
const throwOnEarlyDisconnect = (isSubprocess)=>{
    throw new Error("".concat(getMethodName('getOneMessage', isSubprocess), " could not complete: the ").concat(getOtherProcessName(isSubprocess), " exited or disconnected."));
};
const throwOnStrictDeadlockError = (isSubprocess)=>{
    throw new Error("".concat(getMethodName('sendMessage', isSubprocess), " failed: the ").concat(getOtherProcessName(isSubprocess), " is sending a message too, instead of listening to incoming messages.\nThis can be fixed by both sending a message and listening to incoming messages at the same time:\n\nconst [receivedMessage] = await Promise.all([\n	").concat(getMethodName('getOneMessage', isSubprocess), ",\n	").concat(getMethodName('sendMessage', isSubprocess, 'message, {strict: true}'), ",\n]);"));
};
const getStrictResponseError = (error, isSubprocess)=>new Error("".concat(getMethodName('sendMessage', isSubprocess), " failed when sending an acknowledgment response to the ").concat(getOtherProcessName(isSubprocess), "."), {
        cause: error
    });
const throwOnMissingStrict = (isSubprocess)=>{
    throw new Error("".concat(getMethodName('sendMessage', isSubprocess), " failed: the ").concat(getOtherProcessName(isSubprocess), " is not listening to incoming messages."));
};
const throwOnStrictDisconnect = (isSubprocess)=>{
    throw new Error("".concat(getMethodName('sendMessage', isSubprocess), " failed: the ").concat(getOtherProcessName(isSubprocess), " exited without listening to incoming messages."));
};
const getAbortDisconnectError = ()=>new Error("`cancelSignal` aborted: the ".concat(getOtherProcessName(true), " disconnected."));
const throwOnMissingParent = ()=>{
    throw new Error('`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.');
};
const handleEpipeError = (param)=>{
    let { error, methodName, isSubprocess } = param;
    if (error.code === 'EPIPE') {
        throw new Error("".concat(getMethodName(methodName, isSubprocess), " cannot be used: the ").concat(getOtherProcessName(isSubprocess), " is disconnecting."), {
            cause: error
        });
    }
};
const handleSerializationError = (param)=>{
    let { error, methodName, isSubprocess, message } = param;
    if (isSerializationError(error)) {
        throw new Error("".concat(getMethodName(methodName, isSubprocess), "'s argument type is invalid: the message cannot be serialized: ").concat(String(message), "."), {
            cause: error
        });
    }
};
const isSerializationError = (param)=>{
    let { code, message } = param;
    return SERIALIZATION_ERROR_CODES.has(code) || SERIALIZATION_ERROR_MESSAGES.some((serializationErrorMessage)=>message.includes(serializationErrorMessage));
};
// `error.code` set by Node.js when it failed to serialize the message
const SERIALIZATION_ERROR_CODES = new Set([
    // Message is `undefined`
    'ERR_MISSING_ARGS',
    // Message is a function, a bigint, a symbol
    'ERR_INVALID_ARG_TYPE'
]);
// `error.message` set by Node.js when it failed to serialize the message
const SERIALIZATION_ERROR_MESSAGES = [
    // Message is a promise or a proxy, with `serialization: 'advanced'`
    'could not be cloned',
    // Message has cycles, with `serialization: 'json'`
    'circular structure',
    // Message has cycles inside toJSON(), with `serialization: 'json'`
    'call stack size exceeded'
];
const getMethodName = function(methodName, isSubprocess) {
    let parameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '';
    return methodName === 'cancelSignal' ? '`cancelSignal`\'s `controller.abort()`' : "".concat(getNamespaceName(isSubprocess)).concat(methodName, "(").concat(parameters, ")");
};
const getNamespaceName = (isSubprocess)=>isSubprocess ? '' : 'subprocess.';
const getOtherProcessName = (isSubprocess)=>isSubprocess ? 'parent process' : 'subprocess';
const disconnect = (anyProcess)=>{
    if (anyProcess.connected) {
        anyProcess.disconnect();
    }
};
}),
"[project]/node_modules/execa/lib/utils/deferred.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createDeferred",
    ()=>createDeferred
]);
const createDeferred = ()=>{
    const methods = {};
    const promise = new Promise((resolve, reject)=>{
        Object.assign(methods, {
            resolve,
            reject
        });
    });
    return Object.assign(promise, methods);
};
}),
"[project]/node_modules/execa/lib/arguments/fd-options.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SUBPROCESS_OPTIONS",
    ()=>SUBPROCESS_OPTIONS,
    "getFromStream",
    ()=>getFromStream,
    "getToStream",
    ()=>getToStream,
    "serializeOptionValue",
    ()=>serializeOptionValue
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-client] (ecmascript)");
;
const getToStream = function(destination) {
    let to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'stdin';
    const isWritable = true;
    const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(destination);
    const fdNumber = getFdNumber(fileDescriptors, to, isWritable);
    const destinationStream = destination.stdio[fdNumber];
    if (destinationStream === null) {
        throw new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));
    }
    return destinationStream;
};
const getFromStream = function(source) {
    let from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'stdout';
    const isWritable = false;
    const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
    const fdNumber = getFdNumber(fileDescriptors, from, isWritable);
    const sourceStream = fdNumber === 'all' ? source.all : source.stdio[fdNumber];
    if (sourceStream === null || sourceStream === undefined) {
        throw new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));
    }
    return sourceStream;
};
const SUBPROCESS_OPTIONS = new WeakMap();
const getFdNumber = (fileDescriptors, fdName, isWritable)=>{
    const fdNumber = parseFdNumber(fdName, isWritable);
    validateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);
    return fdNumber;
};
const parseFdNumber = (fdName, isWritable)=>{
    const fdNumber = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseFd"])(fdName);
    if (fdNumber !== undefined) {
        return fdNumber;
    }
    const { validOptions, defaultValue } = isWritable ? {
        validOptions: '"stdin"',
        defaultValue: 'stdin'
    } : {
        validOptions: '"stdout", "stderr", "all"',
        defaultValue: 'stdout'
    };
    throw new TypeError('"'.concat(getOptionName(isWritable), '" must not be "').concat(fdName, '".\nIt must be ').concat(validOptions, ' or "fd3", "fd4" (and so on).\nIt is optional and defaults to "').concat(defaultValue, '".'));
};
const validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors)=>{
    const fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];
    if (fileDescriptor === undefined) {
        throw new TypeError('"'.concat(getOptionName(isWritable), '" must not be ').concat(fdName, '. That file descriptor does not exist.\nPlease set the "stdio" option to ensure that file descriptor exists.'));
    }
    if (fileDescriptor.direction === 'input' && !isWritable) {
        throw new TypeError('"'.concat(getOptionName(isWritable), '" must not be ').concat(fdName, ". It must be a readable stream, not writable."));
    }
    if (fileDescriptor.direction !== 'input' && isWritable) {
        throw new TypeError('"'.concat(getOptionName(isWritable), '" must not be ').concat(fdName, ". It must be a writable stream, not readable."));
    }
};
const getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable)=>{
    if (fdNumber === 'all' && !options.all) {
        return 'The "all" option must be true to use "from: \'all\'".';
    }
    const { optionName, optionValue } = getInvalidStdioOption(fdNumber, options);
    return 'The "'.concat(optionName, ": ").concat(serializeOptionValue(optionValue), '" option is incompatible with using "').concat(getOptionName(isWritable), ": ").concat(serializeOptionValue(fdName), '".\nPlease set this option with "pipe" instead.');
};
const getInvalidStdioOption = (fdNumber, param)=>{
    let { stdin, stdout, stderr, stdio } = param;
    const usedDescriptor = getUsedDescriptor(fdNumber);
    if (usedDescriptor === 0 && stdin !== undefined) {
        return {
            optionName: 'stdin',
            optionValue: stdin
        };
    }
    if (usedDescriptor === 1 && stdout !== undefined) {
        return {
            optionName: 'stdout',
            optionValue: stdout
        };
    }
    if (usedDescriptor === 2 && stderr !== undefined) {
        return {
            optionName: 'stderr',
            optionValue: stderr
        };
    }
    return {
        optionName: "stdio[".concat(usedDescriptor, "]"),
        optionValue: stdio[usedDescriptor]
    };
};
const getUsedDescriptor = (fdNumber)=>fdNumber === 'all' ? 1 : fdNumber;
const getOptionName = (isWritable)=>isWritable ? 'to' : 'from';
const serializeOptionValue = (value)=>{
    if (typeof value === 'string') {
        return "'".concat(value, "'");
    }
    return typeof value === 'number' ? "".concat(value) : 'Stream';
};
}),
"[project]/node_modules/execa/lib/utils/max-listeners.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "incrementMaxListeners",
    ()=>incrementMaxListeners
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
;
const incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal)=>{
    const maxListeners = eventEmitter.getMaxListeners();
    if (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {
        return;
    }
    eventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addAbortListener"])(signal, ()=>{
        eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);
    });
};
}),
"[project]/node_modules/execa/lib/ipc/reference.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// By default, Node.js keeps the subprocess alive while it has a `message` or `disconnect` listener.
// We replicate the same logic for the events that we proxy.
// This ensures the subprocess is kept alive while `getOneMessage()` and `getEachMessage()` are ongoing.
// This is not a problem with `sendMessage()` since Node.js handles that method automatically.
// We do not use `anyProcess.channel.ref()` since this would prevent the automatic `.channel.refCounted()` Node.js is doing.
// We keep a reference to `anyProcess.channel` since it might be `null` while `getOneMessage()` or `getEachMessage()` is still processing debounced messages.
// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L547
__turbopack_context__.s([
    "addReference",
    ()=>addReference,
    "redoAddedReferences",
    ()=>redoAddedReferences,
    "removeReference",
    ()=>removeReference,
    "undoAddedReferences",
    ()=>undoAddedReferences
]);
const addReference = (channel, reference)=>{
    if (reference) {
        addReferenceCount(channel);
    }
};
const addReferenceCount = (channel)=>{
    channel.refCounted();
};
const removeReference = (channel, reference)=>{
    if (reference) {
        removeReferenceCount(channel);
    }
};
const removeReferenceCount = (channel)=>{
    channel.unrefCounted();
};
const undoAddedReferences = (channel, isSubprocess)=>{
    if (isSubprocess) {
        removeReferenceCount(channel);
        removeReferenceCount(channel);
    }
};
const redoAddedReferences = (channel, isSubprocess)=>{
    if (isSubprocess) {
        addReferenceCount(channel);
        addReferenceCount(channel);
    }
};
}),
"[project]/node_modules/execa/lib/ipc/incoming.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/ipc/incoming.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:timers/promises)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/ipc/incoming.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:timers/promises)");

}}),
"[project]/node_modules/execa/lib/ipc/forward.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getIpcEmitter",
    ()=>getIpcEmitter,
    "isConnected",
    ()=>isConnected
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$incoming$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/incoming.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/reference.js [app-client] (ecmascript)");
;
;
;
const getIpcEmitter = (anyProcess, channel, isSubprocess)=>{
    if (IPC_EMITTERS.has(anyProcess)) {
        return IPC_EMITTERS.get(anyProcess);
    }
    // Use an `EventEmitter`, like the `process` that is being proxied
    // eslint-disable-next-line unicorn/prefer-event-target
    const ipcEmitter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"]();
    ipcEmitter.connected = true;
    IPC_EMITTERS.set(anyProcess, ipcEmitter);
    forwardEvents({
        ipcEmitter,
        anyProcess,
        channel,
        isSubprocess
    });
    return ipcEmitter;
};
const IPC_EMITTERS = new WeakMap();
// The `message` and `disconnect` events are buffered in the subprocess until the first listener is setup.
// However, unbuffering happens after one tick, so this give enough time for the caller to setup the listener on the proxy emitter first.
// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L721
const forwardEvents = (param)=>{
    let { ipcEmitter, anyProcess, channel, isSubprocess } = param;
    const boundOnMessage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$incoming$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onMessage"].bind(undefined, {
        anyProcess,
        channel,
        isSubprocess,
        ipcEmitter
    });
    anyProcess.on('message', boundOnMessage);
    anyProcess.once('disconnect', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$incoming$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onDisconnect"].bind(undefined, {
        anyProcess,
        channel,
        isSubprocess,
        ipcEmitter,
        boundOnMessage
    }));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undoAddedReferences"])(channel, isSubprocess);
};
const isConnected = (anyProcess)=>{
    const ipcEmitter = IPC_EMITTERS.get(anyProcess);
    return ipcEmitter === undefined ? anyProcess.channel !== null : ipcEmitter.connected;
};
}),
"[project]/node_modules/execa/lib/ipc/strict.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleSendStrict",
    ()=>handleSendStrict,
    "handleStrictRequest",
    ()=>handleStrictRequest,
    "handleStrictResponse",
    ()=>handleStrictResponse,
    "validateStrictDeadlock",
    ()=>validateStrictDeadlock,
    "waitForStrictResponse",
    ()=>waitForStrictResponse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/deferred.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/max-listeners.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$send$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/send.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/validation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/forward.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/outgoing.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const handleSendStrict = (param)=>{
    let { anyProcess, channel, isSubprocess, message, strict } = param;
    if (!strict) {
        return message;
    }
    const ipcEmitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getIpcEmitter"])(anyProcess, channel, isSubprocess);
    const hasListeners = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasMessageListeners"])(anyProcess, ipcEmitter);
    return {
        id: count++,
        type: REQUEST_TYPE,
        message,
        hasListeners
    };
};
let count = 0n;
const validateStrictDeadlock = (outgoingMessages, wrappedMessage)=>{
    if ((wrappedMessage === null || wrappedMessage === void 0 ? void 0 : wrappedMessage.type) !== REQUEST_TYPE || wrappedMessage.hasListeners) {
        return;
    }
    for (const { id } of outgoingMessages){
        if (id !== undefined) {
            STRICT_RESPONSES[id].resolve({
                isDeadlock: true,
                hasListeners: false
            });
        }
    }
};
const handleStrictRequest = async (param)=>{
    let { wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter } = param;
    if ((wrappedMessage === null || wrappedMessage === void 0 ? void 0 : wrappedMessage.type) !== REQUEST_TYPE || !anyProcess.connected) {
        return wrappedMessage;
    }
    const { id, message } = wrappedMessage;
    const response = {
        id,
        type: RESPONSE_TYPE,
        message: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasMessageListeners"])(anyProcess, ipcEmitter)
    };
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$send$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sendMessage"])({
            anyProcess,
            channel,
            isSubprocess,
            ipc: true
        }, response);
    } catch (error) {
        ipcEmitter.emit('strict:error', error);
    }
    return message;
};
const handleStrictResponse = (wrappedMessage)=>{
    var _STRICT_RESPONSES_id;
    if ((wrappedMessage === null || wrappedMessage === void 0 ? void 0 : wrappedMessage.type) !== RESPONSE_TYPE) {
        return false;
    }
    const { id, message: hasListeners } = wrappedMessage;
    (_STRICT_RESPONSES_id = STRICT_RESPONSES[id]) === null || _STRICT_RESPONSES_id === void 0 ? void 0 : _STRICT_RESPONSES_id.resolve({
        isDeadlock: false,
        hasListeners
    });
    return true;
};
const waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess)=>{
    if ((wrappedMessage === null || wrappedMessage === void 0 ? void 0 : wrappedMessage.type) !== REQUEST_TYPE) {
        return;
    }
    const deferred = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDeferred"])();
    STRICT_RESPONSES[wrappedMessage.id] = deferred;
    const controller = new AbortController();
    try {
        const { isDeadlock, hasListeners } = await Promise.race([
            deferred,
            throwOnDisconnect(anyProcess, isSubprocess, controller)
        ]);
        if (isDeadlock) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwOnStrictDeadlockError"])(isSubprocess);
        }
        if (!hasListeners) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwOnMissingStrict"])(isSubprocess);
        }
    } finally{
        controller.abort();
        delete STRICT_RESPONSES[wrappedMessage.id];
    }
};
const STRICT_RESPONSES = {};
const throwOnDisconnect = async (anyProcess, isSubprocess, param)=>{
    let { signal } = param;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["incrementMaxListeners"])(anyProcess, 1, signal);
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(anyProcess, 'disconnect', {
        signal
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwOnStrictDisconnect"])(isSubprocess);
};
const REQUEST_TYPE = 'execa:ipc:request';
const RESPONSE_TYPE = 'execa:ipc:response';
}),
"[project]/node_modules/execa/lib/ipc/outgoing.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "endSendMessage",
    ()=>endSendMessage,
    "hasMessageListeners",
    ()=>hasMessageListeners,
    "startSendMessage",
    ()=>startSendMessage,
    "waitForOutgoingMessages",
    ()=>waitForOutgoingMessages
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/deferred.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/strict.js [app-client] (ecmascript)");
;
;
;
;
const startSendMessage = (anyProcess, wrappedMessage, strict)=>{
    if (!OUTGOING_MESSAGES.has(anyProcess)) {
        OUTGOING_MESSAGES.set(anyProcess, new Set());
    }
    const outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);
    const onMessageSent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDeferred"])();
    const id = strict ? wrappedMessage.id : undefined;
    const outgoingMessage = {
        onMessageSent,
        id
    };
    outgoingMessages.add(outgoingMessage);
    return {
        outgoingMessages,
        outgoingMessage
    };
};
const endSendMessage = (param)=>{
    let { outgoingMessages, outgoingMessage } = param;
    outgoingMessages.delete(outgoingMessage);
    outgoingMessage.onMessageSent.resolve();
};
const waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage)=>{
    var _OUTGOING_MESSAGES_get;
    while(!hasMessageListeners(anyProcess, ipcEmitter) && ((_OUTGOING_MESSAGES_get = OUTGOING_MESSAGES.get(anyProcess)) === null || _OUTGOING_MESSAGES_get === void 0 ? void 0 : _OUTGOING_MESSAGES_get.size) > 0){
        const outgoingMessages = [
            ...OUTGOING_MESSAGES.get(anyProcess)
        ];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateStrictDeadlock"])(outgoingMessages, wrappedMessage);
        // eslint-disable-next-line no-await-in-loop
        await Promise.all(outgoingMessages.map((param)=>{
            let { onMessageSent } = param;
            return onMessageSent;
        }));
    }
};
const OUTGOING_MESSAGES = new WeakMap();
const hasMessageListeners = (anyProcess, ipcEmitter)=>ipcEmitter.listenerCount('message') > getMinListenerCount(anyProcess);
// When `buffer` is `false`, we set up a `message` listener that should be ignored.
// That listener is only meant to intercept `strict` acknowledgement responses.
const getMinListenerCount = (anyProcess)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUBPROCESS_OPTIONS"].has(anyProcess) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFdSpecificValue"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUBPROCESS_OPTIONS"].get(anyProcess).options.buffer, 'ipc') ? 1 : 0;
}),
"[project]/node_modules/execa/lib/ipc/send.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sendMessage",
    ()=>sendMessage,
    "sendOneMessage",
    ()=>sendOneMessage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/validation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/outgoing.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/strict.js [app-client] (ecmascript)");
;
;
;
;
const sendMessage = function(param, message) {
    let { anyProcess, channel, isSubprocess, ipc } = param, { strict = false } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const methodName = 'sendMessage';
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIpcMethod"])({
        methodName,
        isSubprocess,
        ipc,
        isConnected: anyProcess.connected
    });
    return sendMessageAsync({
        anyProcess,
        channel,
        methodName,
        isSubprocess,
        message,
        strict
    });
};
const sendMessageAsync = async (param)=>{
    let { anyProcess, channel, methodName, isSubprocess, message, strict } = param;
    const wrappedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["handleSendStrict"])({
        anyProcess,
        channel,
        isSubprocess,
        message,
        strict
    });
    const outgoingMessagesState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["startSendMessage"])(anyProcess, wrappedMessage, strict);
    try {
        await sendOneMessage({
            anyProcess,
            methodName,
            isSubprocess,
            wrappedMessage,
            message
        });
    } catch (error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["disconnect"])(anyProcess);
        throw error;
    } finally{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$outgoing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["endSendMessage"])(outgoingMessagesState);
    }
};
const sendOneMessage = async (param)=>{
    let { anyProcess, methodName, isSubprocess, wrappedMessage, message } = param;
    const sendMethod = getSendMethod(anyProcess);
    try {
        await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$strict$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForStrictResponse"])(wrappedMessage, anyProcess, isSubprocess),
            sendMethod(wrappedMessage)
        ]);
    } catch (error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["handleEpipeError"])({
            error,
            methodName,
            isSubprocess
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["handleSerializationError"])({
            error,
            methodName,
            isSubprocess,
            message
        });
        throw error;
    }
};
// [sub]process.send() promisified, memoized
const getSendMethod = (anyProcess)=>{
    if (PROCESS_SEND_METHODS.has(anyProcess)) {
        return PROCESS_SEND_METHODS.get(anyProcess);
    }
    const sendMethod = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["promisify"])(anyProcess.send.bind(anyProcess));
    PROCESS_SEND_METHODS.set(anyProcess, sendMethod);
    return sendMethod;
};
const PROCESS_SEND_METHODS = new WeakMap();
}),
"[project]/node_modules/execa/lib/ipc/graceful.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/ipc/graceful.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:timers/promises)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/ipc/graceful.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:timers/promises)");

}}),
"[project]/node_modules/execa/lib/terminate/graceful.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "throwOnGracefulCancel",
    ()=>throwOnGracefulCancel,
    "validateGracefulCancel",
    ()=>validateGracefulCancel
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$abort$2d$signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/abort-signal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/graceful.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$kill$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/kill.js [app-client] (ecmascript)");
;
;
;
const validateGracefulCancel = (param)=>{
    let { gracefulCancel, cancelSignal, ipc, serialization } = param;
    if (!gracefulCancel) {
        return;
    }
    if (cancelSignal === undefined) {
        throw new Error('The `cancelSignal` option must be defined when setting the `gracefulCancel` option.');
    }
    if (!ipc) {
        throw new Error('The `ipc` option cannot be false when setting the `gracefulCancel` option.');
    }
    if (serialization === 'json') {
        throw new Error('The `serialization` option cannot be \'json\' when setting the `gracefulCancel` option.');
    }
};
const throwOnGracefulCancel = (param)=>{
    let { subprocess, cancelSignal, gracefulCancel, forceKillAfterDelay, context, controller } = param;
    return gracefulCancel ? [
        sendOnAbort({
            subprocess,
            cancelSignal,
            forceKillAfterDelay,
            context,
            controller
        })
    ] : [];
};
const sendOnAbort = async (param)=>{
    let { subprocess, cancelSignal, forceKillAfterDelay, context, controller: { signal } } = param;
    var _context;
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$abort$2d$signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onAbortedSignal"])(cancelSignal, signal);
    const reason = getReason(cancelSignal);
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sendAbort"])(subprocess, reason);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$kill$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["killOnTimeout"])({
        kill: subprocess.kill,
        forceKillAfterDelay,
        context,
        controllerSignal: signal
    });
    var _terminationReason;
    (_terminationReason = (_context = context).terminationReason) !== null && _terminationReason !== void 0 ? _terminationReason : _context.terminationReason = 'gracefulCancel';
    throw cancelSignal.reason;
};
// The default `reason` is a DOMException, which is not serializable with V8
// See https://github.com/nodejs/node/issues/53225
const getReason = (param)=>{
    let { reason } = param;
    if (!(reason instanceof DOMException)) {
        return reason;
    }
    const error = new Error(reason.message);
    Object.defineProperty(error, 'stack', {
        value: reason.stack,
        enumerable: false,
        configurable: true,
        writable: true
    });
    return error;
};
}),
"[project]/node_modules/execa/lib/terminate/timeout.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/terminate/timeout.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:timers/promises)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/terminate/timeout.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:timers/promises)");

}}),
"[project]/node_modules/execa/lib/methods/node.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleNodeOption",
    ()=>handleNodeOption,
    "mapNode",
    ()=>mapNode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/file-url.js [app-client] (ecmascript)");
;
;
;
const mapNode = (param)=>{
    let { options } = param;
    if (options.node === false) {
        throw new TypeError('The "node" option cannot be false with `execaNode()`.');
    }
    return {
        options: {
            ...options,
            node: true
        }
    };
};
const handleNodeOption = (file, commandArguments, param)=>{
    let { node: shouldHandleNode = false, nodePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execPath"], nodeOptions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execArgv"].filter((nodeOption)=>!nodeOption.startsWith('--inspect')), cwd, execPath: formerNodePath, ...options } = param;
    if (formerNodePath !== undefined) {
        throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');
    }
    const normalizedNodePath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeNormalizeFileUrl"])(nodePath, 'The "nodePath" option');
    const resolvedNodePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].resolve(cwd, normalizedNodePath);
    const newOptions = {
        ...options,
        nodePath: resolvedNodePath,
        node: shouldHandleNode,
        cwd
    };
    if (!shouldHandleNode) {
        return [
            file,
            commandArguments,
            newOptions
        ];
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].basename(file, '.exe') === 'node') {
        throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');
    }
    return [
        resolvedNodePath,
        [
            ...nodeOptions,
            file,
            ...commandArguments
        ],
        {
            ipc: true,
            ...newOptions,
            shell: false
        }
    ];
};
}),
"[project]/node_modules/execa/lib/ipc/ipc-input.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/ipc/ipc-input.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:v8)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/ipc/ipc-input.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:v8)");

}}),
"[project]/node_modules/execa/lib/arguments/encoding-option.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Validate `encoding` option
__turbopack_context__.s([
    "BINARY_ENCODINGS",
    ()=>BINARY_ENCODINGS,
    "validateEncoding",
    ()=>validateEncoding
]);
const validateEncoding = (param)=>{
    let { encoding } = param;
    if (ENCODINGS.has(encoding)) {
        return;
    }
    const correctEncoding = getCorrectEncoding(encoding);
    if (correctEncoding !== undefined) {
        throw new TypeError("Invalid option `encoding: ".concat(serializeEncoding(encoding), "`.\nPlease rename it to ").concat(serializeEncoding(correctEncoding), "."));
    }
    const correctEncodings = [
        ...ENCODINGS
    ].map((correctEncoding)=>serializeEncoding(correctEncoding)).join(', ');
    throw new TypeError("Invalid option `encoding: ".concat(serializeEncoding(encoding), "`.\nPlease rename it to one of: ").concat(correctEncodings, "."));
};
const TEXT_ENCODINGS = new Set([
    'utf8',
    'utf16le'
]);
const BINARY_ENCODINGS = new Set([
    'buffer',
    'hex',
    'base64',
    'base64url',
    'latin1',
    'ascii'
]);
const ENCODINGS = new Set([
    ...TEXT_ENCODINGS,
    ...BINARY_ENCODINGS
]);
const getCorrectEncoding = (encoding)=>{
    if (encoding === null) {
        return 'buffer';
    }
    if (typeof encoding !== 'string') {
        return;
    }
    const lowerEncoding = encoding.toLowerCase();
    if (lowerEncoding in ENCODING_ALIASES) {
        return ENCODING_ALIASES[lowerEncoding];
    }
    if (ENCODINGS.has(lowerEncoding)) {
        return lowerEncoding;
    }
};
const ENCODING_ALIASES = {
    // eslint-disable-next-line unicorn/text-encoding-identifier-case
    'utf-8': 'utf8',
    'utf-16le': 'utf16le',
    'ucs-2': 'utf16le',
    ucs2: 'utf16le',
    binary: 'latin1'
};
const serializeEncoding = (encoding)=>typeof encoding === 'string' ? '"'.concat(encoding, '"') : String(encoding);
}),
"[project]/node_modules/execa/lib/arguments/cwd.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/arguments/cwd.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:fs)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/arguments/cwd.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:fs)");

}}),
"[project]/node_modules/execa/lib/arguments/options.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizeOptions",
    ()=>normalizeOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cross$2d$spawn$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cross-spawn/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$npm$2d$run$2d$path$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/npm-run-path/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$kill$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/kill.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/signal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$cancel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/cancel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$graceful$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/graceful.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$timeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/timeout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/node.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$ipc$2d$input$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/ipc-input.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$cwd$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/cwd.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/file-url.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const normalizeOptions = (filePath, rawArguments, rawOptions)=>{
    rawOptions.cwd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$cwd$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeCwd"])(rawOptions.cwd);
    const [processedFile, processedArguments, processedOptions] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["handleNodeOption"])(filePath, rawArguments, rawOptions);
    const { command: file, args: commandArguments, options: initialOptions } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cross$2d$spawn$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]._parse(processedFile, processedArguments, processedOptions);
    const fdOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeFdSpecificOptions"])(initialOptions);
    const options = addDefaultOptions(fdOptions);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$timeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateTimeout"])(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateEncoding"])(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$ipc$2d$input$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIpcInputOption"])(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$cancel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateCancelSignal"])(options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$graceful$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateGracefulCancel"])(options);
    options.shell = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeFileUrl"])(options.shell);
    options.env = getEnv(options);
    options.killSignal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeKillSignal"])(options.killSignal);
    options.forceKillAfterDelay = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$kill$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeForceKillAfterDelay"])(options.forceKillAfterDelay);
    options.lines = options.lines.map((lines, fdNumber)=>lines && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(options.encoding) && options.buffer[fdNumber]);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === 'win32' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].basename(file, '.exe') === 'cmd') {
        // #116
        commandArguments.unshift('/q');
    }
    return {
        file,
        commandArguments,
        options
    };
};
const addDefaultOptions = (param)=>{
    let { extendEnv = true, preferLocal = false, cwd, localDir: localDirectory = cwd, encoding = 'utf8', reject = true, cleanup = true, all = false, windowsHide = true, killSignal = 'SIGTERM', forceKillAfterDelay = true, gracefulCancel = false, ipcInput, ipc = ipcInput !== undefined || gracefulCancel, serialization = 'advanced', ...options } = param;
    return {
        ...options,
        extendEnv,
        preferLocal,
        cwd,
        localDirectory,
        encoding,
        reject,
        cleanup,
        all,
        windowsHide,
        killSignal,
        forceKillAfterDelay,
        gracefulCancel,
        ipcInput,
        ipc,
        serialization
    };
};
const getEnv = (param)=>{
    let { env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath } = param;
    const env = extendEnv ? {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env,
        ...envOption
    } : envOption;
    if (preferLocal || node) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$npm$2d$run$2d$path$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["npmRunPathEnv"])({
            env,
            cwd: localDirectory,
            execPath: nodePath,
            preferLocal,
            addExecPath: node
        });
    }
    return env;
};
}),
"[project]/node_modules/execa/lib/arguments/shell.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// When the `shell` option is set, any command argument is concatenated as a single string by Node.js:
// https://github.com/nodejs/node/blob/e38ce27f3ca0a65f68a31cedd984cddb927d4002/lib/child_process.js#L614-L624
// However, since Node 24, it also prints a deprecation warning.
// To avoid this warning, we perform that same operation before calling `node:child_process`.
// Shells only understand strings, which is why Node.js performs that concatenation.
// However, we rely on users splitting command arguments as an array.
// For example, this allows us to easily detect which arguments are passed.
// So we do want users to pass array of arguments even with `shell: true`, but we also want to avoid any warning.
__turbopack_context__.s([
    "concatenateShell",
    ()=>concatenateShell
]);
const concatenateShell = (file, commandArguments, options)=>options.shell && commandArguments.length > 0 ? [
        [
            file,
            ...commandArguments
        ].join(' '),
        [],
        options
    ] : [
        file,
        commandArguments,
        options
    ];
}),
"[project]/node_modules/execa/lib/io/max-buffer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "checkIpcMaxBuffer",
    ()=>checkIpcMaxBuffer,
    "getMaxBufferMessage",
    ()=>getMaxBufferMessage,
    "getMaxBufferSync",
    ()=>getMaxBufferSync,
    "handleMaxBuffer",
    ()=>handleMaxBuffer,
    "isMaxBufferSync",
    ()=>isMaxBufferSync,
    "truncateMaxBufferSync",
    ()=>truncateMaxBufferSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$contents$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-stream/source/contents.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-client] (ecmascript)");
;
;
;
const handleMaxBuffer = (param)=>{
    let { error, stream, readableObjectMode, lines, encoding, fdNumber } = param;
    if (!(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$contents$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MaxBufferError"])) {
        throw error;
    }
    if (fdNumber === 'all') {
        return error;
    }
    const unit = getMaxBufferUnit(readableObjectMode, lines, encoding);
    error.maxBufferInfo = {
        fdNumber,
        unit
    };
    stream.destroy();
    throw error;
};
const getMaxBufferUnit = (readableObjectMode, lines, encoding)=>{
    if (readableObjectMode) {
        return 'objects';
    }
    if (lines) {
        return 'lines';
    }
    if (encoding === 'buffer') {
        return 'bytes';
    }
    return 'characters';
};
const checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer)=>{
    if (ipcOutput.length !== maxBuffer) {
        return;
    }
    const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$stream$2f$source$2f$contents$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MaxBufferError"]();
    error.maxBufferInfo = {
        fdNumber: 'ipc'
    };
    throw error;
};
const getMaxBufferMessage = (error, maxBuffer)=>{
    const { streamName, threshold, unit } = getMaxBufferInfo(error, maxBuffer);
    return "Command's ".concat(streamName, " was larger than ").concat(threshold, " ").concat(unit);
};
const getMaxBufferInfo = (error, maxBuffer)=>{
    if ((error === null || error === void 0 ? void 0 : error.maxBufferInfo) === undefined) {
        return {
            streamName: 'output',
            threshold: maxBuffer[1],
            unit: 'bytes'
        };
    }
    const { maxBufferInfo: { fdNumber, unit } } = error;
    delete error.maxBufferInfo;
    const threshold = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFdSpecificValue"])(maxBuffer, fdNumber);
    if (fdNumber === 'ipc') {
        return {
            streamName: 'IPC output',
            threshold,
            unit: 'messages'
        };
    }
    return {
        streamName: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStreamName"])(fdNumber),
        threshold,
        unit
    };
};
const isMaxBufferSync = (resultError, output, maxBuffer)=>(resultError === null || resultError === void 0 ? void 0 : resultError.code) === 'ENOBUFS' && output !== null && output.some((result)=>result !== null && result.length > getMaxBufferSync(maxBuffer));
const truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer)=>{
    if (!isMaxBuffer) {
        return result;
    }
    const maxBufferValue = getMaxBufferSync(maxBuffer);
    return result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;
};
const getMaxBufferSync = (param)=>{
    let [, stdoutMaxBuffer] = param;
    return stdoutMaxBuffer;
};
}),
"[project]/node_modules/execa/lib/return/message.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createMessages",
    ()=>createMessages
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$final$2d$newline$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/strip-final-newline/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$cwd$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/cwd.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/escape.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/max-buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/signal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/final-error.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const createMessages = (param)=>{
    let { stdio, all, ipcOutput, originalError, signal, signalDescription, exitCode, escapedCommand, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, forceKillAfterDelay, killSignal, maxBuffer, timeout, cwd } = param;
    const errorCode = originalError === null || originalError === void 0 ? void 0 : originalError.code;
    const prefix = getErrorPrefix({
        originalError,
        timedOut,
        timeout,
        isMaxBuffer,
        maxBuffer,
        errorCode,
        signal,
        signalDescription,
        exitCode,
        isCanceled,
        isGracefullyCanceled,
        isForcefullyTerminated,
        forceKillAfterDelay,
        killSignal
    });
    const originalMessage = getOriginalMessage(originalError, cwd);
    const suffix = originalMessage === undefined ? '' : "\n".concat(originalMessage);
    const shortMessage = "".concat(prefix, ": ").concat(escapedCommand).concat(suffix);
    const messageStdio = all === undefined ? [
        stdio[2],
        stdio[1]
    ] : [
        all
    ];
    const message = [
        shortMessage,
        ...messageStdio,
        ...stdio.slice(3),
        ipcOutput.map((ipcMessage)=>serializeIpcMessage(ipcMessage)).join('\n')
    ].map((messagePart)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["escapeLines"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$final$2d$newline$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(serializeMessagePart(messagePart)))).filter(Boolean).join('\n\n');
    return {
        originalMessage,
        shortMessage,
        message
    };
};
const getErrorPrefix = (param)=>{
    let { originalError, timedOut, timeout, isMaxBuffer, maxBuffer, errorCode, signal, signalDescription, exitCode, isCanceled, isGracefullyCanceled, isForcefullyTerminated, forceKillAfterDelay, killSignal } = param;
    const forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);
    if (timedOut) {
        return "Command timed out after ".concat(timeout, " milliseconds").concat(forcefulSuffix);
    }
    if (isGracefullyCanceled) {
        if (signal === undefined) {
            return "Command was gracefully canceled with exit code ".concat(exitCode);
        }
        return isForcefullyTerminated ? "Command was gracefully canceled".concat(forcefulSuffix) : "Command was gracefully canceled with ".concat(signal, " (").concat(signalDescription, ")");
    }
    if (isCanceled) {
        return "Command was canceled".concat(forcefulSuffix);
    }
    if (isMaxBuffer) {
        return "".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMaxBufferMessage"])(originalError, maxBuffer)).concat(forcefulSuffix);
    }
    if (errorCode !== undefined) {
        return "Command failed with ".concat(errorCode).concat(forcefulSuffix);
    }
    if (isForcefullyTerminated) {
        return "Command was killed with ".concat(killSignal, " (").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSignalDescription"])(killSignal), ")").concat(forcefulSuffix);
    }
    if (signal !== undefined) {
        return "Command was killed with ".concat(signal, " (").concat(signalDescription, ")");
    }
    if (exitCode !== undefined) {
        return "Command failed with exit code ".concat(exitCode);
    }
    return 'Command failed';
};
const getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay)=>isForcefullyTerminated ? " and was forcefully terminated after ".concat(forceKillAfterDelay, " milliseconds") : '';
const getOriginalMessage = (originalError, cwd)=>{
    if (originalError instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DiscardedError"]) {
        return;
    }
    var _originalError_message;
    const originalMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isExecaError"])(originalError) ? originalError.originalMessage : String((_originalError_message = originalError === null || originalError === void 0 ? void 0 : originalError.message) !== null && _originalError_message !== void 0 ? _originalError_message : originalError);
    const escapedOriginalMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$escape$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["escapeLines"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$cwd$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fixCwdError"])(originalMessage, cwd));
    return escapedOriginalMessage === '' ? undefined : escapedOriginalMessage;
};
const serializeIpcMessage = (ipcMessage)=>typeof ipcMessage === 'string' ? ipcMessage : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inspect"])(ipcMessage);
const serializeMessagePart = (messagePart)=>Array.isArray(messagePart) ? messagePart.map((messageItem)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$final$2d$newline$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(serializeMessageItem(messageItem))).filter(Boolean).join('\n') : serializeMessageItem(messagePart);
const serializeMessageItem = (messageItem)=>{
    if (typeof messageItem === 'string') {
        return messageItem;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUint8Array"])(messageItem)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToString"])(messageItem);
    }
    return '';
};
}),
"[project]/node_modules/execa/lib/return/result.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "makeEarlyError",
    ()=>makeEarlyError,
    "makeError",
    ()=>makeError,
    "makeSuccessResult",
    ()=>makeSuccessResult
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/signal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/duration.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/final-error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$message$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/message.js [app-client] (ecmascript)");
;
;
;
;
const makeSuccessResult = (param)=>{
    let { command, escapedCommand, stdio, all, ipcOutput, options: { cwd }, startTime } = param;
    return omitUndefinedProperties({
        command,
        escapedCommand,
        cwd,
        durationMs: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDurationMs"])(startTime),
        failed: false,
        timedOut: false,
        isCanceled: false,
        isGracefullyCanceled: false,
        isTerminated: false,
        isMaxBuffer: false,
        isForcefullyTerminated: false,
        exitCode: 0,
        stdout: stdio[1],
        stderr: stdio[2],
        all,
        stdio,
        ipcOutput,
        pipedFrom: []
    });
};
const makeEarlyError = (param)=>{
    let { error, command, escapedCommand, fileDescriptors, options, startTime, isSync } = param;
    return makeError({
        error,
        command,
        escapedCommand,
        startTime,
        timedOut: false,
        isCanceled: false,
        isGracefullyCanceled: false,
        isMaxBuffer: false,
        isForcefullyTerminated: false,
        stdio: Array.from({
            length: fileDescriptors.length
        }),
        ipcOutput: [],
        options,
        isSync
    });
};
const makeError = (param)=>{
    let { error: originalError, command, escapedCommand, startTime, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, exitCode: rawExitCode, signal: rawSignal, stdio, all, ipcOutput, options: { timeoutDuration, timeout = timeoutDuration, forceKillAfterDelay, killSignal, cwd, maxBuffer }, isSync } = param;
    const { exitCode, signal, signalDescription } = normalizeExitPayload(rawExitCode, rawSignal);
    const { originalMessage, shortMessage, message } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$message$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createMessages"])({
        stdio,
        all,
        ipcOutput,
        originalError,
        signal,
        signalDescription,
        exitCode,
        escapedCommand,
        timedOut,
        isCanceled,
        isGracefullyCanceled,
        isMaxBuffer,
        isForcefullyTerminated,
        forceKillAfterDelay,
        killSignal,
        maxBuffer,
        timeout,
        cwd
    });
    const error = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFinalError"])(originalError, message, isSync);
    Object.assign(error, getErrorProperties({
        error,
        command,
        escapedCommand,
        startTime,
        timedOut,
        isCanceled,
        isGracefullyCanceled,
        isMaxBuffer,
        isForcefullyTerminated,
        exitCode,
        signal,
        signalDescription,
        stdio,
        all,
        ipcOutput,
        cwd,
        originalMessage,
        shortMessage
    }));
    return error;
};
const getErrorProperties = (param)=>{
    let { error, command, escapedCommand, startTime, timedOut, isCanceled, isGracefullyCanceled, isMaxBuffer, isForcefullyTerminated, exitCode, signal, signalDescription, stdio, all, ipcOutput, cwd, originalMessage, shortMessage } = param;
    var _error_cause;
    return omitUndefinedProperties({
        shortMessage,
        originalMessage,
        command,
        escapedCommand,
        cwd,
        durationMs: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDurationMs"])(startTime),
        failed: true,
        timedOut,
        isCanceled,
        isGracefullyCanceled,
        isTerminated: signal !== undefined,
        isMaxBuffer,
        isForcefullyTerminated,
        exitCode,
        signal,
        signalDescription,
        code: (_error_cause = error.cause) === null || _error_cause === void 0 ? void 0 : _error_cause.code,
        stdout: stdio[1],
        stderr: stdio[2],
        all,
        stdio,
        ipcOutput,
        pipedFrom: []
    });
};
const omitUndefinedProperties = (result)=>Object.fromEntries(Object.entries(result).filter((param)=>{
        let [, value] = param;
        return value !== undefined;
    }));
// `signal` and `exitCode` emitted on `subprocess.on('exit')` event can be `null`.
// We normalize them to `undefined`
const normalizeExitPayload = (rawExitCode, rawSignal)=>{
    const exitCode = rawExitCode === null ? undefined : rawExitCode;
    const signal = rawSignal === null ? undefined : rawSignal;
    const signalDescription = signal === undefined ? undefined : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$signal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSignalDescription"])(rawSignal);
    return {
        exitCode,
        signal,
        signalDescription
    };
};
}),
"[project]/node_modules/execa/lib/verbose/error.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logError",
    ()=>logError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/log.js [app-client] (ecmascript)");
;
const logError = (result, verboseInfo)=>{
    if (result.failed) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verboseLog"])({
            type: 'error',
            verboseMessage: result.shortMessage,
            verboseInfo,
            result
        });
    }
};
}),
"[project]/node_modules/execa/lib/verbose/complete.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logResult",
    ()=>logResult
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pretty$2d$ms$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pretty-ms/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/error.js [app-client] (ecmascript)");
;
;
;
;
const logResult = (result, verboseInfo)=>{
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isVerbose"])(verboseInfo)) {
        return;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logError"])(result, verboseInfo);
    logDuration(result, verboseInfo);
};
const logDuration = (result, verboseInfo)=>{
    const verboseMessage = "(done in ".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pretty$2d$ms$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result.durationMs), ")");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verboseLog"])({
        type: 'duration',
        verboseMessage,
        verboseInfo,
        result
    });
};
}),
"[project]/node_modules/execa/lib/return/reject.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleResult",
    ()=>handleResult
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$complete$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/complete.js [app-client] (ecmascript)");
;
const handleResult = (result, verboseInfo, param)=>{
    let { reject } = param;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$complete$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logResult"])(result, verboseInfo);
    if (result.failed && reject) {
        throw result;
    }
    return result;
};
}),
"[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FILE_TYPES",
    ()=>FILE_TYPES,
    "FORBID_DUPLICATE_TYPES",
    ()=>FORBID_DUPLICATE_TYPES,
    "SPECIAL_DUPLICATE_TYPES",
    ()=>SPECIAL_DUPLICATE_TYPES,
    "SPECIAL_DUPLICATE_TYPES_SYNC",
    ()=>SPECIAL_DUPLICATE_TYPES_SYNC,
    "TRANSFORM_TYPES",
    ()=>TRANSFORM_TYPES,
    "TYPE_TO_MESSAGE",
    ()=>TYPE_TO_MESSAGE,
    "getStdioItemType",
    ()=>getStdioItemType,
    "isAsyncGenerator",
    ()=>isAsyncGenerator,
    "isFilePathString",
    ()=>isFilePathString,
    "isRegularUrl",
    ()=>isRegularUrl,
    "isUnknownStdioString",
    ()=>isUnknownStdioString,
    "isUrl",
    ()=>isUrl,
    "isWritableStream",
    ()=>isWritableStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-stream/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-client] (ecmascript)");
;
;
;
const getStdioItemType = (value, optionName)=>{
    if (isAsyncGenerator(value)) {
        return 'asyncGenerator';
    }
    if (isSyncGenerator(value)) {
        return 'generator';
    }
    if (isUrl(value)) {
        return 'fileUrl';
    }
    if (isFilePathObject(value)) {
        return 'filePath';
    }
    if (isWebStream(value)) {
        return 'webStream';
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStream"])(value, {
        checkOpen: false
    })) {
        return 'native';
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUint8Array"])(value)) {
        return 'uint8Array';
    }
    if (isAsyncIterableObject(value)) {
        return 'asyncIterable';
    }
    if (isIterableObject(value)) {
        return 'iterable';
    }
    if (isTransformStream(value)) {
        return getTransformStreamType({
            transform: value
        }, optionName);
    }
    if (isTransformOptions(value)) {
        return getTransformObjectType(value, optionName);
    }
    return 'native';
};
const getTransformObjectType = (value, optionName)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDuplexStream"])(value.transform, {
        checkOpen: false
    })) {
        return getDuplexType(value, optionName);
    }
    if (isTransformStream(value.transform)) {
        return getTransformStreamType(value, optionName);
    }
    return getGeneratorObjectType(value, optionName);
};
const getDuplexType = (value, optionName)=>{
    validateNonGeneratorType(value, optionName, 'Duplex stream');
    return 'duplex';
};
const getTransformStreamType = (value, optionName)=>{
    validateNonGeneratorType(value, optionName, 'web TransformStream');
    return 'webTransform';
};
const validateNonGeneratorType = (param, optionName, typeName)=>{
    let { final, binary, objectMode } = param;
    checkUndefinedOption(final, "".concat(optionName, ".final"), typeName);
    checkUndefinedOption(binary, "".concat(optionName, ".binary"), typeName);
    checkBooleanOption(objectMode, "".concat(optionName, ".objectMode"));
};
const checkUndefinedOption = (value, optionName, typeName)=>{
    if (value !== undefined) {
        throw new TypeError("The `".concat(optionName, "` option can only be defined when using a generator, not a ").concat(typeName, "."));
    }
};
const getGeneratorObjectType = (param, optionName)=>{
    let { transform, final, binary, objectMode } = param;
    if (transform !== undefined && !isGenerator(transform)) {
        throw new TypeError("The `".concat(optionName, ".transform` option must be a generator, a Duplex stream or a web TransformStream."));
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDuplexStream"])(final, {
        checkOpen: false
    })) {
        throw new TypeError("The `".concat(optionName, ".final` option must not be a Duplex stream."));
    }
    if (isTransformStream(final)) {
        throw new TypeError("The `".concat(optionName, ".final` option must not be a web TransformStream."));
    }
    if (final !== undefined && !isGenerator(final)) {
        throw new TypeError("The `".concat(optionName, ".final` option must be a generator."));
    }
    checkBooleanOption(binary, "".concat(optionName, ".binary"));
    checkBooleanOption(objectMode, "".concat(optionName, ".objectMode"));
    return isAsyncGenerator(transform) || isAsyncGenerator(final) ? 'asyncGenerator' : 'generator';
};
const checkBooleanOption = (value, optionName)=>{
    if (value !== undefined && typeof value !== 'boolean') {
        throw new TypeError("The `".concat(optionName, "` option must use a boolean."));
    }
};
const isGenerator = (value)=>isAsyncGenerator(value) || isSyncGenerator(value);
const isAsyncGenerator = (value)=>Object.prototype.toString.call(value) === '[object AsyncGeneratorFunction]';
const isSyncGenerator = (value)=>Object.prototype.toString.call(value) === '[object GeneratorFunction]';
const isTransformOptions = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value) && (value.transform !== undefined || value.final !== undefined);
const isUrl = (value)=>Object.prototype.toString.call(value) === '[object URL]';
const isRegularUrl = (value)=>isUrl(value) && value.protocol !== 'file:';
const isFilePathObject = (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value) && Object.keys(value).length > 0 && Object.keys(value).every((key)=>FILE_PATH_KEYS.has(key)) && isFilePathString(value.file);
const FILE_PATH_KEYS = new Set([
    'file',
    'append'
]);
const isFilePathString = (file)=>typeof file === 'string';
const isUnknownStdioString = (type, value)=>type === 'native' && typeof value === 'string' && !KNOWN_STDIO_STRINGS.has(value);
const KNOWN_STDIO_STRINGS = new Set([
    'ipc',
    'ignore',
    'inherit',
    'overlapped',
    'pipe'
]);
const isReadableStream = (value)=>Object.prototype.toString.call(value) === '[object ReadableStream]';
const isWritableStream = (value)=>Object.prototype.toString.call(value) === '[object WritableStream]';
const isWebStream = (value)=>isReadableStream(value) || isWritableStream(value);
const isTransformStream = (value)=>isReadableStream(value === null || value === void 0 ? void 0 : value.readable) && isWritableStream(value === null || value === void 0 ? void 0 : value.writable);
const isAsyncIterableObject = (value)=>isObject(value) && typeof value[Symbol.asyncIterator] === 'function';
const isIterableObject = (value)=>isObject(value) && typeof value[Symbol.iterator] === 'function';
const isObject = (value)=>typeof value === 'object' && value !== null;
const TRANSFORM_TYPES = new Set([
    'generator',
    'asyncGenerator',
    'duplex',
    'webTransform'
]);
const FILE_TYPES = new Set([
    'fileUrl',
    'filePath',
    'fileNumber'
]);
const SPECIAL_DUPLICATE_TYPES_SYNC = new Set([
    'fileUrl',
    'filePath'
]);
const SPECIAL_DUPLICATE_TYPES = new Set([
    ...SPECIAL_DUPLICATE_TYPES_SYNC,
    'webStream',
    'nodeStream'
]);
const FORBID_DUPLICATE_TYPES = new Set([
    'webTransform',
    'duplex'
]);
const TYPE_TO_MESSAGE = {
    generator: 'a generator',
    asyncGenerator: 'an async generator',
    fileUrl: 'a file URL',
    filePath: 'a file path string',
    fileNumber: 'a file descriptor number',
    webStream: 'a web stream',
    nodeStream: 'a Node.js stream',
    webTransform: 'a web TransformStream',
    duplex: 'a Duplex stream',
    native: 'any value',
    iterable: 'an iterable',
    asyncIterable: 'an async iterable',
    string: 'a string',
    uint8Array: 'a Uint8Array'
};
}),
"[project]/node_modules/execa/lib/transform/object-mode.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getFdObjectMode",
    ()=>getFdObjectMode,
    "getTransformObjectModes",
    ()=>getTransformObjectModes
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
;
const getTransformObjectModes = (objectMode, index, newTransforms, direction)=>direction === 'output' ? getOutputObjectModes(objectMode, index, newTransforms) : getInputObjectModes(objectMode, index, newTransforms);
const getOutputObjectModes = (objectMode, index, newTransforms)=>{
    const writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;
    const readableObjectMode = objectMode !== null && objectMode !== void 0 ? objectMode : writableObjectMode;
    return {
        writableObjectMode,
        readableObjectMode
    };
};
const getInputObjectModes = (objectMode, index, newTransforms)=>{
    const writableObjectMode = index === 0 ? objectMode === true : newTransforms[index - 1].value.readableObjectMode;
    const readableObjectMode = index !== newTransforms.length - 1 && (objectMode !== null && objectMode !== void 0 ? objectMode : writableObjectMode);
    return {
        writableObjectMode,
        readableObjectMode
    };
};
const getFdObjectMode = (stdioItems, direction)=>{
    const lastTransform = stdioItems.findLast((param)=>{
        let { type } = param;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type);
    });
    if (lastTransform === undefined) {
        return false;
    }
    return direction === 'input' ? lastTransform.value.writableObjectMode : lastTransform.value.readableObjectMode;
};
}),
"[project]/node_modules/execa/lib/transform/normalize.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizeTransforms",
    ()=>normalizeTransforms
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$object$2d$mode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/object-mode.js [app-client] (ecmascript)");
;
;
;
;
const normalizeTransforms = (stdioItems, optionName, direction, options)=>[
        ...stdioItems.filter((param)=>{
            let { type } = param;
            return !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type);
        }),
        ...getTransforms(stdioItems, optionName, direction, options)
    ];
const getTransforms = (stdioItems, optionName, direction, param)=>{
    let { encoding } = param;
    const transforms = stdioItems.filter((param)=>{
        let { type } = param;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type);
    });
    const newTransforms = Array.from({
        length: transforms.length
    });
    for (const [index, stdioItem] of Object.entries(transforms)){
        newTransforms[index] = normalizeTransform({
            stdioItem,
            index: Number(index),
            newTransforms,
            optionName,
            direction,
            encoding
        });
    }
    return sortTransforms(newTransforms, direction);
};
const normalizeTransform = (param)=>{
    let { stdioItem, stdioItem: { type }, index, newTransforms, optionName, direction, encoding } = param;
    if (type === 'duplex') {
        return normalizeDuplex({
            stdioItem,
            optionName
        });
    }
    if (type === 'webTransform') {
        return normalizeTransformStream({
            stdioItem,
            index,
            newTransforms,
            direction
        });
    }
    return normalizeGenerator({
        stdioItem,
        index,
        newTransforms,
        direction,
        encoding
    });
};
const normalizeDuplex = (param)=>{
    let { stdioItem, stdioItem: { value: { transform, transform: { writableObjectMode, readableObjectMode }, objectMode = readableObjectMode } }, optionName } = param;
    if (objectMode && !readableObjectMode) {
        throw new TypeError("The `".concat(optionName, ".objectMode` option can only be `true` if `new Duplex({objectMode: true})` is used."));
    }
    if (!objectMode && readableObjectMode) {
        throw new TypeError("The `".concat(optionName, ".objectMode` option cannot be `false` if `new Duplex({objectMode: true})` is used."));
    }
    return {
        ...stdioItem,
        value: {
            transform,
            writableObjectMode,
            readableObjectMode
        }
    };
};
const normalizeTransformStream = (param)=>{
    let { stdioItem, stdioItem: { value }, index, newTransforms, direction } = param;
    const { transform, objectMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value) ? value : {
        transform: value
    };
    const { writableObjectMode, readableObjectMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$object$2d$mode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTransformObjectModes"])(objectMode, index, newTransforms, direction);
    return {
        ...stdioItem,
        value: {
            transform,
            writableObjectMode,
            readableObjectMode
        }
    };
};
const normalizeGenerator = (param)=>{
    let { stdioItem, stdioItem: { value }, index, newTransforms, direction, encoding } = param;
    const { transform, final, binary: binaryOption = false, preserveNewlines = false, objectMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value) ? value : {
        transform: value
    };
    const binary = binaryOption || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(encoding);
    const { writableObjectMode, readableObjectMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$object$2d$mode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTransformObjectModes"])(objectMode, index, newTransforms, direction);
    return {
        ...stdioItem,
        value: {
            transform,
            final,
            binary,
            preserveNewlines,
            writableObjectMode,
            readableObjectMode
        }
    };
};
const sortTransforms = (newTransforms, direction)=>direction === 'input' ? newTransforms.reverse() : newTransforms;
}),
"[project]/node_modules/execa/lib/stdio/direction.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getStreamDirection",
    ()=>getStreamDirection
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-stream/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
;
;
;
const getStreamDirection = (stdioItems, fdNumber, optionName)=>{
    const directions = stdioItems.map((stdioItem)=>getStdioItemDirection(stdioItem, fdNumber));
    if (directions.includes('input') && directions.includes('output')) {
        throw new TypeError("The `".concat(optionName, "` option must not be an array of both readable and writable values."));
    }
    var _directions_find;
    return (_directions_find = directions.find(Boolean)) !== null && _directions_find !== void 0 ? _directions_find : DEFAULT_DIRECTION;
};
const getStdioItemDirection = (param, fdNumber)=>{
    let { type, value } = param;
    var _KNOWN_DIRECTIONS_fdNumber;
    return (_KNOWN_DIRECTIONS_fdNumber = KNOWN_DIRECTIONS[fdNumber]) !== null && _KNOWN_DIRECTIONS_fdNumber !== void 0 ? _KNOWN_DIRECTIONS_fdNumber : guessStreamDirection[type](value);
};
// `stdin`/`stdout`/`stderr` have a known direction
const KNOWN_DIRECTIONS = [
    'input',
    'output',
    'output'
];
const anyDirection = ()=>undefined;
const alwaysInput = ()=>'input';
// `string` can only be added through the `input` option, i.e. does not need to be handled here
const guessStreamDirection = {
    generator: anyDirection,
    asyncGenerator: anyDirection,
    fileUrl: anyDirection,
    filePath: anyDirection,
    iterable: alwaysInput,
    asyncIterable: alwaysInput,
    uint8Array: alwaysInput,
    webStream: (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWritableStream"])(value) ? 'output' : 'input',
    nodeStream (value) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReadableStream"])(value, {
            checkOpen: false
        })) {
            return 'output';
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWritableStream"])(value, {
            checkOpen: false
        }) ? undefined : 'input';
    },
    webTransform: anyDirection,
    duplex: anyDirection,
    native (value) {
        const standardStreamDirection = getStandardStreamDirection(value);
        if (standardStreamDirection !== undefined) {
            return standardStreamDirection;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStream"])(value, {
            checkOpen: false
        })) {
            return guessStreamDirection.nodeStream(value);
        }
    }
};
const getStandardStreamDirection = (value)=>{
    if ([
        0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stdin
    ].includes(value)) {
        return 'input';
    }
    if ([
        1,
        2,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stdout,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stderr
    ].includes(value)) {
        return 'output';
    }
};
// When ambiguous, we initially keep the direction as `undefined`.
// This allows arrays of `stdio` values to resolve the ambiguity.
// For example, `stdio[3]: DuplexStream` is ambiguous, but `stdio[3]: [DuplexStream, WritableStream]` is not.
// When the ambiguity remains, we default to `output` since it is the most common use case for additional file descriptors.
const DEFAULT_DIRECTION = 'output';
}),
"[project]/node_modules/execa/lib/ipc/array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// The `ipc` option adds an `ipc` item to the `stdio` option
__turbopack_context__.s([
    "normalizeIpcStdioArray",
    ()=>normalizeIpcStdioArray
]);
const normalizeIpcStdioArray = (stdioArray, ipc)=>ipc && !stdioArray.includes('ipc') ? [
        ...stdioArray,
        'ipc'
    ] : stdioArray;
}),
"[project]/node_modules/execa/lib/stdio/stdio-option.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizeStdioOption",
    ()=>normalizeStdioOption
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-client] (ecmascript)");
;
;
;
const normalizeStdioOption = (param, verboseInfo, isSync)=>{
    let { stdio, ipc, buffer, ...options } = param;
    const stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber)=>addDefaultValue(stdioOption, fdNumber));
    return isSync ? normalizeStdioSync(stdioArray, buffer, verboseInfo) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeIpcStdioArray"])(stdioArray, ipc);
};
const getStdioArray = (stdio, options)=>{
    if (stdio === undefined) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].map((alias)=>options[alias]);
    }
    if (hasAlias(options)) {
        throw new Error("It's not possible to provide `stdio` in combination with one of ".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].map((alias)=>"`".concat(alias, "`")).join(', ')));
    }
    if (typeof stdio === 'string') {
        return [
            stdio,
            stdio,
            stdio
        ];
    }
    if (!Array.isArray(stdio)) {
        throw new TypeError("Expected `stdio` to be of type `string` or `Array`, got `".concat(typeof stdio, "`"));
    }
    const length = Math.max(stdio.length, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].length);
    return Array.from({
        length
    }, (_, fdNumber)=>stdio[fdNumber]);
};
const hasAlias = (options)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].some((alias)=>options[alias] !== undefined);
const addDefaultValue = (stdioOption, fdNumber)=>{
    if (Array.isArray(stdioOption)) {
        return stdioOption.map((item)=>addDefaultValue(item, fdNumber));
    }
    if (stdioOption === null || stdioOption === undefined) {
        return fdNumber >= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["STANDARD_STREAMS_ALIASES"].length ? 'ignore' : 'pipe';
    }
    return stdioOption;
};
// Using `buffer: false` with synchronous methods implies `stdout`/`stderr`: `ignore`.
// Unless the output is needed, e.g. due to `verbose: 'full'` or to redirecting to a file.
const normalizeStdioSync = (stdioArray, buffer, verboseInfo)=>stdioArray.map((stdioOption, fdNumber)=>!buffer[fdNumber] && fdNumber !== 0 && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFullVerbose"])(verboseInfo, fdNumber) && isOutputPipeOnly(stdioOption) ? 'ignore' : stdioOption);
const isOutputPipeOnly = (stdioOption)=>stdioOption === 'pipe' || Array.isArray(stdioOption) && stdioOption.every((item)=>item === 'pipe');
}),
"[project]/node_modules/execa/lib/stdio/native.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/stdio/native.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:fs)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/stdio/native.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:fs)");

}}),
"[project]/node_modules/execa/lib/stdio/input-option.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleInputOptions",
    ()=>handleInputOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-stream/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
;
;
;
const handleInputOptions = (param, fdNumber)=>{
    let { input, inputFile } = param;
    return fdNumber === 0 ? [
        ...handleInputOption(input),
        ...handleInputFileOption(inputFile)
    ] : [];
};
const handleInputOption = (input)=>input === undefined ? [] : [
        {
            type: getInputType(input),
            value: input,
            optionName: 'input'
        }
    ];
const getInputType = (input)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReadableStream"])(input, {
        checkOpen: false
    })) {
        return 'nodeStream';
    }
    if (typeof input === 'string') {
        return 'string';
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUint8Array"])(input)) {
        return 'uint8Array';
    }
    throw new Error('The `input` option must be a string, a Uint8Array or a Node.js Readable stream.');
};
const handleInputFileOption = (inputFile)=>inputFile === undefined ? [] : [
        {
            ...getInputFileType(inputFile),
            optionName: 'inputFile'
        }
    ];
const getInputFileType = (inputFile)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUrl"])(inputFile)) {
        return {
            type: 'fileUrl',
            value: inputFile
        };
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFilePathString"])(inputFile)) {
        return {
            type: 'filePath',
            value: {
                file: inputFile
            }
        };
    }
    throw new Error('The `inputFile` option must be a file path string or a file URL.');
};
}),
"[project]/node_modules/execa/lib/stdio/duplicate.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "filterDuplicates",
    ()=>filterDuplicates,
    "getDuplicateStream",
    ()=>getDuplicateStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
;
const filterDuplicates = (stdioItems)=>stdioItems.filter((stdioItemOne, indexOne)=>stdioItems.every((stdioItemTwo, indexTwo)=>stdioItemOne.value !== stdioItemTwo.value || indexOne >= indexTwo || stdioItemOne.type === 'generator' || stdioItemOne.type === 'asyncGenerator'));
const getDuplicateStream = (param)=>{
    let { stdioItem: { type, value, optionName }, direction, fileDescriptors, isSync } = param;
    const otherStdioItems = getOtherStdioItems(fileDescriptors, type);
    if (otherStdioItems.length === 0) {
        return;
    }
    if (isSync) {
        validateDuplicateStreamSync({
            otherStdioItems,
            type,
            value,
            optionName,
            direction
        });
        return;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SPECIAL_DUPLICATE_TYPES"].has(type)) {
        return getDuplicateStreamInstance({
            otherStdioItems,
            type,
            value,
            optionName,
            direction
        });
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FORBID_DUPLICATE_TYPES"].has(type)) {
        validateDuplicateTransform({
            otherStdioItems,
            type,
            value,
            optionName
        });
    }
};
// Values shared by multiple file descriptors
const getOtherStdioItems = (fileDescriptors, type)=>fileDescriptors.flatMap((param)=>{
        let { direction, stdioItems } = param;
        return stdioItems.filter((stdioItem)=>stdioItem.type === type).map((stdioItem)=>({
                ...stdioItem,
                direction
            }));
    });
// With `execaSync()`, do not allow setting a file path both in input and output
const validateDuplicateStreamSync = (param)=>{
    let { otherStdioItems, type, value, optionName, direction } = param;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SPECIAL_DUPLICATE_TYPES_SYNC"].has(type)) {
        getDuplicateStreamInstance({
            otherStdioItems,
            type,
            value,
            optionName,
            direction
        });
    }
};
// When two file descriptors share the file or stream, we need to re-use the same underlying stream.
// Otherwise, the stream would be closed twice when piping ends.
// This is only an issue with output file descriptors.
// This is not a problem with generator functions since those create a new instance for each file descriptor.
// We also forbid input and output file descriptors sharing the same file or stream, since that does not make sense.
const getDuplicateStreamInstance = (param)=>{
    let { otherStdioItems, type, value, optionName, direction } = param;
    const duplicateStdioItems = otherStdioItems.filter((stdioItem)=>hasSameValue(stdioItem, value));
    if (duplicateStdioItems.length === 0) {
        return;
    }
    const differentStdioItem = duplicateStdioItems.find((stdioItem)=>stdioItem.direction !== direction);
    throwOnDuplicateStream(differentStdioItem, optionName, type);
    return direction === 'output' ? duplicateStdioItems[0].stream : undefined;
};
const hasSameValue = (param, secondValue)=>{
    let { type, value } = param;
    if (type === 'filePath') {
        return value.file === secondValue.file;
    }
    if (type === 'fileUrl') {
        return value.href === secondValue.href;
    }
    return value === secondValue;
};
// We do not allow two file descriptors to share the same Duplex or TransformStream.
// This is because those are set directly to `subprocess.std*`.
// For example, this could result in `subprocess.stdout` and `subprocess.stderr` being the same value.
// This means reading from either would get data from both stdout and stderr.
const validateDuplicateTransform = (param)=>{
    let { otherStdioItems, type, value, optionName } = param;
    const duplicateStdioItem = otherStdioItems.find((param)=>{
        let { value: { transform } } = param;
        return transform === value.transform;
    });
    throwOnDuplicateStream(duplicateStdioItem, optionName, type);
};
const throwOnDuplicateStream = (stdioItem, optionName, type)=>{
    if (stdioItem !== undefined) {
        throw new TypeError("The `".concat(stdioItem.optionName, "` and `").concat(optionName, "` options must not target ").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE_TO_MESSAGE"][type], " that is the same."));
    }
};
}),
"[project]/node_modules/execa/lib/stdio/handle.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cleanupCustomStreams",
    ()=>cleanupCustomStreams,
    "handleStdio",
    ()=>handleStdio
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$normalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/normalize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$object$2d$mode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/object-mode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$direction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/direction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$stdio$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/stdio-option.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/native.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$input$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/input-option.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$duplicate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/duplicate.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
const handleStdio = (addProperties, options, verboseInfo, isSync)=>{
    const stdio = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$stdio$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeStdioOption"])(options, verboseInfo, isSync);
    const initialFileDescriptors = stdio.map((stdioOption, fdNumber)=>getFileDescriptor({
            stdioOption,
            fdNumber,
            options,
            isSync
        }));
    const fileDescriptors = getFinalFileDescriptors({
        initialFileDescriptors,
        addProperties,
        options,
        isSync
    });
    options.stdio = fileDescriptors.map((param)=>{
        let { stdioItems } = param;
        return forwardStdio(stdioItems);
    });
    return fileDescriptors;
};
const getFileDescriptor = (param)=>{
    let { stdioOption, fdNumber, options, isSync } = param;
    const optionName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStreamName"])(fdNumber);
    const { stdioItems: initialStdioItems, isStdioArray } = initializeStdioItems({
        stdioOption,
        fdNumber,
        options,
        optionName
    });
    const direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$direction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStreamDirection"])(initialStdioItems, fdNumber, optionName);
    const stdioItems = initialStdioItems.map((stdioItem)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["handleNativeStream"])({
            stdioItem,
            isStdioArray,
            fdNumber,
            direction,
            isSync
        }));
    const normalizedStdioItems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$normalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeTransforms"])(stdioItems, optionName, direction, options);
    const objectMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$object$2d$mode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFdObjectMode"])(normalizedStdioItems, direction);
    validateFileObjectMode(normalizedStdioItems, objectMode);
    return {
        direction,
        objectMode,
        stdioItems: normalizedStdioItems
    };
};
// We make sure passing an array with a single item behaves the same as passing that item without an array.
// This is what users would expect.
// For example, `stdout: ['ignore']` behaves the same as `stdout: 'ignore'`.
const initializeStdioItems = (param)=>{
    let { stdioOption, fdNumber, options, optionName } = param;
    const values = Array.isArray(stdioOption) ? stdioOption : [
        stdioOption
    ];
    const initialStdioItems = [
        ...values.map((value)=>initializeStdioItem(value, optionName)),
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$input$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["handleInputOptions"])(options, fdNumber)
    ];
    const stdioItems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$duplicate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filterDuplicates"])(initialStdioItems);
    const isStdioArray = stdioItems.length > 1;
    validateStdioArray(stdioItems, isStdioArray, optionName);
    validateStreams(stdioItems);
    return {
        stdioItems,
        isStdioArray
    };
};
const initializeStdioItem = (value, optionName)=>({
        type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStdioItemType"])(value, optionName),
        value,
        optionName
    });
const validateStdioArray = (stdioItems, isStdioArray, optionName)=>{
    if (stdioItems.length === 0) {
        throw new TypeError("The `".concat(optionName, "` option must not be an empty array."));
    }
    if (!isStdioArray) {
        return;
    }
    for (const { value, optionName } of stdioItems){
        if (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {
            throw new Error("The `".concat(optionName, "` option must not include `").concat(value, "`."));
        }
    }
};
// Using those `stdio` values together with others for the same stream does not make sense, so we make it fail.
// However, we do allow it if the array has a single item.
const INVALID_STDIO_ARRAY_OPTIONS = new Set([
    'ignore',
    'ipc'
]);
const validateStreams = (stdioItems)=>{
    for (const stdioItem of stdioItems){
        validateFileStdio(stdioItem);
    }
};
const validateFileStdio = (param)=>{
    let { type, value, optionName } = param;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRegularUrl"])(value)) {
        throw new TypeError("The `".concat(optionName, ": URL` option must use the `file:` scheme.\nFor example, you can use the `pathToFileURL()` method of the `url` core module."));
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUnknownStdioString"])(type, value)) {
        throw new TypeError("The `".concat(optionName, ": { file: '...' }` option must be used instead of `").concat(optionName, ": '...'`."));
    }
};
const validateFileObjectMode = (stdioItems, objectMode)=>{
    if (!objectMode) {
        return;
    }
    const fileStdioItem = stdioItems.find((param)=>{
        let { type } = param;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FILE_TYPES"].has(type);
    });
    if (fileStdioItem !== undefined) {
        throw new TypeError("The `".concat(fileStdioItem.optionName, "` option cannot use both files and transforms in objectMode."));
    }
};
// Some `stdio` values require Execa to create streams.
// For example, file paths create file read/write streams.
// Those transformations are specified in `addProperties`, which is both direction-specific and type-specific.
const getFinalFileDescriptors = (param)=>{
    let { initialFileDescriptors, addProperties, options, isSync } = param;
    const fileDescriptors = [];
    try {
        for (const fileDescriptor of initialFileDescriptors){
            fileDescriptors.push(getFinalFileDescriptor({
                fileDescriptor,
                fileDescriptors,
                addProperties,
                options,
                isSync
            }));
        }
        return fileDescriptors;
    } catch (error) {
        cleanupCustomStreams(fileDescriptors);
        throw error;
    }
};
const getFinalFileDescriptor = (param)=>{
    let { fileDescriptor: { direction, objectMode, stdioItems }, fileDescriptors, addProperties, options, isSync } = param;
    const finalStdioItems = stdioItems.map((stdioItem)=>addStreamProperties({
            stdioItem,
            addProperties,
            direction,
            options,
            fileDescriptors,
            isSync
        }));
    return {
        direction,
        objectMode,
        stdioItems: finalStdioItems
    };
};
const addStreamProperties = (param)=>{
    let { stdioItem, addProperties, direction, options, fileDescriptors, isSync } = param;
    const duplicateStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$duplicate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDuplicateStream"])({
        stdioItem,
        direction,
        fileDescriptors,
        isSync
    });
    if (duplicateStream !== undefined) {
        return {
            ...stdioItem,
            stream: duplicateStream
        };
    }
    return {
        ...stdioItem,
        ...addProperties[direction][stdioItem.type](stdioItem, options)
    };
};
const cleanupCustomStreams = (fileDescriptors)=>{
    for (const { stdioItems } of fileDescriptors){
        for (const { stream } of stdioItems){
            if (stream !== undefined && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStandardStream"])(stream)) {
                stream.destroy();
            }
        }
    }
};
// When the `std*: Iterable | WebStream | URL | filePath`, `input` or `inputFile` option is used, we pipe to `subprocess.std*`.
// When the `std*: Array` option is used, we emulate some of the native values ('inherit', Node.js stream and file descriptor integer). To do so, we also need to pipe to `subprocess.std*`.
// Therefore the `std*` options must be either `pipe` or `overlapped`. Other values do not set `subprocess.std*`.
const forwardStdio = (stdioItems)=>{
    if (stdioItems.length > 1) {
        return stdioItems.some((param)=>{
            let { value } = param;
            return value === 'overlapped';
        }) ? 'overlapped' : 'pipe';
    }
    const [{ type, value }] = stdioItems;
    return type === 'native' ? value : 'pipe';
};
}),
"[project]/node_modules/execa/lib/stdio/handle-sync.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/stdio/handle-sync.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:fs)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/stdio/handle-sync.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:fs)");

}}),
"[project]/node_modules/execa/lib/io/strip-newline.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getStripFinalNewline",
    ()=>getStripFinalNewline,
    "stripNewline",
    ()=>stripNewline
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$final$2d$newline$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/strip-final-newline/index.js [app-client] (ecmascript)");
;
const stripNewline = (value, param, fdNumber)=>{
    let { stripFinalNewline } = param;
    return getStripFinalNewline(stripFinalNewline, fdNumber) && value !== undefined && !Array.isArray(value) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$strip$2d$final$2d$newline$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value) : value;
};
const getStripFinalNewline = (stripFinalNewline, fdNumber)=>fdNumber === 'all' ? stripFinalNewline[1] || stripFinalNewline[2] : stripFinalNewline[fdNumber];
}),
"[project]/node_modules/execa/lib/transform/split.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Split chunks line-wise for generators passed to the `std*` options
__turbopack_context__.s([
    "getAppendNewlineGenerator",
    ()=>getAppendNewlineGenerator,
    "getSplitLinesGenerator",
    ()=>getSplitLinesGenerator,
    "splitLinesSync",
    ()=>splitLinesSync
]);
const getSplitLinesGenerator = (binary, preserveNewlines, skipped, state)=>binary || skipped ? undefined : initializeSplitLines(preserveNewlines, state);
const splitLinesSync = (chunk, preserveNewlines, objectMode)=>objectMode ? chunk.flatMap((item)=>splitLinesItemSync(item, preserveNewlines)) : splitLinesItemSync(chunk, preserveNewlines);
const splitLinesItemSync = (chunk, preserveNewlines)=>{
    const { transform, final } = initializeSplitLines(preserveNewlines, {});
    return [
        ...transform(chunk),
        ...final()
    ];
};
const initializeSplitLines = (preserveNewlines, state)=>{
    state.previousChunks = '';
    return {
        transform: splitGenerator.bind(undefined, state, preserveNewlines),
        final: linesFinal.bind(undefined, state)
    };
};
// This imperative logic is much faster than using `String.split()` and uses very low memory.
const splitGenerator = function*(state, preserveNewlines, chunk) {
    if (typeof chunk !== 'string') {
        yield chunk;
        return;
    }
    let { previousChunks } = state;
    let start = -1;
    for(let end = 0; end < chunk.length; end += 1){
        if (chunk[end] === '\n') {
            const newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);
            let line = chunk.slice(start + 1, end + 1 - newlineLength);
            if (previousChunks.length > 0) {
                line = concatString(previousChunks, line);
                previousChunks = '';
            }
            yield line;
            start = end;
        }
    }
    if (start !== chunk.length - 1) {
        previousChunks = concatString(previousChunks, chunk.slice(start + 1));
    }
    state.previousChunks = previousChunks;
};
const getNewlineLength = (chunk, end, preserveNewlines, state)=>{
    if (preserveNewlines) {
        return 0;
    }
    state.isWindowsNewline = end !== 0 && chunk[end - 1] === '\r';
    return state.isWindowsNewline ? 2 : 1;
};
const linesFinal = function*(param) {
    let { previousChunks } = param;
    if (previousChunks.length > 0) {
        yield previousChunks;
    }
};
const getAppendNewlineGenerator = (param)=>{
    let { binary, preserveNewlines, readableObjectMode, state } = param;
    return binary || preserveNewlines || readableObjectMode ? undefined : {
        transform: appendNewlineGenerator.bind(undefined, state)
    };
};
const appendNewlineGenerator = function*(param, chunk) {
    let { isWindowsNewline = false } = param;
    const { unixNewline, windowsNewline, LF, concatBytes } = typeof chunk === 'string' ? linesStringInfo : linesUint8ArrayInfo;
    if (chunk.at(-1) === LF) {
        yield chunk;
        return;
    }
    const newline = isWindowsNewline ? windowsNewline : unixNewline;
    yield concatBytes(chunk, newline);
};
const concatString = (firstChunk, secondChunk)=>"".concat(firstChunk).concat(secondChunk);
const linesStringInfo = {
    windowsNewline: '\r\n',
    unixNewline: '\n',
    LF: '\n',
    concatBytes: concatString
};
const concatUint8Array = (firstChunk, secondChunk)=>{
    const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
    chunk.set(firstChunk, 0);
    chunk.set(secondChunk, firstChunk.length);
    return chunk;
};
const linesUint8ArrayInfo = {
    windowsNewline: new Uint8Array([
        0x0D,
        0x0A
    ]),
    unixNewline: new Uint8Array([
        0x0A
    ]),
    LF: 0x0A,
    concatBytes: concatUint8Array
};
}),
"[project]/node_modules/execa/lib/transform/validate.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getValidateTransformInput",
    ()=>getValidateTransformInput,
    "getValidateTransformReturn",
    ()=>getValidateTransformReturn
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-client] (ecmascript)");
;
;
const getValidateTransformInput = (writableObjectMode, optionName)=>writableObjectMode ? undefined : validateStringTransformInput.bind(undefined, optionName);
const validateStringTransformInput = function*(optionName, chunk) {
    if (typeof chunk !== 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUint8Array"])(chunk) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(chunk)) {
        throw new TypeError("The `".concat(optionName, '` option\'s transform must use "objectMode: true" to receive as input: ').concat(typeof chunk, "."));
    }
    yield chunk;
};
const getValidateTransformReturn = (readableObjectMode, optionName)=>readableObjectMode ? validateObjectTransformReturn.bind(undefined, optionName) : validateStringTransformReturn.bind(undefined, optionName);
const validateObjectTransformReturn = function*(optionName, chunk) {
    validateEmptyReturn(optionName, chunk);
    yield chunk;
};
const validateStringTransformReturn = function*(optionName, chunk) {
    validateEmptyReturn(optionName, chunk);
    if (typeof chunk !== 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUint8Array"])(chunk)) {
        throw new TypeError("The `".concat(optionName, "` option's function must yield a string or an Uint8Array, not ").concat(typeof chunk, "."));
    }
    yield chunk;
};
const validateEmptyReturn = (optionName, chunk)=>{
    if (chunk === null || chunk === undefined) {
        throw new TypeError("The `".concat(optionName, "` option's function must not call `yield ").concat(chunk, "`.\nInstead, `yield` should either be called with a value, or not be called at all. For example:\n  if (condition) { yield value; }"));
    }
};
}),
"[project]/node_modules/execa/lib/transform/encoding-transform.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getEncodingTransformGenerator",
    ()=>getEncodingTransformGenerator
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$string_decoder$2f$string_decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/string_decoder/string_decoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-client] (ecmascript)");
;
;
;
const getEncodingTransformGenerator = (binary, encoding, skipped)=>{
    if (skipped) {
        return;
    }
    if (binary) {
        return {
            transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder())
        };
    }
    const stringDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$string_decoder$2f$string_decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StringDecoder"](encoding);
    return {
        transform: encodingStringGenerator.bind(undefined, stringDecoder),
        final: encodingStringFinal.bind(undefined, stringDecoder)
    };
};
const encodingUint8ArrayGenerator = function*(textEncoder, chunk) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(chunk)) {
        yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bufferToUint8Array"])(chunk);
    } else if (typeof chunk === 'string') {
        yield textEncoder.encode(chunk);
    } else {
        yield chunk;
    }
};
const encodingStringGenerator = function*(stringDecoder, chunk) {
    yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUint8Array"])(chunk) ? stringDecoder.write(chunk) : chunk;
};
const encodingStringFinal = function*(stringDecoder) {
    const lastChunk = stringDecoder.end();
    if (lastChunk !== '') {
        yield lastChunk;
    }
};
}),
"[project]/node_modules/execa/lib/transform/run-async.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "destroyTransform",
    ()=>destroyTransform,
    "finalChunks",
    ()=>finalChunks,
    "pushChunks",
    ()=>pushChunks,
    "transformChunk",
    ()=>transformChunk
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
;
const pushChunks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackify"])(async (getChunks, state, getChunksArguments, transformStream)=>{
    state.currentIterable = getChunks(...getChunksArguments);
    try {
        for await (const chunk of state.currentIterable){
            transformStream.push(chunk);
        }
    } finally{
        delete state.currentIterable;
    }
});
const transformChunk = async function*(chunk, generators, index) {
    if (index === generators.length) {
        yield chunk;
        return;
    }
    const { transform = identityGenerator } = generators[index];
    for await (const transformedChunk of transform(chunk)){
        yield* transformChunk(transformedChunk, generators, index + 1);
    }
};
const finalChunks = async function*(generators) {
    for (const [index, { final }] of Object.entries(generators)){
        yield* generatorFinalChunks(final, Number(index), generators);
    }
};
const generatorFinalChunks = async function*(final, index, generators) {
    if (final === undefined) {
        return;
    }
    for await (const finalChunk of final()){
        yield* transformChunk(finalChunk, generators, index + 1);
    }
};
const destroyTransform = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackify"])(async (param, error)=>{
    let { currentIterable } = param;
    if (currentIterable !== undefined) {
        await (error ? currentIterable.throw(error) : currentIterable.return());
        return;
    }
    if (error) {
        throw error;
    }
});
const identityGenerator = function*(chunk) {
    yield chunk;
};
}),
"[project]/node_modules/execa/lib/transform/run-sync.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Duplicate the code from `run-async.js` but as synchronous functions
__turbopack_context__.s([
    "finalChunksSync",
    ()=>finalChunksSync,
    "pushChunksSync",
    ()=>pushChunksSync,
    "runTransformSync",
    ()=>runTransformSync,
    "transformChunkSync",
    ()=>transformChunkSync
]);
const pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done)=>{
    try {
        for (const chunk of getChunksSync(...getChunksArguments)){
            transformStream.push(chunk);
        }
        done();
    } catch (error) {
        done(error);
    }
};
const runTransformSync = (generators, chunks)=>[
        ...chunks.flatMap((chunk)=>[
                ...transformChunkSync(chunk, generators, 0)
            ]),
        ...finalChunksSync(generators)
    ];
const transformChunkSync = function*(chunk, generators, index) {
    if (index === generators.length) {
        yield chunk;
        return;
    }
    const { transform = identityGenerator } = generators[index];
    for (const transformedChunk of transform(chunk)){
        yield* transformChunkSync(transformedChunk, generators, index + 1);
    }
};
const finalChunksSync = function*(generators) {
    for (const [index, { final }] of Object.entries(generators)){
        yield* generatorFinalChunksSync(final, Number(index), generators);
    }
};
const generatorFinalChunksSync = function*(final, index, generators) {
    if (final === undefined) {
        return;
    }
    for (const finalChunk of final()){
        yield* transformChunkSync(finalChunk, generators, index + 1);
    }
};
const identityGenerator = function*(chunk) {
    yield chunk;
};
}),
"[project]/node_modules/execa/lib/transform/generator.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generatorToStream",
    ()=>generatorToStream,
    "runGeneratorsSync",
    ()=>runGeneratorsSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/split.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/validate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$encoding$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/encoding-transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/run-async.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/run-sync.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const generatorToStream = (param, param1)=>{
    let { value, value: { transform, final, writableObjectMode, readableObjectMode }, optionName } = param, { encoding } = param1;
    const state = {};
    const generators = addInternalGenerators(value, encoding, optionName);
    const transformAsync = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAsyncGenerator"])(transform);
    const finalAsync = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAsyncGenerator"])(final);
    const transformMethod = transformAsync ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pushChunks"].bind(undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformChunk"], state) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pushChunksSync"].bind(undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformChunkSync"]);
    const finalMethod = transformAsync || finalAsync ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pushChunks"].bind(undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finalChunks"], state) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pushChunksSync"].bind(undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finalChunksSync"]);
    const destroyMethod = transformAsync || finalAsync ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["destroyTransform"].bind(undefined, state) : undefined;
    const stream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transform"]({
        writableObjectMode,
        writableHighWaterMark: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultHighWaterMark"])(writableObjectMode),
        readableObjectMode,
        readableHighWaterMark: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultHighWaterMark"])(readableObjectMode),
        transform (chunk, encoding, done) {
            transformMethod([
                chunk,
                generators,
                0
            ], this, done);
        },
        flush (done) {
            finalMethod([
                generators
            ], this, done);
        },
        destroy: destroyMethod
    });
    return {
        stream
    };
};
const runGeneratorsSync = (chunks, stdioItems, encoding, isInput)=>{
    const generators = stdioItems.filter((param)=>{
        let { type } = param;
        return type === 'generator';
    });
    const reversedGenerators = isInput ? generators.reverse() : generators;
    for (const { value, optionName } of reversedGenerators){
        const generators = addInternalGenerators(value, encoding, optionName);
        chunks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["runTransformSync"])(generators, chunks);
    }
    return chunks;
};
// Generators used internally to convert the chunk type, validate it, and split into lines
const addInternalGenerators = (param, encoding, optionName)=>{
    let { transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines } = param;
    const state = {};
    return [
        {
            transform: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getValidateTransformInput"])(writableObjectMode, optionName)
        },
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$encoding$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEncodingTransformGenerator"])(binary, encoding, writableObjectMode),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSplitLinesGenerator"])(binary, preserveNewlines, writableObjectMode, state),
        {
            transform,
            final
        },
        {
            transform: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getValidateTransformReturn"])(readableObjectMode, optionName)
        },
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAppendNewlineGenerator"])({
            binary,
            preserveNewlines,
            readableObjectMode,
            state
        })
    ].filter(Boolean);
};
}),
"[project]/node_modules/execa/lib/io/input-sync.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addInputOptionsSync",
    ()=>addInputOptionsSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/generator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
;
;
;
const addInputOptionsSync = (fileDescriptors, options)=>{
    for (const fdNumber of getInputFdNumbers(fileDescriptors)){
        addInputOptionSync(fileDescriptors, fdNumber, options);
    }
};
const getInputFdNumbers = (fileDescriptors)=>new Set(Object.entries(fileDescriptors).filter((param)=>{
        let [, { direction }] = param;
        return direction === 'input';
    }).map((param)=>{
        let [fdNumber] = param;
        return Number(fdNumber);
    }));
const addInputOptionSync = (fileDescriptors, fdNumber, options)=>{
    const { stdioItems } = fileDescriptors[fdNumber];
    const allStdioItems = stdioItems.filter((param)=>{
        let { contents } = param;
        return contents !== undefined;
    });
    if (allStdioItems.length === 0) {
        return;
    }
    if (fdNumber !== 0) {
        const [{ type, optionName }] = allStdioItems;
        throw new TypeError("Only the `stdin` option, not `".concat(optionName, "`, can be ").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE_TO_MESSAGE"][type], " with synchronous methods."));
    }
    const allContents = allStdioItems.map((param)=>{
        let { contents } = param;
        return contents;
    });
    const transformedContents = allContents.map((contents)=>applySingleInputGeneratorsSync(contents, stdioItems));
    options.input = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinToUint8Array"])(transformedContents);
};
const applySingleInputGeneratorsSync = (contents, stdioItems)=>{
    const newContents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["runGeneratorsSync"])(contents, stdioItems, 'utf8', true);
    validateSerializable(newContents);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinToUint8Array"])(newContents);
};
const validateSerializable = (newContents)=>{
    const invalidItem = newContents.find((item)=>typeof item !== 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUint8Array"])(item));
    if (invalidItem !== undefined) {
        throw new TypeError("The `stdin` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ".concat(invalidItem, "."));
    }
};
}),
"[project]/node_modules/execa/lib/verbose/output.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logLines",
    ()=>logLines,
    "logLinesSync",
    ()=>logLinesSync,
    "shouldLogOutput",
    ()=>shouldLogOutput
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-client] (ecmascript)");
;
;
;
;
const shouldLogOutput = (param)=>{
    let { stdioItems, encoding, verboseInfo, fdNumber } = param;
    return fdNumber !== 'all' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFullVerbose"])(verboseInfo, fdNumber) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(encoding) && fdUsesVerbose(fdNumber) && (stdioItems.some((param)=>{
        let { type, value } = param;
        return type === 'native' && PIPED_STDIO_VALUES.has(value);
    }) || stdioItems.every((param)=>{
        let { type } = param;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type);
    }));
};
// Printing input streams would be confusing.
// Files and streams can produce big outputs, which we don't want to print.
// We could print `stdio[3+]` but it often is redirected to files and streams, with the same issue.
// So we only print stdout and stderr.
const fdUsesVerbose = (fdNumber)=>fdNumber === 1 || fdNumber === 2;
const PIPED_STDIO_VALUES = new Set([
    'pipe',
    'overlapped'
]);
const logLines = async (linesIterable, stream, fdNumber, verboseInfo)=>{
    for await (const line of linesIterable){
        if (!isPipingStream(stream)) {
            logLine(line, fdNumber, verboseInfo);
        }
    }
};
const logLinesSync = (linesArray, fdNumber, verboseInfo)=>{
    for (const line of linesArray){
        logLine(line, fdNumber, verboseInfo);
    }
};
// When `subprocess.stdout|stderr.pipe()` is called, `verbose` becomes a noop.
// This prevents the following problems:
//  - `.pipe()` achieves the same result as using `stdout: 'inherit'`, `stdout: stream`, etc. which also make `verbose` a noop.
//    For example, `subprocess.stdout.pipe(process.stdin)` would print each line twice.
//  - When chaining subprocesses with `subprocess.pipe(otherSubprocess)`, only the last one should print its output.
// Detecting whether `.pipe()` is impossible without monkey-patching it, so we use the following undocumented property.
// This is not a critical behavior since changes of the following property would only make `verbose` more verbose.
const isPipingStream = (stream)=>stream._readableState.pipes.length > 0;
// When `verbose` is `full`, print stdout|stderr
const logLine = (line, fdNumber, verboseInfo)=>{
    const verboseMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serializeVerboseMessage"])(line);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verboseLog"])({
        type: 'output',
        verboseMessage,
        fdNumber,
        verboseInfo
    });
};
}),
"[project]/node_modules/execa/lib/io/output-sync.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/io/output-sync.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:fs)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/io/output-sync.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:fs)");

}}),
"[project]/node_modules/execa/lib/resolve/all-sync.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getAllSync",
    ()=>getAllSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/uint-array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/strip-newline.js [app-client] (ecmascript)");
;
;
const getAllSync = (param, options)=>{
    let [, stdout, stderr] = param;
    if (!options.all) {
        return;
    }
    if (stdout === undefined) {
        return stderr;
    }
    if (stderr === undefined) {
        return stdout;
    }
    if (Array.isArray(stdout)) {
        return Array.isArray(stderr) ? [
            ...stdout,
            ...stderr
        ] : [
            ...stdout,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stripNewline"])(stderr, options, 'all')
        ];
    }
    if (Array.isArray(stderr)) {
        return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$strip$2d$newline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stripNewline"])(stdout, options, 'all'),
            ...stderr
        ];
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUint8Array"])(stdout) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUint8Array"])(stderr)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$uint$2d$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concatUint8Arrays"])([
            stdout,
            stderr
        ]);
    }
    return "".concat(stdout).concat(stderr);
};
}),
"[project]/node_modules/execa/lib/resolve/exit-async.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isFailedExit",
    ()=>isFailedExit,
    "waitForExit",
    ()=>waitForExit,
    "waitForSuccessfulExit",
    ()=>waitForSuccessfulExit
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/final-error.js [app-client] (ecmascript)");
;
;
const waitForExit = async (subprocess, context)=>{
    var _context;
    const [exitCode, signal] = await waitForExitOrError(subprocess);
    var _isForcefullyTerminated;
    (_isForcefullyTerminated = (_context = context).isForcefullyTerminated) !== null && _isForcefullyTerminated !== void 0 ? _isForcefullyTerminated : _context.isForcefullyTerminated = false;
    return [
        exitCode,
        signal
    ];
};
const waitForExitOrError = async (subprocess)=>{
    const [spawnPayload, exitPayload] = await Promise.allSettled([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(subprocess, 'spawn'),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(subprocess, 'exit')
    ]);
    if (spawnPayload.status === 'rejected') {
        return [];
    }
    return exitPayload.status === 'rejected' ? waitForSubprocessExit(subprocess) : exitPayload.value;
};
const waitForSubprocessExit = async (subprocess)=>{
    try {
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(subprocess, 'exit');
    } catch (e) {
        return waitForSubprocessExit(subprocess);
    }
};
const waitForSuccessfulExit = async (exitPromise)=>{
    const [exitCode, signal] = await exitPromise;
    if (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DiscardedError"]();
    }
    return [
        exitCode,
        signal
    ];
};
// When the subprocess fails due to an `error` event
const isSubprocessErrorExit = (exitCode, signal)=>exitCode === undefined && signal === undefined;
const isFailedExit = (exitCode, signal)=>exitCode !== 0 || signal !== null;
}),
"[project]/node_modules/execa/lib/resolve/exit-sync.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getExitResultSync",
    ()=>getExitResultSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/final-error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/max-buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/exit-async.js [app-client] (ecmascript)");
;
;
;
const getExitResultSync = (param, param1)=>{
    let { error, status: exitCode, signal, output } = param, { maxBuffer } = param1;
    const resultError = getResultError(error, exitCode, signal);
    const timedOut = (resultError === null || resultError === void 0 ? void 0 : resultError.code) === 'ETIMEDOUT';
    const isMaxBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMaxBufferSync"])(resultError, output, maxBuffer);
    return {
        resultError,
        exitCode,
        signal,
        timedOut,
        isMaxBuffer
    };
};
const getResultError = (error, exitCode, signal)=>{
    if (error !== undefined) {
        return error;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFailedExit"])(exitCode, signal) ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$final$2d$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DiscardedError"]() : undefined;
};
}),
"[project]/node_modules/execa/lib/methods/main-sync.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/methods/main-sync.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:child_process)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/methods/main-sync.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:child_process)");

}}),
"[project]/node_modules/execa/lib/ipc/get-one.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getOneMessage",
    ()=>getOneMessage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/validation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/forward.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/reference.js [app-client] (ecmascript)");
;
;
;
;
const getOneMessage = function(param) {
    let { anyProcess, channel, isSubprocess, ipc } = param, { reference = true, filter } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIpcMethod"])({
        methodName: 'getOneMessage',
        isSubprocess,
        ipc,
        isConnected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConnected"])(anyProcess)
    });
    return getOneMessageAsync({
        anyProcess,
        channel,
        isSubprocess,
        filter,
        reference
    });
};
const getOneMessageAsync = async (param)=>{
    let { anyProcess, channel, isSubprocess, filter, reference } = param;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addReference"])(channel, reference);
    const ipcEmitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getIpcEmitter"])(anyProcess, channel, isSubprocess);
    const controller = new AbortController();
    try {
        return await Promise.race([
            getMessage(ipcEmitter, filter, controller),
            throwOnDisconnect(ipcEmitter, isSubprocess, controller),
            throwOnStrictError(ipcEmitter, isSubprocess, controller)
        ]);
    } catch (error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["disconnect"])(anyProcess);
        throw error;
    } finally{
        controller.abort();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["removeReference"])(channel, reference);
    }
};
const getMessage = async (ipcEmitter, filter, param)=>{
    let { signal } = param;
    if (filter === undefined) {
        const [message] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(ipcEmitter, 'message', {
            signal
        });
        return message;
    }
    for await (const [message] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["on"])(ipcEmitter, 'message', {
        signal
    })){
        if (filter(message)) {
            return message;
        }
    }
};
const throwOnDisconnect = async (ipcEmitter, isSubprocess, param)=>{
    let { signal } = param;
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(ipcEmitter, 'disconnect', {
        signal
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwOnEarlyDisconnect"])(isSubprocess);
};
const throwOnStrictError = async (ipcEmitter, isSubprocess, param)=>{
    let { signal } = param;
    const [error] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(ipcEmitter, 'strict:error', {
        signal
    });
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStrictResponseError"])(error, isSubprocess);
};
}),
"[project]/node_modules/execa/lib/ipc/get-each.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getEachMessage",
    ()=>getEachMessage,
    "loopOnMessages",
    ()=>loopOnMessages
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/validation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/forward.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/reference.js [app-client] (ecmascript)");
;
;
;
;
const getEachMessage = function(param) {
    let { anyProcess, channel, isSubprocess, ipc } = param, { reference = true } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return loopOnMessages({
        anyProcess,
        channel,
        isSubprocess,
        ipc,
        shouldAwait: !isSubprocess,
        reference
    });
};
const loopOnMessages = (param)=>{
    let { anyProcess, channel, isSubprocess, ipc, shouldAwait, reference } = param;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateIpcMethod"])({
        methodName: 'getEachMessage',
        isSubprocess,
        ipc,
        isConnected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConnected"])(anyProcess)
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addReference"])(channel, reference);
    const ipcEmitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$forward$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getIpcEmitter"])(anyProcess, channel, isSubprocess);
    const controller = new AbortController();
    const state = {};
    stopOnDisconnect(anyProcess, ipcEmitter, controller);
    abortOnStrictError({
        ipcEmitter,
        isSubprocess,
        controller,
        state
    });
    return iterateOnMessages({
        anyProcess,
        channel,
        ipcEmitter,
        isSubprocess,
        shouldAwait,
        controller,
        state,
        reference
    });
};
const stopOnDisconnect = async (anyProcess, ipcEmitter, controller)=>{
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(ipcEmitter, 'disconnect', {
            signal: controller.signal
        });
        controller.abort();
    } catch (e) {}
};
const abortOnStrictError = async (param)=>{
    let { ipcEmitter, isSubprocess, controller, state } = param;
    try {
        const [error] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(ipcEmitter, 'strict:error', {
            signal: controller.signal
        });
        state.error = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStrictResponseError"])(error, isSubprocess);
        controller.abort();
    } catch (e) {}
};
const iterateOnMessages = async function*(param) {
    let { anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference } = param;
    try {
        for await (const [message] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["on"])(ipcEmitter, 'message', {
            signal: controller.signal
        })){
            throwIfStrictError(state);
            yield message;
        }
    } catch (e) {
        throwIfStrictError(state);
    } finally{
        controller.abort();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$reference$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["removeReference"])(channel, reference);
        if (!isSubprocess) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$validation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["disconnect"])(anyProcess);
        }
        if (shouldAwait) {
            await anyProcess;
        }
    }
};
const throwIfStrictError = (param)=>{
    let { error } = param;
    if (error) {
        throw error;
    }
};
}),
"[project]/node_modules/execa/lib/ipc/methods.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addIpcMethods",
    ()=>addIpcMethods,
    "getIpcExport",
    ()=>getIpcExport
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$send$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/send.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$one$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/get-one.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$each$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/get-each.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/graceful.js [app-client] (ecmascript)");
;
;
;
;
;
const addIpcMethods = (subprocess, param)=>{
    let { ipc } = param;
    Object.assign(subprocess, getIpcMethods(subprocess, false, ipc));
};
const getIpcExport = ()=>{
    const anyProcess = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    const isSubprocess = true;
    const ipc = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].channel !== undefined;
    return {
        ...getIpcMethods(anyProcess, isSubprocess, ipc),
        getCancelSignal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$graceful$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCancelSignal"].bind(undefined, {
            anyProcess,
            channel: anyProcess.channel,
            isSubprocess,
            ipc
        })
    };
};
// Retrieve the `ipc` shared by both the current process and the subprocess
const getIpcMethods = (anyProcess, isSubprocess, ipc)=>({
        sendMessage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$send$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sendMessage"].bind(undefined, {
            anyProcess,
            channel: anyProcess.channel,
            isSubprocess,
            ipc
        }),
        getOneMessage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$one$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOneMessage"].bind(undefined, {
            anyProcess,
            channel: anyProcess.channel,
            isSubprocess,
            ipc
        }),
        getEachMessage: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$each$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEachMessage"].bind(undefined, {
            anyProcess,
            channel: anyProcess.channel,
            isSubprocess,
            ipc
        })
    });
}),
"[project]/node_modules/execa/lib/return/early-error.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/return/early-error.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:child_process)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/return/early-error.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:child_process)");

}}),
"[project]/node_modules/execa/lib/stdio/handle-async.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/stdio/handle-async.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:fs)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/stdio/handle-async.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:fs)");

}}),
"[project]/node_modules/execa/lib/io/pipeline.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/io/pipeline.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:stream/promises)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/io/pipeline.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:stream/promises)");

}}),
"[project]/node_modules/execa/lib/io/output-async.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "pipeOutputAsync",
    ()=>pipeOutputAsync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$merge$2d$streams$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/merge-streams/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/max-listeners.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/pipeline.js [app-client] (ecmascript)");
;
;
;
;
;
const pipeOutputAsync = (subprocess, fileDescriptors, controller)=>{
    const pipeGroups = new Map();
    for (const [fdNumber, { stdioItems, direction }] of Object.entries(fileDescriptors)){
        for (const { stream } of stdioItems.filter((param)=>{
            let { type } = param;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type);
        })){
            pipeTransform(subprocess, stream, direction, fdNumber);
        }
        for (const { stream } of stdioItems.filter((param)=>{
            let { type } = param;
            return !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type);
        })){
            pipeStdioItem({
                subprocess,
                stream,
                direction,
                fdNumber,
                pipeGroups,
                controller
            });
        }
    }
    for (const [outputStream, inputStreams] of pipeGroups.entries()){
        const inputStream = inputStreams.length === 1 ? inputStreams[0] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$merge$2d$streams$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(inputStreams);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipeStreams"])(inputStream, outputStream);
    }
};
// When using transforms, `subprocess.stdin|stdout|stderr|stdio` is directly mutated
const pipeTransform = (subprocess, stream, direction, fdNumber)=>{
    if (direction === 'output') {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipeStreams"])(subprocess.stdio[fdNumber], stream);
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipeStreams"])(stream, subprocess.stdio[fdNumber]);
    }
    const streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];
    if (streamProperty !== undefined) {
        subprocess[streamProperty] = stream;
    }
    subprocess.stdio[fdNumber] = stream;
};
const SUBPROCESS_STREAM_PROPERTIES = [
    'stdin',
    'stdout',
    'stderr'
];
// Most `std*` option values involve piping `subprocess.std*` to a stream.
// The stream is either passed by the user or created internally.
const pipeStdioItem = (param)=>{
    let { subprocess, stream, direction, fdNumber, pipeGroups, controller } = param;
    if (stream === undefined) {
        return;
    }
    setStandardStreamMaxListeners(stream, controller);
    const [inputStream, outputStream] = direction === 'output' ? [
        stream,
        subprocess.stdio[fdNumber]
    ] : [
        subprocess.stdio[fdNumber],
        stream
    ];
    var _pipeGroups_get;
    const outputStreams = (_pipeGroups_get = pipeGroups.get(inputStream)) !== null && _pipeGroups_get !== void 0 ? _pipeGroups_get : [];
    pipeGroups.set(inputStream, [
        ...outputStreams,
        outputStream
    ]);
};
// Multiple subprocesses might be piping from/to `process.std*` at the same time.
// This is not necessarily an error and should not print a `maxListeners` warning.
const setStandardStreamMaxListeners = (stream, param)=>{
    let { signal } = param;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStandardStream"])(stream)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$max$2d$listeners$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["incrementMaxListeners"])(stream, MAX_LISTENERS_INCREMENT, signal);
    }
};
// `source.pipe(destination)` adds at most 1 listener for each event.
// If `stdin` option is an array, the values might be combined with `merge-streams`.
// That library also listens for `source` end, which adds 1 more listener.
const MAX_LISTENERS_INCREMENT = 2;
}),
"[project]/node_modules/execa/lib/terminate/cleanup.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cleanupOnExit",
    ()=>cleanupOnExit
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$signal$2d$exit$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/signal-exit/dist/mjs/index.js [app-client] (ecmascript) <locals>");
;
;
const cleanupOnExit = (subprocess, param, param1)=>{
    let { cleanup, detached } = param, { signal } = param1;
    if (!cleanup || detached) {
        return;
    }
    const removeExitHandler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$signal$2d$exit$2f$dist$2f$mjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["onExit"])(()=>{
        subprocess.kill();
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addAbortListener"])(signal, ()=>{
        removeExitHandler();
    });
};
}),
"[project]/node_modules/execa/lib/pipe/pipe-arguments.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizePipeArguments",
    ()=>normalizePipeArguments
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/parameters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/duration.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/file-url.js [app-client] (ecmascript)");
;
;
;
;
const normalizePipeArguments = function(param) {
    let { source, sourcePromise, boundOptions, createNested } = param;
    for(var _len = arguments.length, pipeArguments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        pipeArguments[_key - 1] = arguments[_key];
    }
    const startTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$duration$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStartTime"])();
    const { destination, destinationStream, destinationError, from, unpipeSignal } = getDestinationStream(boundOptions, createNested, pipeArguments);
    const { sourceStream, sourceError } = getSourceStream(source, from);
    const { options: sourceOptions, fileDescriptors } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUBPROCESS_OPTIONS"].get(source);
    return {
        sourcePromise,
        sourceStream,
        sourceOptions,
        sourceError,
        destination,
        destinationStream,
        destinationError,
        unpipeSignal,
        fileDescriptors,
        startTime
    };
};
const getDestinationStream = (boundOptions, createNested, pipeArguments)=>{
    try {
        const { destination, pipeOptions: { from, to, unpipeSignal } = {} } = getDestination(boundOptions, createNested, ...pipeArguments);
        const destinationStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getToStream"])(destination, to);
        return {
            destination,
            destinationStream,
            from,
            unpipeSignal
        };
    } catch (error) {
        return {
            destinationError: error
        };
    }
};
// Piping subprocesses can use three syntaxes:
//  - source.pipe('command', commandArguments, pipeOptionsOrDestinationOptions)
//  - source.pipe`command commandArgument` or source.pipe(pipeOptionsOrDestinationOptions)`command commandArgument`
//  - source.pipe(execa(...), pipeOptions)
const getDestination = function(boundOptions, createNested, firstArgument) {
    for(var _len = arguments.length, pipeArguments = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
        pipeArguments[_key - 3] = arguments[_key];
    }
    if (Array.isArray(firstArgument)) {
        const destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);
        return {
            destination,
            pipeOptions: boundOptions
        };
    }
    if (typeof firstArgument === 'string' || firstArgument instanceof URL || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$file$2d$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDenoExecPath"])(firstArgument)) {
        if (Object.keys(boundOptions).length > 0) {
            throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');
        }
        const [rawFile, rawArguments, rawOptions] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeParameters"])(firstArgument, ...pipeArguments);
        const destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);
        return {
            destination,
            pipeOptions: rawOptions
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUBPROCESS_OPTIONS"].has(firstArgument)) {
        if (Object.keys(boundOptions).length > 0) {
            throw new TypeError('Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).');
        }
        return {
            destination: firstArgument,
            pipeOptions: pipeArguments[0]
        };
    }
    throw new TypeError("The first argument must be a template string, an options object, or an Execa subprocess: ".concat(firstArgument));
};
// Force `stdin: 'pipe'` with the destination subprocess
const mapDestinationArguments = (param)=>{
    let { options } = param;
    return {
        options: {
            ...options,
            stdin: 'pipe',
            piped: true
        }
    };
};
const getSourceStream = (source, from)=>{
    try {
        const sourceStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFromStream"])(source, from);
        return {
            sourceStream
        };
    } catch (error) {
        return {
            sourceError: error
        };
    }
};
}),
"[project]/node_modules/execa/lib/pipe/throw.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createNonCommandError",
    ()=>createNonCommandError,
    "handlePipeArgumentsError",
    ()=>handlePipeArgumentsError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/return/result.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/pipeline.js [app-client] (ecmascript)");
;
;
const handlePipeArgumentsError = (param)=>{
    let { sourceStream, sourceError, destinationStream, destinationError, fileDescriptors, sourceOptions, startTime } = param;
    const error = getPipeArgumentsError({
        sourceStream,
        sourceError,
        destinationStream,
        destinationError
    });
    if (error !== undefined) {
        throw createNonCommandError({
            error,
            fileDescriptors,
            sourceOptions,
            startTime
        });
    }
};
const getPipeArgumentsError = (param)=>{
    let { sourceStream, sourceError, destinationStream, destinationError } = param;
    if (sourceError !== undefined && destinationError !== undefined) {
        return destinationError;
    }
    if (destinationError !== undefined) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abortSourceStream"])(sourceStream);
        return destinationError;
    }
    if (sourceError !== undefined) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$pipeline$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["endDestinationStream"])(destinationStream);
        return sourceError;
    }
};
const createNonCommandError = (param)=>{
    let { error, fileDescriptors, sourceOptions, startTime } = param;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$return$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeEarlyError"])({
        error,
        command: PIPE_COMMAND_MESSAGE,
        escapedCommand: PIPE_COMMAND_MESSAGE,
        fileDescriptors,
        options: sourceOptions,
        startTime,
        isSync: false
    });
};
const PIPE_COMMAND_MESSAGE = 'source.pipe(destination)';
}),
"[project]/node_modules/execa/lib/pipe/sequence.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Like Bash, we await both subprocesses. This is unlike some other shells which only await the destination subprocess.
// Like Bash with the `pipefail` option, if either subprocess fails, the whole pipe fails.
// Like Bash, if both subprocesses fail, we return the failure of the destination.
// This ensures both subprocesses' errors are present, using `error.pipedFrom`.
__turbopack_context__.s([
    "waitForBothSubprocesses",
    ()=>waitForBothSubprocesses
]);
const waitForBothSubprocesses = async (subprocessPromises)=>{
    const [{ status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason }, { status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason }] = await subprocessPromises;
    if (!destinationResult.pipedFrom.includes(sourceResult)) {
        destinationResult.pipedFrom.push(sourceResult);
    }
    if (destinationStatus === 'rejected') {
        throw destinationResult;
    }
    if (sourceStatus === 'rejected') {
        throw sourceResult;
    }
    return destinationResult;
};
}),
"[project]/node_modules/execa/lib/pipe/streaming.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/pipe/streaming.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:stream/promises)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/pipe/streaming.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:stream/promises)");

}}),
"[project]/node_modules/execa/lib/pipe/abort.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unpipeOnAbort",
    ()=>unpipeOnAbort
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$throw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/throw.js [app-client] (ecmascript)");
;
;
const unpipeOnAbort = (unpipeSignal, unpipeContext)=>unpipeSignal === undefined ? [] : [
        unpipeOnSignalAbort(unpipeSignal, unpipeContext)
    ];
const unpipeOnSignalAbort = async (unpipeSignal, param)=>{
    let { sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime } = param;
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aborted"])(unpipeSignal, sourceStream);
    await mergedStream.remove(sourceStream);
    const error = new Error('Pipe canceled by `unpipeSignal` option.');
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$throw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNonCommandError"])({
        error,
        fileDescriptors,
        sourceOptions,
        startTime
    });
};
}),
"[project]/node_modules/execa/lib/pipe/setup.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "pipeToSubprocess",
    ()=>pipeToSubprocess
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$pipe$2d$arguments$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/pipe-arguments.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$throw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/throw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$sequence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/sequence.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$streaming$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/streaming.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$abort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/pipe/abort.js [app-client] (ecmascript)");
;
;
;
;
;
;
const pipeToSubprocess = function(sourceInfo) {
    for(var _len = arguments.length, pipeArguments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        pipeArguments[_key - 1] = arguments[_key];
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pipeArguments[0])) {
        return pipeToSubprocess.bind(undefined, {
            ...sourceInfo,
            boundOptions: {
                ...sourceInfo.boundOptions,
                ...pipeArguments[0]
            }
        });
    }
    const { destination, ...normalizedInfo } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$pipe$2d$arguments$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizePipeArguments"])(sourceInfo, ...pipeArguments);
    const promise = handlePipePromise({
        ...normalizedInfo,
        destination
    });
    promise.pipe = pipeToSubprocess.bind(undefined, {
        ...sourceInfo,
        source: destination,
        sourcePromise: promise,
        boundOptions: {}
    });
    return promise;
};
// Asynchronous logic when piping subprocesses
const handlePipePromise = async (param)=>{
    let { sourcePromise, sourceStream, sourceOptions, sourceError, destination, destinationStream, destinationError, unpipeSignal, fileDescriptors, startTime } = param;
    const subprocessPromises = getSubprocessPromises(sourcePromise, destination);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$throw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["handlePipeArgumentsError"])({
        sourceStream,
        sourceError,
        destinationStream,
        destinationError,
        fileDescriptors,
        sourceOptions,
        startTime
    });
    const maxListenersController = new AbortController();
    try {
        const mergedStream = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$streaming$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipeSubprocessStream"])(sourceStream, destinationStream, maxListenersController);
        return await Promise.race([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$sequence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForBothSubprocesses"])(subprocessPromises),
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$pipe$2f$abort$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unpipeOnAbort"])(unpipeSignal, {
                sourceStream,
                mergedStream,
                sourceOptions,
                fileDescriptors,
                startTime
            })
        ]);
    } finally{
        maxListenersController.abort();
    }
};
// `.pipe()` awaits the subprocess promises.
// When invalid arguments are passed to `.pipe()`, we throw an error, which prevents awaiting them.
// We need to ensure this does not create unhandled rejections.
const getSubprocessPromises = (sourcePromise, destination)=>Promise.allSettled([
        sourcePromise,
        destination
    ]);
}),
"[project]/node_modules/execa/lib/io/iterate.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_OBJECT_HIGH_WATER_MARK",
    ()=>DEFAULT_OBJECT_HIGH_WATER_MARK,
    "iterateForResult",
    ()=>iterateForResult,
    "iterateOnSubprocessStream",
    ()=>iterateOnSubprocessStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$encoding$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/encoding-transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/split.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/transform/run-sync.js [app-client] (ecmascript)");
;
;
;
;
;
const iterateOnSubprocessStream = (param)=>{
    let { subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines } = param;
    const controller = new AbortController();
    stopReadingOnExit(subprocess, controller);
    return iterateOnStream({
        stream: subprocessStdout,
        controller,
        binary,
        shouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,
        encoding,
        shouldSplit: !subprocessStdout.readableObjectMode,
        preserveNewlines
    });
};
const stopReadingOnExit = async (subprocess, controller)=>{
    try {
        await subprocess;
    } catch (e) {} finally{
        controller.abort();
    }
};
const iterateForResult = (param)=>{
    let { stream, onStreamEnd, lines, encoding, stripFinalNewline, allMixed } = param;
    const controller = new AbortController();
    stopReadingOnStreamEnd(onStreamEnd, controller, stream);
    const objectMode = stream.readableObjectMode && !allMixed;
    return iterateOnStream({
        stream,
        controller,
        binary: encoding === 'buffer',
        shouldEncode: !objectMode,
        encoding,
        shouldSplit: !objectMode && lines,
        preserveNewlines: !stripFinalNewline
    });
};
const stopReadingOnStreamEnd = async (onStreamEnd, controller, stream)=>{
    try {
        await onStreamEnd;
    } catch (e) {
        stream.destroy();
    } finally{
        controller.abort();
    }
};
const iterateOnStream = (param)=>{
    let { stream, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines } = param;
    const onStdoutChunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["on"])(stream, 'data', {
        signal: controller.signal,
        highWaterMark: HIGH_WATER_MARK,
        // Backward compatibility with older name for this option
        // See https://github.com/nodejs/node/pull/52080#discussion_r1525227861
        // @todo Remove after removing support for Node 21
        highWatermark: HIGH_WATER_MARK
    });
    return iterateOnData({
        onStdoutChunk,
        controller,
        binary,
        shouldEncode,
        encoding,
        shouldSplit,
        preserveNewlines
    });
};
const DEFAULT_OBJECT_HIGH_WATER_MARK = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDefaultHighWaterMark"])(true);
// The `highWaterMark` of `events.on()` is measured in number of events, not in bytes.
// Not knowing the average amount of bytes per `data` event, we use the same heuristic as streams in objectMode, since they have the same issue.
// Therefore, we use the value of `getDefaultHighWaterMark(true)`.
// Note: this option does not exist on Node 18, but this is ok since the logic works without it. It just consumes more memory.
const HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;
const iterateOnData = async function*(param) {
    let { onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines } = param;
    const generators = getGenerators({
        binary,
        shouldEncode,
        encoding,
        shouldSplit,
        preserveNewlines
    });
    try {
        for await (const [chunk] of onStdoutChunk){
            yield* (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformChunkSync"])(chunk, generators, 0);
        }
    } catch (error) {
        if (!controller.signal.aborted) {
            throw error;
        }
    } finally{
        yield* (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$run$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finalChunksSync"])(generators);
    }
};
const getGenerators = (param)=>{
    let { binary, shouldEncode, encoding, shouldSplit, preserveNewlines } = param;
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$encoding$2d$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEncodingTransformGenerator"])(binary, encoding, !shouldEncode),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$transform$2f$split$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSplitLinesGenerator"])(binary, preserveNewlines, !shouldSplit, {})
    ].filter(Boolean);
};
}),
"[project]/node_modules/execa/lib/io/contents.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/io/contents.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:timers/promises)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/io/contents.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:timers/promises)");

}}),
"[project]/node_modules/execa/lib/resolve/wait-stream.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/resolve/wait-stream.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:stream/promises)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/resolve/wait-stream.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:stream/promises)");

}}),
"[project]/node_modules/execa/lib/resolve/stdio.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "waitForStdioStreams",
    ()=>waitForStdioStreams,
    "waitForSubprocessStream",
    ()=>waitForSubprocessStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$contents$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/contents.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/wait-stream.js [app-client] (ecmascript)");
;
;
const waitForStdioStreams = (param)=>{
    let { subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo } = param;
    return subprocess.stdio.map((stream, fdNumber)=>waitForSubprocessStream({
            stream,
            fdNumber,
            encoding,
            buffer: buffer[fdNumber],
            maxBuffer: maxBuffer[fdNumber],
            lines: lines[fdNumber],
            allMixed: false,
            stripFinalNewline,
            verboseInfo,
            streamInfo
        }));
};
const waitForSubprocessStream = async (param)=>{
    let { stream, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo } = param;
    if (!stream) {
        return;
    }
    const onStreamEnd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForStream"])(stream, fdNumber, streamInfo);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInputFileDescriptor"])(streamInfo, fdNumber)) {
        await onStreamEnd;
        return;
    }
    const [output] = await Promise.all([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$contents$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStreamOutput"])({
            stream,
            onStreamEnd,
            fdNumber,
            encoding,
            buffer,
            maxBuffer,
            lines,
            allMixed,
            stripFinalNewline,
            verboseInfo,
            streamInfo
        }),
        onStreamEnd
    ]);
    return output;
};
}),
"[project]/node_modules/execa/lib/resolve/all-async.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "makeAllStream",
    ()=>makeAllStream,
    "waitForAllStream",
    ()=>waitForAllStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$merge$2d$streams$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sindresorhus/merge-streams/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$stdio$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/stdio.js [app-client] (ecmascript)");
;
;
const makeAllStream = (param, param1)=>{
    let { stdout, stderr } = param, { all } = param1;
    return all && (stdout || stderr) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sindresorhus$2f$merge$2d$streams$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])([
        stdout,
        stderr
    ].filter(Boolean)) : undefined;
};
const waitForAllStream = (param)=>{
    let { subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo } = param;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$stdio$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForSubprocessStream"])({
        ...getAllStream(subprocess, buffer),
        fdNumber: 'all',
        encoding,
        maxBuffer: maxBuffer[1] + maxBuffer[2],
        lines: lines[1] || lines[2],
        allMixed: getAllMixed(subprocess),
        stripFinalNewline,
        verboseInfo,
        streamInfo
    });
};
const getAllStream = (param, param1)=>{
    let { stdout, stderr, all } = param, [, bufferStdout, bufferStderr] = param1;
    const buffer = bufferStdout || bufferStderr;
    if (!buffer) {
        return {
            stream: all,
            buffer
        };
    }
    if (!bufferStdout) {
        return {
            stream: stderr,
            buffer
        };
    }
    if (!bufferStderr) {
        return {
            stream: stdout,
            buffer
        };
    }
    return {
        stream: all,
        buffer
    };
};
// When `subprocess.stdout` is in objectMode but not `subprocess.stderr` (or the opposite), we need to use both:
//  - `getStreamAsArray()` for the chunks in objectMode, to return as an array without changing each chunk
//  - `getStreamAsArrayBuffer()` or `getStream()` for the chunks not in objectMode, to convert them from Buffers to string or Uint8Array
// We do this by emulating the Buffer -> string|Uint8Array conversion performed by `get-stream` with our own, which is identical.
const getAllMixed = (param)=>{
    let { all, stdout, stderr } = param;
    return all && stdout && stderr && stdout.readableObjectMode !== stderr.readableObjectMode;
};
}),
"[project]/node_modules/execa/lib/verbose/ipc.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "logIpcOutput",
    ()=>logIpcOutput,
    "shouldLogIpc",
    ()=>shouldLogIpc
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/values.js [app-client] (ecmascript)");
;
;
const shouldLogIpc = (verboseInfo)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFullVerbose"])(verboseInfo, 'ipc');
const logIpcOutput = (message, verboseInfo)=>{
    const verboseMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serializeVerboseMessage"])(message);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verboseLog"])({
        type: 'ipc',
        verboseMessage,
        fdNumber: 'ipc',
        verboseInfo
    });
};
}),
"[project]/node_modules/execa/lib/ipc/buffer-messages.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getBufferedIpcOutput",
    ()=>getBufferedIpcOutput,
    "waitForIpcOutput",
    ()=>waitForIpcOutput
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/max-buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$ipc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/verbose/ipc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$each$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/get-each.js [app-client] (ecmascript)");
;
;
;
;
const waitForIpcOutput = async (param)=>{
    let { subprocess, buffer: bufferArray, maxBuffer: maxBufferArray, ipc, ipcOutput, verboseInfo } = param;
    if (!ipc) {
        return ipcOutput;
    }
    const isVerbose = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$ipc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldLogIpc"])(verboseInfo);
    const buffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFdSpecificValue"])(bufferArray, 'ipc');
    const maxBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFdSpecificValue"])(maxBufferArray, 'ipc');
    for await (const message of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$get$2d$each$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loopOnMessages"])({
        anyProcess: subprocess,
        channel: subprocess.channel,
        isSubprocess: false,
        ipc,
        shouldAwait: false,
        reference: true
    })){
        if (buffer) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$max$2d$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkIpcMaxBuffer"])(subprocess, ipcOutput, maxBuffer);
            ipcOutput.push(message);
        }
        if (isVerbose) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$verbose$2f$ipc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logIpcOutput"])(message, verboseInfo);
        }
    }
    return ipcOutput;
};
const getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput)=>{
    await Promise.allSettled([
        ipcOutputPromise
    ]);
    return ipcOutput;
};
}),
"[project]/node_modules/execa/lib/resolve/wait-subprocess.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "waitForSubprocessResult",
    ()=>waitForSubprocessResult
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-stream/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$timeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/timeout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$cancel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/cancel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$graceful$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/terminate/graceful.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/standard-stream.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/stdio/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$contents$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/contents.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$buffer$2d$messages$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/buffer-messages.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$ipc$2d$input$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/ipc-input.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$all$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/all-async.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$stdio$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/stdio.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/exit-async.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/resolve/wait-stream.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const waitForSubprocessResult = async (param)=>{
    let { subprocess, options: { encoding, buffer, maxBuffer, lines, timeoutDuration: timeout, cancelSignal, gracefulCancel, forceKillAfterDelay, stripFinalNewline, ipc, ipcInput }, context, verboseInfo, fileDescriptors, originalStreams, onInternalError, controller } = param;
    const exitPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForExit"])(subprocess, context);
    const streamInfo = {
        originalStreams,
        fileDescriptors,
        subprocess,
        exitPromise,
        propagating: false
    };
    const stdioPromises = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$stdio$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForStdioStreams"])({
        subprocess,
        encoding,
        buffer,
        maxBuffer,
        lines,
        stripFinalNewline,
        verboseInfo,
        streamInfo
    });
    const allPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$all$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForAllStream"])({
        subprocess,
        encoding,
        buffer,
        maxBuffer,
        lines,
        stripFinalNewline,
        verboseInfo,
        streamInfo
    });
    const ipcOutput = [];
    const ipcOutputPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$buffer$2d$messages$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForIpcOutput"])({
        subprocess,
        buffer,
        maxBuffer,
        ipc,
        ipcOutput,
        verboseInfo
    });
    const originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);
    const customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);
    try {
        return await Promise.race([
            Promise.all([
                {},
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$exit$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForSuccessfulExit"])(exitPromise),
                Promise.all(stdioPromises),
                allPromise,
                ipcOutputPromise,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$ipc$2d$input$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sendIpcInput"])(subprocess, ipcInput),
                ...originalPromises,
                ...customStreamsEndPromises
            ]),
            onInternalError,
            throwOnSubprocessError(subprocess, controller),
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$timeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwOnTimeout"])(subprocess, timeout, context, controller),
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$cancel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwOnCancel"])({
                subprocess,
                cancelSignal,
                gracefulCancel,
                context,
                controller
            }),
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$terminate$2f$graceful$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwOnGracefulCancel"])({
                subprocess,
                cancelSignal,
                gracefulCancel,
                forceKillAfterDelay,
                context,
                controller
            })
        ]);
    } catch (error) {
        var _context;
        var _terminationReason;
        (_terminationReason = (_context = context).terminationReason) !== null && _terminationReason !== void 0 ? _terminationReason : _context.terminationReason = 'other';
        return Promise.all([
            {
                error
            },
            exitPromise,
            Promise.all(stdioPromises.map((stdioPromise)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$contents$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBufferedData"])(stdioPromise))),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$contents$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBufferedData"])(allPromise),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$buffer$2d$messages$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBufferedIpcOutput"])(ipcOutputPromise, ipcOutput),
            Promise.allSettled(originalPromises),
            Promise.allSettled(customStreamsEndPromises)
        ]);
    }
};
// Transforms replace `subprocess.std*`, which means they are not exposed to users.
// However, we still want to wait for their completion.
const waitForOriginalStreams = (originalStreams, subprocess, streamInfo)=>originalStreams.map((stream, fdNumber)=>stream === subprocess.stdio[fdNumber] ? undefined : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForStream"])(stream, fdNumber, streamInfo));
// Some `stdin`/`stdout`/`stderr` options create a stream, e.g. when passing a file path.
// The `.pipe()` method automatically ends that stream when `subprocess` ends.
// This makes sure we wait for the completion of those streams, in order to catch any error.
const waitForCustomStreamsEnd = (fileDescriptors, streamInfo)=>fileDescriptors.flatMap((param, fdNumber)=>{
        let { stdioItems } = param;
        return stdioItems.filter((param)=>{
            let { value, stream = value } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$stream$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStream"])(stream, {
                checkOpen: false
            }) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$standard$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isStandardStream"])(stream);
        }).map((param)=>{
            let { type, value, stream = value } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$resolve$2f$wait$2d$stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForStream"])(stream, fdNumber, streamInfo, {
                isSameDirection: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$stdio$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRANSFORM_TYPES"].has(type),
                stopOnExit: type === 'native'
            });
        });
    });
// Fails when the subprocess emits an `error` event
const throwOnSubprocessError = async (subprocess, param)=>{
    let { signal } = param;
    const [error] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["once"])(subprocess, 'error', {
        signal
    });
    throw error;
};
}),
"[project]/node_modules/execa/lib/convert/concurrent.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addConcurrentStream",
    ()=>addConcurrentStream,
    "initializeConcurrentStreams",
    ()=>initializeConcurrentStreams,
    "waitForConcurrentStreams",
    ()=>waitForConcurrentStreams
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/deferred.js [app-client] (ecmascript)");
;
const initializeConcurrentStreams = ()=>({
        readableDestroy: new WeakMap(),
        writableFinal: new WeakMap(),
        writableDestroy: new WeakMap()
    });
const addConcurrentStream = (concurrentStreams, stream, waitName)=>{
    const weakMap = concurrentStreams[waitName];
    if (!weakMap.has(stream)) {
        weakMap.set(stream, []);
    }
    const promises = weakMap.get(stream);
    const promise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDeferred"])();
    promises.push(promise);
    const resolve = promise.resolve.bind(promise);
    return {
        resolve,
        promises
    };
};
const waitForConcurrentStreams = async (param, subprocess)=>{
    let { resolve, promises } = param;
    resolve();
    const [isSubprocessExit] = await Promise.race([
        Promise.allSettled([
            true,
            subprocess
        ]),
        Promise.all([
            false,
            ...promises
        ])
    ]);
    return !isSubprocessExit;
};
}),
"[project]/node_modules/execa/lib/convert/shared.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/convert/shared.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:stream/promises)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/convert/shared.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:stream/promises)");

}}),
"[project]/node_modules/execa/lib/convert/readable.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createReadable",
    ()=>createReadable,
    "getReadableMethods",
    ()=>getReadableMethods,
    "getReadableOptions",
    ()=>getReadableOptions,
    "getSubprocessStdout",
    ()=>getSubprocessStdout,
    "onReadableDestroy",
    ()=>onReadableDestroy,
    "onStdoutFinished",
    ()=>onStdoutFinished
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/iterate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/utils/deferred.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/concurrent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/shared.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const createReadable = function(param) {
    let { subprocess, concurrentStreams, encoding } = param, { from, binary: binaryOption = true, preserveNewlines = true } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const binary = binaryOption || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(encoding);
    const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
    const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
    const { read, onStdoutDataDone } = getReadableMethods({
        subprocessStdout,
        subprocess,
        binary,
        encoding,
        preserveNewlines
    });
    const readable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Readable"]({
        read,
        destroy: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackify"])(onReadableDestroy.bind(undefined, {
            subprocessStdout,
            subprocess,
            waitReadableDestroy
        })),
        highWaterMark: readableHighWaterMark,
        objectMode: readableObjectMode,
        encoding: readableEncoding
    });
    onStdoutFinished({
        subprocessStdout,
        onStdoutDataDone,
        readable,
        subprocess
    });
    return readable;
};
const getSubprocessStdout = (subprocess, from, concurrentStreams)=>{
    const subprocessStdout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFromStream"])(subprocess, from);
    const waitReadableDestroy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addConcurrentStream"])(concurrentStreams, subprocessStdout, 'readableDestroy');
    return {
        subprocessStdout,
        waitReadableDestroy
    };
};
const getReadableOptions = (param, binary)=>{
    let { readableEncoding, readableObjectMode, readableHighWaterMark } = param;
    return binary ? {
        readableEncoding,
        readableObjectMode,
        readableHighWaterMark
    } : {
        readableEncoding,
        readableObjectMode: true,
        readableHighWaterMark: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_OBJECT_HIGH_WATER_MARK"]
    };
};
const getReadableMethods = (param)=>{
    let { subprocessStdout, subprocess, binary, encoding, preserveNewlines } = param;
    const onStdoutDataDone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$utils$2f$deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDeferred"])();
    const onStdoutData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iterateOnSubprocessStream"])({
        subprocessStdout,
        subprocess,
        binary,
        shouldEncode: !binary,
        encoding,
        preserveNewlines
    });
    return {
        read () {
            onRead(this, onStdoutData, onStdoutDataDone);
        },
        onStdoutDataDone
    };
};
// Forwards data from `stdout` to `readable`
const onRead = async (readable, onStdoutData, onStdoutDataDone)=>{
    try {
        const { value, done } = await onStdoutData.next();
        if (done) {
            onStdoutDataDone.resolve();
        } else {
            readable.push(value);
        }
    } catch (e) {}
};
const onStdoutFinished = async (param)=>{
    let { subprocessStdout, onStdoutDataDone, readable, subprocess, subprocessStdin } = param;
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForSubprocessStdout"])(subprocessStdout);
        await subprocess;
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeWaitForSubprocessStdin"])(subprocessStdin);
        await onStdoutDataDone;
        if (readable.readable) {
            readable.push(null);
        }
    } catch (error) {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeWaitForSubprocessStdin"])(subprocessStdin);
        destroyOtherReadable(readable, error);
    }
};
const onReadableDestroy = async (param, error)=>{
    let { subprocessStdout, subprocess, waitReadableDestroy } = param;
    if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForConcurrentStreams"])(waitReadableDestroy, subprocess)) {
        destroyOtherReadable(subprocessStdout, error);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForSubprocess"])(subprocess, error);
    }
};
const destroyOtherReadable = (stream, error)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["destroyOtherStream"])(stream, stream.readable, error);
};
}),
"[project]/node_modules/execa/lib/convert/writable.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createWritable",
    ()=>createWritable,
    "getSubprocessStdin",
    ()=>getSubprocessStdin,
    "getWritableMethods",
    ()=>getWritableMethods,
    "onStdinFinished",
    ()=>onStdinFinished,
    "onWritableDestroy",
    ()=>onWritableDestroy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/concurrent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/shared.js [app-client] (ecmascript)");
;
;
;
;
;
const createWritable = function(param) {
    let { subprocess, concurrentStreams } = param, { to } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
    const writable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Writable"]({
        ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
        destroy: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackify"])(onWritableDestroy.bind(undefined, {
            subprocessStdin,
            subprocess,
            waitWritableFinal,
            waitWritableDestroy
        })),
        highWaterMark: subprocessStdin.writableHighWaterMark,
        objectMode: subprocessStdin.writableObjectMode
    });
    onStdinFinished(subprocessStdin, writable);
    return writable;
};
const getSubprocessStdin = (subprocess, to, concurrentStreams)=>{
    const subprocessStdin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getToStream"])(subprocess, to);
    const waitWritableFinal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addConcurrentStream"])(concurrentStreams, subprocessStdin, 'writableFinal');
    const waitWritableDestroy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addConcurrentStream"])(concurrentStreams, subprocessStdin, 'writableDestroy');
    return {
        subprocessStdin,
        waitWritableFinal,
        waitWritableDestroy
    };
};
const getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal)=>({
        write: onWrite.bind(undefined, subprocessStdin),
        final: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackify"])(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal))
    });
// Forwards data from `writable` to `stdin`
const onWrite = (subprocessStdin, chunk, encoding, done)=>{
    if (subprocessStdin.write(chunk, encoding)) {
        done();
    } else {
        subprocessStdin.once('drain', done);
    }
};
// Ensures that the writable `final` and readable `end` events awaits the subprocess.
// Like this, any subprocess failure is propagated as a stream `error` event, instead of being lost.
// The user does not need to `await` the subprocess anymore, but now needs to await the stream completion or error.
// When multiple writables are targeting the same stream, they wait for each other, unless the subprocess ends first.
const onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal)=>{
    if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForConcurrentStreams"])(waitWritableFinal, subprocess)) {
        if (subprocessStdin.writable) {
            subprocessStdin.end();
        }
        await subprocess;
    }
};
const onStdinFinished = async (subprocessStdin, writable, subprocessStdout)=>{
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForSubprocessStdin"])(subprocessStdin);
        if (writable.writable) {
            writable.end();
        }
    } catch (error) {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeWaitForSubprocessStdout"])(subprocessStdout);
        destroyOtherWritable(writable, error);
    }
};
const onWritableDestroy = async (param, error)=>{
    let { subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy } = param;
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForConcurrentStreams"])(waitWritableFinal, subprocess);
    if (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForConcurrentStreams"])(waitWritableDestroy, subprocess)) {
        destroyOtherWritable(subprocessStdin, error);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForSubprocess"])(subprocess, error);
    }
};
const destroyOtherWritable = (stream, error)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$shared$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["destroyOtherStream"])(stream, stream.writable, error);
};
}),
"[project]/node_modules/execa/lib/convert/duplex.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createDuplex",
    ()=>createDuplex
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/readable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/writable.js [app-client] (ecmascript)");
;
;
;
;
;
const createDuplex = function(param) {
    let { subprocess, concurrentStreams, encoding } = param, { from, to, binary: binaryOption = true, preserveNewlines = true } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const binary = binaryOption || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(encoding);
    const { subprocessStdout, waitReadableDestroy } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSubprocessStdout"])(subprocess, from, concurrentStreams);
    const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSubprocessStdin"])(subprocess, to, concurrentStreams);
    const { readableEncoding, readableObjectMode, readableHighWaterMark } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getReadableOptions"])(subprocessStdout, binary);
    const { read, onStdoutDataDone } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getReadableMethods"])({
        subprocessStdout,
        subprocess,
        binary,
        encoding,
        preserveNewlines
    });
    const duplex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$stream$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Duplex"]({
        read,
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWritableMethods"])(subprocessStdin, subprocess, waitWritableFinal),
        destroy: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$util$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackify"])(onDuplexDestroy.bind(undefined, {
            subprocessStdout,
            subprocessStdin,
            subprocess,
            waitReadableDestroy,
            waitWritableFinal,
            waitWritableDestroy
        })),
        readableHighWaterMark,
        writableHighWaterMark: subprocessStdin.writableHighWaterMark,
        readableObjectMode,
        writableObjectMode: subprocessStdin.writableObjectMode,
        encoding: readableEncoding
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onStdoutFinished"])({
        subprocessStdout,
        onStdoutDataDone,
        readable: duplex,
        subprocess,
        subprocessStdin
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onStdinFinished"])(subprocessStdin, duplex, subprocessStdout);
    return duplex;
};
const onDuplexDestroy = async (param, error)=>{
    let { subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy } = param;
    await Promise.all([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onReadableDestroy"])({
            subprocessStdout,
            subprocess,
            waitReadableDestroy
        }, error),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onWritableDestroy"])({
            subprocessStdin,
            subprocess,
            waitWritableFinal,
            waitWritableDestroy
        }, error)
    ]);
};
}),
"[project]/node_modules/execa/lib/convert/iterable.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createIterable",
    ()=>createIterable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/encoding-option.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/fd-options.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/io/iterate.js [app-client] (ecmascript)");
;
;
;
const createIterable = function(subprocess, encoding) {
    let { from, binary: binaryOption = false, preserveNewlines = false } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const binary = binaryOption || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$encoding$2d$option$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BINARY_ENCODINGS"].has(encoding);
    const subprocessStdout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$fd$2d$options$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFromStream"])(subprocess, from);
    const onStdoutData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$io$2f$iterate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iterateOnSubprocessStream"])({
        subprocessStdout,
        subprocess,
        binary,
        shouldEncode: true,
        encoding,
        preserveNewlines
    });
    return iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);
};
const iterateOnStdoutData = async function*(onStdoutData, subprocessStdout, subprocess) {
    try {
        yield* onStdoutData;
    } finally{
        if (subprocessStdout.readable) {
            subprocessStdout.destroy();
        }
        await subprocess;
    }
};
}),
"[project]/node_modules/execa/lib/convert/add.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addConvertedStreams",
    ()=>addConvertedStreams
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/concurrent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/readable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/writable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$duplex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/duplex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$iterable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/convert/iterable.js [app-client] (ecmascript)");
;
;
;
;
;
const addConvertedStreams = (subprocess, param)=>{
    let { encoding } = param;
    const concurrentStreams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$concurrent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeConcurrentStreams"])();
    subprocess.readable = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$readable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createReadable"].bind(undefined, {
        subprocess,
        concurrentStreams,
        encoding
    });
    subprocess.writable = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$writable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createWritable"].bind(undefined, {
        subprocess,
        concurrentStreams
    });
    subprocess.duplex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$duplex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDuplex"].bind(undefined, {
        subprocess,
        concurrentStreams,
        encoding
    });
    subprocess.iterable = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$iterable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createIterable"].bind(undefined, subprocess, encoding);
    subprocess[Symbol.asyncIterator] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$convert$2f$iterable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createIterable"].bind(undefined, subprocess, encoding, {});
};
}),
"[project]/node_modules/execa/lib/methods/promise.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// The return value is a mixin of `subprocess` and `Promise`
__turbopack_context__.s([
    "mergePromise",
    ()=>mergePromise
]);
const mergePromise = (subprocess, promise)=>{
    for (const [property, descriptor] of descriptors){
        const value = descriptor.value.bind(promise);
        Reflect.defineProperty(subprocess, property, {
            ...descriptor,
            value
        });
    }
};
// eslint-disable-next-line unicorn/prefer-top-level-await
const nativePromisePrototype = (async ()=>{})().constructor.prototype;
const descriptors = [
    'then',
    'catch',
    'finally'
].map((property)=>[
        property,
        Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
}),
"[project]/node_modules/execa/lib/methods/main-async.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/execa/lib/methods/main-async.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:child_process)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/execa/lib/methods/main-async.js [app-client] (ecmascript)\n- Execution of *EcmascriptChunkItemContent::module_factory failed\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:child_process)");

}}),
"[project]/node_modules/execa/lib/methods/bind.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "mergeOptions",
    ()=>mergeOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/arguments/specific.js [app-client] (ecmascript)");
;
;
const mergeOptions = (boundOptions, options)=>{
    const newOptions = Object.fromEntries(Object.entries(options).map((param)=>{
        let [optionName, optionValue] = param;
        return [
            optionName,
            mergeOption(optionName, boundOptions[optionName], optionValue)
        ];
    }));
    return {
        ...boundOptions,
        ...newOptions
    };
};
const mergeOption = (optionName, boundOptionValue, optionValue)=>{
    if (DEEP_OPTIONS.has(optionName) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(boundOptionValue) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(optionValue)) {
        return {
            ...boundOptionValue,
            ...optionValue
        };
    }
    return optionValue;
};
const DEEP_OPTIONS = new Set([
    'env',
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$arguments$2f$specific$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FD_SPECIFIC_OPTIONS"]
]);
}),
"[project]/node_modules/execa/lib/methods/create.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createExeca",
    ()=>createExeca
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/is-plain-obj/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/parameters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$template$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/template.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$main$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/main-sync.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$main$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/main-async.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/bind.js [app-client] (ecmascript)");
;
;
;
;
;
;
const createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca)=>{
    const createNested = (mapArguments, boundOptions, setBoundExeca)=>createExeca(mapArguments, boundOptions, deepOptions, setBoundExeca);
    const boundExeca = function() {
        for(var _len = arguments.length, execaArguments = new Array(_len), _key = 0; _key < _len; _key++){
            execaArguments[_key] = arguments[_key];
        }
        return callBoundExeca({
            mapArguments,
            deepOptions,
            boundOptions,
            setBoundExeca,
            createNested
        }, ...execaArguments);
    };
    if (setBoundExeca !== undefined) {
        setBoundExeca(boundExeca, createNested, boundOptions);
    }
    return boundExeca;
};
const callBoundExeca = function(param, firstArgument) {
    let { mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested } = param;
    for(var _len = arguments.length, nextArguments = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
        nextArguments[_key - 2] = arguments[_key];
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$is$2d$plain$2d$obj$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(firstArgument)) {
        return createNested(mapArguments, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeOptions"])(boundOptions, firstArgument), setBoundExeca);
    }
    const { file, commandArguments, options, isSync } = parseArguments({
        mapArguments,
        firstArgument,
        nextArguments,
        deepOptions,
        boundOptions
    });
    return isSync ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$main$2d$sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execaCoreSync"])(file, commandArguments, options) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$main$2d$async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execaCoreAsync"])(file, commandArguments, options, createNested);
};
const parseArguments = (param)=>{
    let { mapArguments, firstArgument, nextArguments, deepOptions, boundOptions } = param;
    const callArguments = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$template$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTemplateString"])(firstArgument) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$template$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseTemplates"])(firstArgument, nextArguments) : [
        firstArgument,
        ...nextArguments
    ];
    const [initialFile, initialArguments, initialOptions] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$parameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeParameters"])(...callArguments);
    const mergedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeOptions"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$bind$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeOptions"])(deepOptions, boundOptions), initialOptions);
    const { file = initialFile, commandArguments = initialArguments, options = mergedOptions, isSync = false } = mapArguments({
        file: initialFile,
        commandArguments: initialArguments,
        options: mergedOptions
    });
    return {
        file,
        commandArguments,
        options,
        isSync
    };
};
}),
"[project]/node_modules/execa/lib/methods/command.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Main logic for `execaCommand()`
__turbopack_context__.s([
    "mapCommandAsync",
    ()=>mapCommandAsync,
    "mapCommandSync",
    ()=>mapCommandSync,
    "parseCommandString",
    ()=>parseCommandString
]);
const mapCommandAsync = (param)=>{
    let { file, commandArguments } = param;
    return parseCommand(file, commandArguments);
};
const mapCommandSync = (param)=>{
    let { file, commandArguments } = param;
    return {
        ...parseCommand(file, commandArguments),
        isSync: true
    };
};
// Convert `execaCommand(command)` into `execa(file, ...commandArguments)`
const parseCommand = (command, unusedArguments)=>{
    if (unusedArguments.length > 0) {
        throw new TypeError("The command and its arguments must be passed as a single string: ".concat(command, " ").concat(unusedArguments, "."));
    }
    const [file, ...commandArguments] = parseCommandString(command);
    return {
        file,
        commandArguments
    };
};
const parseCommandString = (command)=>{
    if (typeof command !== 'string') {
        throw new TypeError("The command must be a string: ".concat(String(command), "."));
    }
    const trimmedCommand = command.trim();
    if (trimmedCommand === '') {
        return [];
    }
    const tokens = [];
    for (const token of trimmedCommand.split(SPACES_REGEXP)){
        // Allow spaces to be escaped by a backslash if not meant as a delimiter
        const previousToken = tokens.at(-1);
        if (previousToken && previousToken.endsWith('\\')) {
            // Merge previous token with current one
            tokens[tokens.length - 1] = "".concat(previousToken.slice(0, -1), " ").concat(token);
        } else {
            tokens.push(token);
        }
    }
    return tokens;
};
const SPACES_REGEXP = / +/g;
}),
"[project]/node_modules/execa/lib/methods/script.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Sets `$.sync` and `$.s`
__turbopack_context__.s([
    "deepScriptOptions",
    ()=>deepScriptOptions,
    "mapScriptAsync",
    ()=>mapScriptAsync,
    "setScriptSync",
    ()=>setScriptSync
]);
const setScriptSync = (boundExeca, createNested, boundOptions)=>{
    boundExeca.sync = createNested(mapScriptSync, boundOptions);
    boundExeca.s = boundExeca.sync;
};
const mapScriptAsync = (param)=>{
    let { options } = param;
    return getScriptOptions(options);
};
// Main logic for `$.sync`
const mapScriptSync = (param)=>{
    let { options } = param;
    return {
        ...getScriptOptions(options),
        isSync: true
    };
};
// `$` is like `execa` but with script-friendly options: `{stdin: 'inherit', preferLocal: true}`
const getScriptOptions = (options)=>({
        options: {
            ...getScriptStdinOption(options),
            ...options
        }
    });
const getScriptStdinOption = (param)=>{
    let { input, inputFile, stdio } = param;
    return input === undefined && inputFile === undefined && stdio === undefined ? {
        stdin: 'inherit'
    } : {};
};
const deepScriptOptions = {
    preferLocal: true
};
}),
"[project]/node_modules/execa/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$",
    ()=>$,
    "execa",
    ()=>execa,
    "execaCommand",
    ()=>execaCommand,
    "execaCommandSync",
    ()=>execaCommandSync,
    "execaNode",
    ()=>execaNode,
    "execaSync",
    ()=>execaSync,
    "getCancelSignal",
    ()=>getCancelSignal,
    "getEachMessage",
    ()=>getEachMessage,
    "getOneMessage",
    ()=>getOneMessage,
    "sendMessage",
    ()=>sendMessage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/create.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$command$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/command.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/node.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$script$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/methods/script.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$methods$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/execa/lib/ipc/methods.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const execa = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createExeca"])(()=>({}));
const execaSync = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createExeca"])(()=>({
        isSync: true
    }));
const execaCommand = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createExeca"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$command$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapCommandAsync"]);
const execaCommandSync = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createExeca"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$command$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapCommandSync"]);
const execaNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createExeca"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapNode"]);
const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$create$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createExeca"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$script$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapScriptAsync"], {}, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$script$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepScriptOptions"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$methods$2f$script$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setScriptSync"]);
const { sendMessage, getOneMessage, getEachMessage, getCancelSignal } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$execa$2f$lib$2f$ipc$2f$methods$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getIpcExport"])();
;
}),
]);

//# sourceMappingURL=node_modules_execa_836b1c1b._.js.map